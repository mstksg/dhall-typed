-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/dhall-typed#readme</a>
@package dhall-typed
@version 0.1.0.0

module Dhall.Typed.Type.Index

-- | Witness an item in a type-level list by providing its index.
data Index (a :: [k]) (b :: k) :: forall k. () => [k] -> k -> Type
[IZ] :: forall k (a :: [k]) (b :: k) (as :: [k]). () => Index (b : as) b
[IS] :: forall k (a :: [k]) (b :: k) (bs :: [k]) (b1 :: k). () => Index bs b -> Index (b1 : bs) b
data SIndex as a :: Index as a -> Type
[SIZ] :: SIndex (a : as) a  'IZ
[SIS] :: SIndex as b i -> SIndex (a : as) b ( 'IS i)
class SIndexI as a (i :: Index as a)
sIndex :: SIndexI as a i => SIndex as a i
sSameIx :: SIndex as a i -> SIndex as a j -> Maybe (i :~: j)
fromSIndex :: SIndex as a i -> Index as a
type family SIndexOf as a (i :: Index as a) = (s :: SIndex as a i) | s -> i
data Delete :: [k] -> [k] -> k -> Type
[DelZ] :: Delete (a : as) as a
[DelS] :: Delete as bs c -> Delete (a : as) (a : bs) c
delete :: Delete as bs a -> Index as b -> Maybe (Index bs b)
type family ISMaybe (i :: Maybe (Index as a)) :: Maybe (Index (b : as) a)
type family Del as bs a b (d :: Delete as bs a) (i :: Index as b) :: Maybe (Index bs b)
data SDelete as bs a :: Delete as bs a -> Type
[SDelZ] :: SDelete (a : as) as a  'DelZ
[SDelS] :: SDelete as bs c del -> SDelete (a : as) (a : bs) c ( 'DelS del)
sDelete :: SDelete as bs a del -> SIndex as b i -> GetDeleted as bs a b del i
data GetDeleted as bs a b :: Delete as bs a -> Index as b -> Type
[GotDeleted] :: Del as bs a b del i ~  'Nothing => (a :~: b) -> GetDeleted as bs a b del i
[ThatsToxic] :: Del as bs a b del i ~  'Just j => SIndex bs b j -> GetDeleted as bs a b del i

-- | This is just flipped delete, heh.
data Insert :: [k] -> [k] -> k -> Type
[InsZ] :: Insert as (a : as) a
[InsS] :: Insert as bs c -> Insert (a : as) (a : bs) c
insert :: Insert as bs a -> Index as b -> Index bs b
type family Ins as bs a b (ins :: Insert as bs a) (i :: Index as b) :: Index bs b
sInsert :: forall as bs a b ins i. () => SInsert as bs a ins -> SIndex as b i -> SIndex bs b (Ins as bs a b ins i)
data SInsert as bs a :: Insert as bs a -> Type
[SInsZ] :: SInsert as (a : as) a  'InsZ
[SInsS] :: SInsert as bs c ins -> SInsert (a : as) (a : bs) c ( 'InsS ins)

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
instance forall k (as :: [k]) (a :: k) (i :: Data.Type.Universe.Index as a). GHC.Show.Show (Dhall.Typed.Type.Index.SIndex as a i)
instance forall k (a :: k) (as :: [k]). Dhall.Typed.Type.Index.SIndexI (a : as) a 'Data.Type.Universe.IZ
instance forall k (as :: [k]) (b :: k) (i :: Data.Type.Universe.Index as b) (a :: k). Dhall.Typed.Type.Index.SIndexI as b i => Dhall.Typed.Type.Index.SIndexI (a : as) b ('Data.Type.Universe.IS i)
instance forall k (as :: [k]) (a :: k). Data.Singletons.Internal.SingKind (Data.Type.Universe.Index as a)

module Dhall.Typed.Type.N
data N
Z :: N
S :: N -> N

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
type SN = (Sing :: N -> Type)
fromNatural :: Natural -> N
toNatural :: N -> Natural
type ZSym0 = Z
data SSym0 :: (~>) N N
type SSym1 (t6989586621679220425 :: N) = S t6989586621679220425
data IsLength :: [k] -> N -> Type
[ILZ] :: IsLength '[]  'Z
[ILS] :: IsLength as n -> IsLength (a : as) ( 'S n)
data Fin :: N -> Type
[FZ] :: Fin ( 'S n)
[FS] :: Fin n -> Fin ( 'S n)
data SFin n :: Fin n -> Type
[SFZ] :: SFin ( 'S n)  'FZ
[SFS] :: SFin n x -> SFin ( 'S n) ( 'FS x)
type family ShiftFin n (i :: Fin n) :: Fin n
data LTE :: N -> N -> Type
[LTEZ] :: LTE  'Z m
[LTES] :: LTE n m -> LTE ( 'S n) ( 'S m)
type N0 =  'Z
type N1 =  'S N0
type N2 =  'S N1
type N3 =  'S N2
type N4 =  'S N3
type N5 =  'S N4
type F0 =  'FZ
type F1 =  'FS F0
type F2 =  'FS F1
type F3 =  'FS F2
type F4 =  'FS F3
type F5 =  'FS F4
sf0 :: SFin ( 'S n) F0
sf1 :: SFin ( 'S ( 'S n)) F1
sf2 :: SFin ( 'S ( 'S ( 'S n))) F2
sf3 :: SFin ( 'S ( 'S ( 'S ( 'S n)))) F3
sf4 :: SFin ( 'S ( 'S ( 'S ( 'S ( 'S n))))) F4
sf5 :: SFin ( 'S ( 'S ( 'S ( 'S ( 'S ( 'S n)))))) F5
instance GHC.Show.Show Dhall.Typed.Type.N.N
instance GHC.Classes.Ord Dhall.Typed.Type.N.N
instance GHC.Classes.Eq Dhall.Typed.Type.N.N
instance Data.Singletons.ShowSing.ShowSing Dhall.Typed.Type.N.N => GHC.Show.Show (Data.Singletons.Internal.Sing z)
instance Data.Singletons.Prelude.Eq.PEq Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.ShowsPrec_6989586621679222784Sym0
instance Data.Singletons.Prelude.Show.PShow Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.ShowsPrec_6989586621679222784Sym1 a6989586621679222781)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.ShowsPrec_6989586621679222784Sym2 a6989586621679222782 a6989586621679222781)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.Compare_6989586621679222014Sym0
instance Data.Singletons.Prelude.Ord.POrd Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.Compare_6989586621679222014Sym1 a6989586621679222012)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.SSym0
instance Data.Singletons.Internal.SingI Dhall.Typed.Type.N.SSym0
instance Data.Singletons.Internal.SingKind Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Ord.SOrd Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Ord.SOrd Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Show.SShow Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Show.SShow Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Eq.SEq Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Eq.SEq Dhall.Typed.Type.N.N
instance Data.Singletons.Decide.SDecide Dhall.Typed.Type.N.N => Data.Singletons.Decide.SDecide Dhall.Typed.Type.N.N
instance Data.Singletons.Internal.SingI 'Dhall.Typed.Type.N.Z
instance Data.Singletons.Internal.SingI n => Data.Singletons.Internal.SingI ('Dhall.Typed.Type.N.S n)
instance Data.Singletons.Internal.SingI (Data.Singletons.Internal.TyCon1 'Dhall.Typed.Type.N.S)

module Dhall.Typed.Plugin
plugin :: Plugin

module Dhall.Typed.Type.Option
data Option :: (k -> Type) -> Maybe k -> Type
[Noot] :: Option f  'Nothing
[Juus] :: f a -> Option f ( 'Just a)

module Dhall.Typed.Type.Prod
data Prod :: (k -> Type) -> [k] -> Type
[Ø] :: Prod f '[]
[:<] :: f a -> Prod f as -> Prod f (a : as)
infixr 5 :<
traverseProd :: forall f g h as. Applicative h => (forall x. f x -> h (g x)) -> Prod f as -> h (Prod g as)
mapProd :: forall f g as. () => (forall x. f x -> g x) -> Prod f as -> Prod g as
zipProd :: Prod f as -> Prod g as -> Prod (f :*: g) as
singProd :: Sing as -> Prod Sing as
prodSing :: Prod Sing as -> Sing as
allProd :: Sing as -> WitAll [] (TyCon1 f) as -> Prod f as
prodAll :: Prod f as -> WitAll [] (TyCon1 f) as
ixProd :: Prod f as -> Index as a -> f a
data SeqListEq :: Seq a -> [a] -> Type
[SeqListEq] :: SeqListEq xs ys
type family IxProd f as b (p :: Prod f as) (i :: Index as b) :: f b
data SProd f as :: Prod f as -> Type
[SØ] :: SProd f '[]  'Ø
[:%<] :: Sing (x :: f a) -> SProd f as xs -> SProd f (a : as) (x :< xs)
sIxProd :: SProd f as xs -> SIndex as a i -> Sing (IxProd f as a xs i)
instance forall k (f :: k -> *) (as :: [k]). (forall (a :: k). GHC.Show.Show (f a)) => GHC.Show.Show (Dhall.Typed.Type.Prod.Prod f as)


-- | Implementing a typed lambda calculus. Uses De Bruijn indices in
--   separate namespaces (that is, kind, type, term variables all have
--   their own separate De Bruijn indexing)
--   
--   We have a hierarchy: Term -&gt; Type -&gt; Kind -&gt; Sort. We can
--   stop at Sort because we don't allow any Sort variables, so there is no
--   need to talk about the "type" of any Sorts. Disallowing variables
--   effectively stops the chain.
--   
--   It looks like each level has some sets of constructors just from its
--   position on the chain.
--   
--   <ul>
--   <li>At all levels, we have <i>primitives</i>. Term-level primitives
--   are built-in functions and values and literals. Type-level primitives
--   are built-in types and type functions. Dhall has no kind- or
--   sort-level primitives.</li>
--   <li>If a level has variables (Terms, Types, Kinds), we gain some
--   constructors:<ul><li>Var, the variable constructor j Lam, the function
--   abstraction</li><li>App, the function application</li></ul></li>
--   <li>If a level has variables and its "type" also has variables (Terms,
--   Types), we gain some constructors:<ul><li>Poly, the type
--   abstraction</li><li>Inst (instantiation), the type
--   application</li></ul></li>
--   <li>If a level is the "type" of something (n &gt;= 1), we gain a
--   function type constructor, the type of function abstractions in the
--   immediately lower level.</li>
--   <li>If a level is the "type" of a "type" of something (n &gt;= 2), we
--   gain an "constant" constructor that links the two layers below it
--   together. Examples are the Kind sort that links Kinds to Types (all
--   types have kinds of sort Kind), and the Type kind that links types to
--   values (all terms have types of kind Type)</li>
--   <li>If a type is the "type" of something (n &gt;= 1), <i>and</i> it
--   has variables, we have a Pi type constructor, the type of type
--   abstractions (type-polymorphic values) in the lower level.</li>
--   </ul>
--   
--   We actually gain a Pi type for our current level, and each level above
--   our current level (that has variables). So for the Type level, we have
--   Type-Pi and Kind-Pi, and for the Kind level, we have Kind-Pi.
--   
--   So to summarize:
--   
--   <ul>
--   <li>n = 3: Sort has a constant (it is n &gt;= 2) and a function type
--   constructor (it is n &gt;= 1). It could also potentially have
--   primitives, but Dhall has no sort primitives.</li>
--   <li>n = 2: Kind has variables, so it has Var, Lam, and App. It has a
--   constant (they are n &gt;= 2) and a function type constructor and a Pi
--   constructor (it is n &gt;= 1 and has variables). It could also
--   potentially have primitives; Dhall has only record and union kinds as
--   primitives.</li>
--   <li>n = 1: Type has variables, so it has Var, Lam, and App. It has a
--   function type constructor and a Pi constructor (it is n &gt;= 1 and
--   has variables). Because its "type" has variables (Kind), it also has
--   Poly and Inst. It has primitives, and in Dhall ther are several.</li>
--   <li>n = 0: Term has variables, so it has Var, Lam, and App. Because
--   its "type" has variables, it has Poly and Inst. In Dhall, it has
--   multitudes of primitives.</li>
--   </ul>
module Dhall.Typed.LC
instance forall (ts :: [Dhall.Typed.LC.DSort]) (vs :: [Dhall.Typed.LC.DKind ts 'Dhall.Typed.LC.Kind]) (a :: Dhall.Typed.LC.DKind ts 'Dhall.Typed.LC.Kind). Data.Singletons.Internal.SingKind (Dhall.Typed.LC.DType ts vs a)
instance Data.Singletons.Internal.SingKind (Dhall.Typed.LC.DKind ts a)
instance Data.Singletons.Internal.SingKind Dhall.Typed.LC.DSort

module Dhall.Typed.Type.Sum
data Sum :: (k -> Type) -> [k] -> Type
[Sum] :: Index as a -> f a -> Sum f as
anySum :: WitAny [] (TyCon1 f) as -> Sum f as
sumAny :: Sum f as -> WitAny [] (TyCon1 f) as
instance forall k (f :: k -> *) (as :: [k]). (forall (a :: k). GHC.Show.Show (f a)) => GHC.Show.Show (Dhall.Typed.Type.Sum.Sum f as)

module Dhall.Typed.Type.Symbol
data TLSSym :: Symbol -> Type
[TLSSym] :: TLSSym s

module Dhall.Typed.Core

-- | Represents the possible sorts encountered in Dhall.
--   
--   Note that this implementation allows records of kinds with sorts other
--   than <a>Kind</a>, so <tt>{ foo : Kind -&gt; Kind }</tt> would
--   typecheck, even though normal Dhall forbids this.
data DSort :: Type
[Kind] :: DSort
[:*>] :: DSort -> DSort -> DSort
[SRecord] :: AggType ()  '() ls as -> Prod (Const DSort) as -> DSort
[SUnion] :: AggType ()  '() ls as -> Prod (Const DSort) as -> DSort
data KPrim :: [DSort] -> DSort -> Type
[KRecord] :: AggType DSort  'Kind ls as -> KPrim as  'Kind
[KUnion] :: AggType DSort  'Kind ls as -> KPrim as  'Kind
[KRecordLit] :: RecordVal () (Const DSort)  '() ls ks at bs as -> KPrim (Map GetConstSym0 as) ( 'SRecord at bs)
[KUnionLit] :: UnionVal () (Const DSort)  '() ls ks at bs ( 'Const a) -> KPrim '[a] ( 'SRecord at bs)

-- | Represents the possible types encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DKind</a> '[r, s] t
--   </pre>
--   
--   Describes a kind of sort <tt>t</tt> with possible kind variables of
--   sorts <tt>r</tt> and <tt>s</tt>.
--   
--   Something of type <tt><a>DKind</a> '[] t</tt> is a kind of sort
--   <tt>t</tt> with no free variables.
data DKind :: [DSort] -> DSort -> Type
[KVar] :: Index ts a -> DKind ts a
[KLam] :: SDSort t -> DKind (t : ts) a -> DKind ts (t :*> a)
[KApp] :: DKind ts (a :*> b) -> DKind ts a -> DKind ts b
[:~>] :: DKind ts  'Kind -> DKind ts  'Kind -> DKind ts  'Kind
[KPi] :: SDSort t -> DKind (t : ts) a -> DKind ts a
[Type] :: DKind ts  'Kind
[KP] :: KPrim as a -> Prod (DKind ts) as -> DKind ts a
infixr 1 :~>
data SomeKind :: [DSort] -> Type
[SomeKind] :: SDSort a -> DKind ts a -> SomeKind ts
type a :~> b = a :~> b
infixr 1 :~>

-- | Shift all kind variables in a kind expression of sort <tt>b</tt> to
--   account for a new bound variable of sort <tt>a</tt>, to be inserted at
--   the position indicated by the <a>Insert</a>.
type family KShift ts ps a b (ins :: Insert ts ps a) (x :: DKind ts b) :: DKind ps b

-- | Primitives of Dhall types, built into the language.
data TPrim ts :: [DKind ts 'Kind] -> DKind ts 'Kind -> Type
[Bool] :: TPrim ts '[]  'Type
[Natural] :: TPrim ts '[]  'Type
[Record] :: AggType (DKind ts  'Kind)  'Type ls as -> TPrim ts as  'Type
[List] :: TPrim ts '[] ( 'Type :~>  'Type)
[Optional] :: TPrim ts '[] ( 'Type :~>  'Type)
[TRecordLit] :: RecordVal DSort (DKind ts)  'Kind ls ks at bs as -> TPrim ts as ( 'KP ( 'KRecord at) bs)
[TUnionLit] :: UnionVal DSort (DKind ts)  'Kind ls ks at bs a -> TPrim ts '[a] ( 'KP ( 'KRecord at) bs)

-- | Represents the possible types encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DTerm</a> '[r, s] '[k, j] a
--   </pre>
--   
--   Describes a type of kind <tt>a</tt> with possible:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   </ul>
--   
--   Something of type <tt><a>DType</a> '[] '[] a</tt> is a type of kind
--   <tt>a</tt> with no free variables.
data DType ts :: [DKind ts 'Kind] -> DKind ts 'Kind -> Type
[TVar] :: Index us a -> DType ts us a
[TLam] :: SDKind ts  'Kind u -> DType ts (u : us) a -> DType ts us (u :~> a)
[TApp] :: DType ts us (a :~> b) -> DType ts us a -> DType ts us b
[TP] :: TPrim ts as a -> Prod (DType ts us) as -> DType ts us a
[TPoly] :: SDSort t -> DType (t : ts) (Map (KShiftSym ts (t : ts) t  'Kind  'InsZ) us) a -> DType ts us ( 'KPi (SDSortOf t) a)
[TInst] :: DType ts us ( 'KPi (SDSortOf t) b) -> SDKind ts t a -> DType ts us (KSub (t : ts) ts t  'Kind  'DelZ a b)
[:->] :: DType ts us  'Type -> DType ts us  'Type -> DType ts us  'Type
[Pi] :: SDKind ts  'Kind u -> DType ts (u : us) a -> DType ts us a
infixr 0 :->
infixl 9 `TApp`
data SomeType ts :: [DKind ts 'Kind] -> Type
[SomeType] :: SDKind ts  'Kind a -> DType ts us a -> SomeType ts us

-- | The kind of types with values. For example <tt>Int :: Type</tt>.
type Type = Type
type TBool =  'TP  'Bool  'Ø
type TNatural =  'TP  'Natural  'Ø
type TList =  'TP  'List  'Ø
type TOptional =  'TP  'Optional  'Ø
type (:$) =  'TApp
infixl 9 :$
type a :-> b = a :-> b
infixr 0 :->

-- | Shift all type variables in a type expression of kind <tt>b</tt> to
--   account for a new bound variable of kind <tt>a</tt>, to be inserted at
--   the position indicated by the <a>Insert</a>.
type family Shift ts us qs a b (ins :: Insert us qs a) (x :: DType ts us b) :: DType ts qs b

-- | Primitives of Dhall terms, built into the language.
data Prim ts us :: [DType ts us 'Type] -> DType ts us 'Type -> Type
[BoolLit] :: Bool -> Prim ts us '[] TBool
[NaturalLit] :: Natural -> Prim ts us '[] TNatural
[NaturalFold] :: Prim ts us '[] (TNatural :->  'Pi  'SType (( 'TVar  'IZ :->  'TVar  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)))
[NaturalBuild] :: Prim ts us '[] ( 'Pi  'SType (( 'TVar  'IZ :->  'TVar  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> TNatural)
[NaturalPlus] :: Prim ts us '[TNatural, TNatural] TNatural
[NaturalTimes] :: Prim ts us '[TNatural, TNatural] TNatural
[NaturalIsZero] :: Prim ts us '[] (TNatural :-> TBool)
[ListFold] :: Prim ts us '[] ( 'Pi  'SType ((TList :$  'TVar  'IZ) :->  'Pi  'SType (( 'TVar ( 'IS  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'TVar  'IZ :->  'TVar  'IZ))))
[ListBuild] :: Prim ts us '[] ( 'Pi  'SType ( 'Pi  'SType (( 'TVar ( 'IS  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> (TList :$  'TVar  'IZ)))
[ListAppend] :: Prim ts us '[TList :$ a, TList :$ a] (TList :$ a)
[ListHead] :: Prim ts us '[] ( 'Pi  'SType ((TList :$  'TVar  'IZ) :-> (TOptional :$  'TVar  'IZ)))
[ListLast] :: Prim ts us '[] ( 'Pi  'SType ((TList :$  'TVar  'IZ) :-> (TOptional :$  'TVar  'IZ)))
[ListReverse] :: Prim ts us '[] ( 'Pi  'SType ((TList :$  'TVar  'IZ) :-> (TList :$  'TVar  'IZ)))
[Some] :: Prim ts us '[a] (TOptional :$ a)
[None] :: Prim ts us '[] ( 'Pi  'SType (TOptional :$  'TVar  'IZ))
[RecordLit] :: RecordVal (DKind ts  'Kind) (DType ts us)  'Type ls ks at bs as -> Prim ts us as ( 'TP ( 'Record at) bs)
[UnionLit] :: UnionVal (DKind ts  'Kind) (DType ts us)  'Type ls ks at bs a -> Prim ts us '[a] ( 'TP ( 'Record at) bs)

-- | Primitive functors of Dhall terms, built into the language.
data PrimF ts us :: (Type -> Type) -> DType ts us ( 'Type :~> 'Type) -> Type
[ListLit] :: PrimF ts us Seq TList
[OptionalLit] :: PrimF ts us Maybe TOptional

-- | Represents the possible terms encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DTerm</a> '[r, s] '[k, j] '[a, b, c] d
--   </pre>
--   
--   Describes a term of type <tt>d</tt> with possible:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   <li>Variables of type <tt>a</tt>, <tt>b</tt>, <tt>c</tt></li>
--   </ul>
--   
--   Something of type <tt><a>DTerm</a> '[] '[] '[] a</tt> is a term of
--   type <tt>a</tt> with no free variables.
data DTerm ts (us :: [DKind ts 'Kind]) :: [DType ts us 'Type] -> DType ts us 'Type -> Type
[Var] :: Index vs a -> DTerm ts us vs a
[Lam] :: SDType ts us  'Type v -> DTerm ts us (v : vs) a -> DTerm ts us vs (v :-> a)
[App] :: DTerm ts us vs (a :-> b) -> DTerm ts us vs a -> DTerm ts us vs b
[P] :: Prim ts us as a -> Prod (DTerm ts us vs) as -> DTerm ts us vs a
[PF] :: PrimF ts us f g -> SDType ts us  'Type a -> f (DTerm ts us vs a) -> DTerm ts us vs (g :$ a)
[Poly] :: SDKind ts  'Kind u -> DTerm ts (u : us) (Map (ShiftSym ts us (u : us) u  'Type  'InsZ) vs) a -> DTerm ts us vs ( 'Pi (SDKindOf ts  'Kind u) a)
[Inst] :: DTerm ts us vs ( 'Pi (SDKindOf ts  'Kind u) b) -> SDType ts us u a -> DTerm ts us vs (Sub ts (u : us) us u  'Type  'DelZ a b)
data SomeTerm ts us :: [DType ts us 'Type] -> Type
[SomeTerm] :: SDType ts us  'Type a -> DTerm ts us vs a -> SomeTerm ts us vs

-- | A <a>DExpr</a> fully covers all legal type-checking dhall terms. A
--   value of type
--   
--   <pre>
--   <a>DExpr</a> '[ r, s ] '[ k, j ] '[ a, b ] n
--   </pre>
--   
--   Represents a dhall expression on level <tt>n</tt> (<tt>'FZ</tt> =
--   term, <tt>'FS 'FZ</tt> = type, etc.) with potential:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   <li>Term variables of type <tt>a</tt>, <tt>b</tt></li>
--   </ul>
--   
--   A value of type <tt><a>DExpr</a> '[] '[] '[] n</tt> represents a typed
--   dhall expression with no free variables.
--   
--   You can pattern match on it to get a value of one of the "levels" of
--   the dhall type hierarchy, and also to get the "type" and
--   representation of it.
--   
--   The number of level goes up to 4 :
--   
--   <ul>
--   <li><tt>F0</tt>: term</li>
--   <li><tt>F1</tt>: type</li>
--   <li><tt>F2</tt>: kind</li>
--   <li><tt>F3</tt>: sort</li>
--   <li><tt>F4</tt>: "meta" level, outside of the hierarchy. This is
--   necessary because the original untyped Dhall AST itself contains this
--   level.</li>
--   </ul>
--   
--   Note that you can restrict this to only <a>DExpr</a> past a given
--   "level" by asking for or returning a <tt><a>DExpr</a> ts us vs ('FS
--   n)</tt>, for instance. Such a value will only contain types, kinds,
--   sorts, or meta. A <tt><a>DExpr</a> ts us vs ('FS ('FS n))</tt> will
--   only contain kinds, sorts, or meta, etc.
data DExpr ts us :: [DType ts us 'Type] -> Fin N5 -> Type
[DEMeta] :: DExpr ts us vs F4
[DESort] :: DSort -> DExpr ts us vs F3
[DEKind] :: SomeKind ts -> DExpr ts us vs F2
[DEType] :: SomeType ts us -> DExpr ts us vs F1
[DETerm] :: SomeTerm ts us vs -> DExpr ts us vs F0

-- | Hides the "level" of a <a>DExpr</a>. Pattern match to find it. Can be
--   useful when returning a <a>DExpr</a> of level unknown until runtime,
--   or storing <a>DExpr</a> of multiple levels in a container.
data SomeDExpr ts us :: [DType ts us 'Type] -> Type
[SomeDExpr] :: SFin N5 l -> DExpr ts us vs l -> SomeDExpr ts us vs

-- | Get the meta-level "type" of a <a>DExpr</a>. If it's a term, this will
--   return its type. If it's a type, this returns its type, etc. It
--   essentially goes up one "level" of the Dhall type hierarchy.
--   
--   This will not typecheck if given a "Level 4" fin, so you cannot pass
--   in <a>DEMeta</a>.
dExprType :: DExpr ts us vs n -> DExpr ts us vs (ShiftFin N5 n)

-- | Meta-level type describing a collection or aggregation of types. Used
--   for specifying records and unions.
data AggType k :: k -> [Symbol] -> [k] -> Type
[ATZ] :: AggType k r '[] '[]
[ATS] :: AggType k r ls as -> AggType k r (l : ls) (r : as)

-- | GADT for specifying a record value matching an <a>AggType</a>.
--   
--   Basically you just need to stack as many <a>RVS</a> <a>RVZ</a> as
--   there are fields in the record.
data RecordVal k (j :: k -> Type) (r :: k) (ls :: [Symbol]) (ks :: [k]) :: AggType k r ls ks -> Prod j ks -> [j r] -> Type
[RVZ] :: RecordVal k j r '[] '[]  'ATZ  'Ø '[]
[RVS] :: RecordVal k j r ls ks at bs as -> RecordVal k j r (l : ls) (r : ks) ( 'ATS at) (b :< bs) (a : as)

-- | GADT for specifying a union value matching an <a>AggType</a>.
data UnionVal k (j :: k -> Type) (r :: k) (ls :: [Symbol]) (ks :: [k]) :: AggType k r ls ks -> Prod j ks -> j r -> Type
[UnionVal] :: SIndex ks r i -> UnionVal k j r ls ks at bs (IxProd j ks r bs i)
data SDSort :: DSort -> Type
[SKind] :: SDSort  'Kind
[:%*>] :: SDSort s -> SDSort t -> SDSort (s :*> t)
data SDKind ts a :: DKind ts a -> Type
[SKVar] :: SIndex ts a i -> SDKind ts a ( 'KVar i)
[SKLam] :: SDSort t -> SDKind (t : ts) a x -> SDKind ts (t :*> a) ( 'KLam (SDSortOf t) x)
[SKApp] :: SDKind ts (a :*> b) f -> SDKind ts a x -> SDKind ts b ( 'KApp f x)
[:%~>] :: SDKind ts  'Kind x -> SDKind ts  'Kind y -> SDKind ts  'Kind (x :~> y)
[SType] :: SDKind ts  'Kind  'Type
data STPrim ts as a :: TPrim ts as a -> Type
[SBool] :: STPrim ts '[]  'Type  'Bool
[SNatural] :: STPrim ts '[]  'Type  'Natural
[SList] :: STPrim ts '[] ( 'Type :~>  'Type)  'List
[SOptional] :: STPrim ts '[] ( 'Type :~>  'Type)  'Optional
data SDType ts us a :: DType ts us a -> Type
[STVar] :: SIndex us a i -> SDType ts us a ( 'TVar i)
[STLam] :: SDKind ts  'Kind u -> SDType ts (u : us) a x -> SDType ts us (u :~> a) ( 'TLam (SDKindOf ts  'Kind u) x)
[STApp] :: SDType ts us (a :~> b) f -> SDType ts us a x -> SDType ts us b ( 'TApp f x)
[:%->] :: SDType ts us  'Type x -> SDType ts us  'Type y -> SDType ts us  'Type (x :-> y)
[STP] :: STPrim ts as a x -> SProd (DType ts us) as p -> SDType ts us a ( 'TP x p)
data SPrim ts us as a :: Prim ts us as a -> Type
[SBoolLit] :: Sing b -> SPrim ts us '[] TBool ( 'BoolLit b)
[SNaturalLit] :: Sing n -> SPrim ts us '[] TNatural ( 'NaturalLit n)
data SPrimF ts us f g :: PrimF ts us f g -> Type
[SListLit] :: SPrimF ts us Seq TList  'ListLit
[SOptionalLit] :: SPrimF ts us Maybe TOptional  'OptionalLit
data SDTerm ts us vs a :: DTerm ts us vs a -> Type
[SVar] :: SIndex vs a i -> SDTerm ts us vs a ( 'Var i)
data KShiftSym ts ps a b :: Insert ts ps a -> DKind ts b ~> DKind ps b
data ShiftSym ts us qs a b :: Insert us qs a -> DType ts us b ~> DType ts qs b

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
type family Map (f :: a ~> b) (xs :: [a]) :: [b]
data MapSym (f :: a ~> b) :: [a] ~> [b]
instance forall (ts :: [Dhall.Typed.Core.DSort]) (us :: [Dhall.Typed.Core.DKind ts 'Dhall.Typed.Core.Kind]) (vs :: [Dhall.Typed.Core.DType ts us 'Dhall.Typed.Core.Type]) (a :: Dhall.Typed.Core.DType ts us 'Dhall.Typed.Core.Type). Data.Singletons.Internal.SingKind (Dhall.Typed.Core.DTerm ts us vs a)
instance forall (ts :: [Dhall.Typed.Core.DSort]) (us :: [Dhall.Typed.Core.DKind ts 'Dhall.Typed.Core.Kind]) (as :: [Dhall.Typed.Core.DType ts us 'Dhall.Typed.Core.Type]) (a :: Dhall.Typed.Core.DType ts us 'Dhall.Typed.Core.Type). Data.Singletons.Internal.SingKind (Dhall.Typed.Core.Prim ts us as a)
instance forall (ts :: [Dhall.Typed.Core.DSort]) (us :: [Dhall.Typed.Core.DKind ts 'Dhall.Typed.Core.Kind]) (f :: * -> *) (g :: Dhall.Typed.Core.DType ts us ('Dhall.Typed.Core.Type Dhall.Typed.Core.:~> 'Dhall.Typed.Core.Type)). Data.Singletons.Internal.SingKind (Dhall.Typed.Core.PrimF ts us f g)
instance forall (ts :: [Dhall.Typed.Core.DSort]) (us :: [Dhall.Typed.Core.DKind ts 'Dhall.Typed.Core.Kind]) (a :: Dhall.Typed.Core.DKind ts 'Dhall.Typed.Core.Kind). Data.Singletons.Internal.SingKind (Dhall.Typed.Core.DType ts us a)
instance forall (ts :: [Dhall.Typed.Core.DSort]) (as :: [Dhall.Typed.Core.DKind ts 'Dhall.Typed.Core.Kind]) (a :: Dhall.Typed.Core.DKind ts 'Dhall.Typed.Core.Kind). Data.Singletons.Internal.SingKind (Dhall.Typed.Core.TPrim ts as a)
instance Data.Singletons.Internal.SingKind (Dhall.Typed.Core.DKind ts a)
instance Data.Singletons.Internal.SingKind Dhall.Typed.Core.DSort

module Dhall.Typed
