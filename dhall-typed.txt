-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/dhall-typed#readme</a>
@package dhall-typed
@version 0.1.0.0

module Dhall.Typed.Type.Bool
type family (x :: Bool) && (y :: Bool) :: Bool

module Dhall.Typed.Type.N
data N
Z :: N
S :: N -> N

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
type SN = (Sing :: N -> Type)
fromNatural :: Natural -> N
toNatural :: N -> Natural
type ZSym0 = Z
data SSym0 :: (~>) N N
type SSym1 (t6989586621679139462 :: N) = S t6989586621679139462
data IsLength :: [k] -> N -> Type
[ILZ] :: IsLength '[]  'Z
[ILS] :: IsLength as n -> IsLength (a : as) ( 'S n)
data Fin :: N -> Type
[FZ] :: Fin ( 'S n)
[FS] :: Fin n -> Fin ( 'S n)
data SFin n :: Fin n -> Type
[SFZ] :: SFin ( 'S n)  'FZ
[SFS] :: SFin n x -> SFin ( 'S n) ( 'FS x)
type family ShiftFin n (i :: Fin n) :: Fin n
data LTE :: N -> N -> Type
[LTEZ] :: LTE  'Z m
[LTES] :: LTE n m -> LTE ( 'S n) ( 'S m)
type N0 =  'Z
type N1 =  'S N0
type N2 =  'S N1
type N3 =  'S N2
type N4 =  'S N3
type N5 =  'S N4
type F0 =  'FZ
type F1 =  'FS F0
type F2 =  'FS F1
type F3 =  'FS F2
type F4 =  'FS F3
type F5 =  'FS F4
sf0 :: SFin ( 'S n) F0
sf1 :: SFin ( 'S ( 'S n)) F1
sf2 :: SFin ( 'S ( 'S ( 'S n))) F2
sf3 :: SFin ( 'S ( 'S ( 'S ( 'S n)))) F3
sf4 :: SFin ( 'S ( 'S ( 'S ( 'S ( 'S n))))) F4
sf5 :: SFin ( 'S ( 'S ( 'S ( 'S ( 'S ( 'S n)))))) F5
instance GHC.Show.Show Dhall.Typed.Type.N.N
instance GHC.Classes.Ord Dhall.Typed.Type.N.N
instance GHC.Classes.Eq Dhall.Typed.Type.N.N
instance Data.Singletons.ShowSing.ShowSing Dhall.Typed.Type.N.N => GHC.Show.Show (Data.Singletons.Internal.Sing z)
instance Data.Singletons.Prelude.Eq.PEq Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.ShowsPrec_6989586621679144971Sym0
instance Data.Singletons.Prelude.Show.PShow Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.ShowsPrec_6989586621679144971Sym1 a6989586621679144968)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.ShowsPrec_6989586621679144971Sym2 a6989586621679144969 a6989586621679144968)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.Compare_6989586621679141427Sym0
instance Data.Singletons.Prelude.Ord.POrd Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.Compare_6989586621679141427Sym1 a6989586621679141425)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.SSym0
instance Data.Singletons.Internal.SingI Dhall.Typed.Type.N.SSym0
instance Data.Singletons.Internal.SingKind Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Ord.SOrd Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Ord.SOrd Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Show.SShow Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Show.SShow Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Eq.SEq Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Eq.SEq Dhall.Typed.Type.N.N
instance Data.Singletons.Decide.SDecide Dhall.Typed.Type.N.N => Data.Singletons.Decide.SDecide Dhall.Typed.Type.N.N
instance Data.Singletons.Internal.SingI 'Dhall.Typed.Type.N.Z
instance Data.Singletons.Internal.SingI n => Data.Singletons.Internal.SingI ('Dhall.Typed.Type.N.S n)
instance Data.Singletons.Internal.SingI (Data.Singletons.Internal.TyCon1 'Dhall.Typed.Type.N.S)

module Dhall.Typed.Plugin
plugin :: Plugin

module Dhall.Typed.Type.Option
data Option :: (k -> Type) -> Maybe k -> Type
[Noot] :: Option f  'Nothing
[Juus] :: f a -> Option f ( 'Just a)

module Dhall.Typed.Type.Singletons.TH
genPolySing :: DsMonad q => Name -> q [Dec]
genPolySingWith :: DsMonad q => GenPolySingOpts -> Name -> q [Dec]
data GenPolySingOpts
GPSO :: !Bool -> !Bool -> !GenOpts -> !GenOpts -> GenPolySingOpts
[gpsoSing] :: GenPolySingOpts -> !Bool
[gpsoSingI] :: GenPolySingOpts -> !Bool
[gpsoPSK] :: GenPolySingOpts -> !GenOpts
[gpsoSingEq] :: GenPolySingOpts -> !GenOpts
defaultGPSO :: GenPolySingOpts
data GenOpts
GOInfer :: GenOpts
GOSkip :: GenOpts
GOHead :: Q [Dec] -> GenOpts
genPolySingKind :: forall q. DsMonad q => q [Dec] -> q [Dec]
genSingEq :: forall q. DsMonad q => q [Dec] -> q [Dec]
instance GHC.Base.Functor Dhall.Typed.Type.Singletons.TH.V2
instance GHC.Base.Applicative Dhall.Typed.Type.Singletons.TH.V2
instance GHC.Base.Monad Dhall.Typed.Type.Singletons.TH.V2
instance Data.Default.Class.Default Dhall.Typed.Type.Singletons.TH.GenPolySingOpts

module Dhall.Typed.Type.Singletons
type family PolySing k = (s :: k -> Type) | s -> k
class PolySingI (x :: k)
polySing :: PolySingI x => PolySing k x
class PolySingKind k
fromPolySing :: PolySingKind k => PolySing k x -> k
toPolySing :: PolySingKind k => k -> SomePolySing k
data SomePolySing k
[SomePS] :: PolySing k x -> SomePolySing k
newtype WrappedSing k (x :: k)
WS :: PolySing k x -> WrappedSing k
[getWS] :: WrappedSing k -> PolySing k x
newtype SingSing k x :: WrappedSing k x -> Type
[SiSi] :: forall k x (ws :: WrappedSing k x). () => {getSiSi :: PolySing k x} -> SingSing k x ws
type PolySingOfI (x :: PolySing k y) = PolySingI y
class SingEq f g
singEq :: forall x y. SingEq f g => PolySing f x -> PolySing g y -> Decision (x :~~: y)
data SConst (a_axQM :: Type) (b_axQN :: k_axQL) (x_a1sEs :: Const (a_axQM :: Type) (b_axQN :: k_axQL))
[SConst] :: forall (a_axQM :: Type) (b_axQN :: k_axQL) x_a1sEt. () => {sGetConst :: PolySing a_axQM x_a1sEt} -> SConst (a_axQM :: Type) (b_axQN :: k_axQL) ( 'Const x_a1sEt)
data SMaybe (a_11 :: Type) (x_a1sKj :: Maybe (a_11 :: Type))
[SNothing] :: forall (a_11 :: Type). () => SMaybe (a_11 :: Type)  'Nothing
[SJust] :: forall (a_11 :: Type) x_a1sKk. () => PolySing a_11 x_a1sKk -> SMaybe (a_11 :: Type) ( 'Just x_a1sKk)
data SList k :: [k] -> Type
[:%] :: PolySing k x -> SList k xs -> SList k (x : xs)
[SNil] :: SList k '[]
infixr 5 :%
data STup2 a b :: (a, b) -> Type
[STup2] :: PolySing a x -> PolySing b y -> STup2 a b '(x, y)
data SBool :: Bool -> Type
[SFalse] :: SBool  'False
[STrue] :: SBool  'True
data SProxy (t_a1iTt :: k_a1iTs) (x_a1sOL :: Proxy (t_a1iTt :: k_a1iTs))
[SProxy] :: forall (t_a1iTt :: k_a1iTs). () => SProxy (t_a1iTt :: k_a1iTs)  'Proxy
data STup0 :: () -> Type
[STup0] :: STup0  '()
type family ToNat (n :: Natural) = (m :: Nat) | m -> n
type family FromNat (m :: Nat) = (n :: Natural) | n -> m
data SNatural :: Natural -> Type
[SNat] :: KnownNat (ToNat n) => SNatural n
withKnownNatural :: forall n r. KnownNat n => (KnownNat (ToNat (FromNat n)) => r) -> r
type family ToSym (t :: Text) = (s :: Symbol) | s -> t
type family FromSym (s :: Symbol) = (t :: Text) | t -> s
data SText :: Text -> Type
[SText] :: KnownSymbol (ToSym t) => SText t
withKnownText :: forall n r. KnownSymbol n => (KnownSymbol (ToSym (FromSym n)) => r) -> r
instance GHC.TypeLits.KnownSymbol (Dhall.Typed.Type.Singletons.ToSym t) => Dhall.Typed.Type.Singletons.Internal.PolySingI t
instance Dhall.Typed.Type.Singletons.Internal.PolySingKind Data.Text.Internal.Text
instance Dhall.Typed.Type.Singletons.Internal.SingEq Data.Text.Internal.Text Data.Text.Internal.Text
instance GHC.TypeNats.KnownNat (Dhall.Typed.Type.Singletons.ToNat n) => Dhall.Typed.Type.Singletons.Internal.PolySingI n
instance Dhall.Typed.Type.Singletons.Internal.PolySingKind GHC.Natural.Natural
instance Dhall.Typed.Type.Singletons.Internal.SingEq GHC.Natural.Natural GHC.Natural.Natural
instance forall k (t :: k). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Data.Proxy.Proxy
instance forall k (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Proxy.Proxy a)
instance forall k (a :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Proxy.Proxy a) (Data.Proxy.Proxy a)
instance Dhall.Typed.Type.Singletons.Internal.PolySingI 'GHC.Maybe.Nothing
instance forall a (x :: a). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('GHC.Maybe.Just x)
instance Dhall.Typed.Type.Singletons.Internal.PolySingKind a => Dhall.Typed.Type.Singletons.Internal.PolySingKind (GHC.Maybe.Maybe a)
instance Dhall.Typed.Type.Singletons.Internal.SingEq a a => Dhall.Typed.Type.Singletons.Internal.SingEq (GHC.Maybe.Maybe a) (GHC.Maybe.Maybe a)
instance forall k (b :: k) a (x :: a). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Data.Functor.Const.Const x)
instance forall k a (b :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind a => Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Functor.Const.Const a b)
instance forall k a b (c :: k). Dhall.Typed.Type.Singletons.Internal.SingEq a b => Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Functor.Const.Const a c) (Data.Functor.Const.Const b c)

module Dhall.Typed.Type.Index

-- | Witness an item in a type-level list by providing its index.
data Index (a :: [k]) (b :: k) :: forall k. () => [k] -> k -> Type
[IZ] :: forall k (a :: [k]) (b :: k) (as :: [k]). () => Index (b : as) b
[IS] :: forall k (a :: [k]) (b :: k) (bs :: [k]) (b1 :: k). () => Index bs b -> Index (b1 : bs) b

-- | Kind-indexed singleton for <a>Index</a>. Provided as a separate data
--   declaration to allow you to use these at the type level. However, the
--   main interface is still provided through the newtype wrapper
--   <a>SIndex'</a>, which has an actual proper <a>Sing</a> instance.
data SIndex (as :: [k]) (a :: k) (b :: Index as a) :: forall k (as :: [k]) (a :: k). () => Index as a -> Type
[SIZ] :: forall k (as :: [k]) (a :: k) (b :: Index as a) (as1 :: [k]). () => SIndex (a : as1) a (IZ :: Index (a : as1) a)
[SIS] :: forall k (as :: [k]) (a :: k) (b :: Index as a) (bs :: [k]) (i :: Index bs a) (b1 :: k). () => SIndex bs a i -> SIndex (b1 : bs) a (IS i :: Index (b1 : bs) a)
indexN :: Index as a -> N

-- | A <tt><a>Delete</a> as bs x</tt> is a witness that you can delete item
--   <tt>x</tt> from <tt>as</tt> to produce the list <tt>bs</tt>. It is
--   essentially <a>Insert</a> flipped.
--   
--   Some examples:
--   
--   <pre>
--   DelZ             :: Delete '[1,2,3] '[2,3] 1
--   DelS DelZ        :: Delete '[1,2,3] '[2,3] 2
--   DelS (DelS DelZ) :: Delete '[1,2,3] '[1,2] 3
--   </pre>
--   
--   <tt>bs</tt> will always be exactly one item shorter than <tt>as</tt>.
data Delete (a :: [k]) (b :: [k]) (c :: k) :: forall k. () => [k] -> [k] -> k -> Type
[DelZ] :: forall k (a :: [k]) (b :: [k]) (c :: k). () => Delete (c : b) b c
[DelS] :: forall k (a :: [k]) (b :: [k]) (c :: k) (as :: [k]) (bs :: [k]) (a1 :: k). () => Delete as bs c -> Delete (a1 : as) (a1 : bs) c

-- | An <tt><a>Insert</a> as bs x</tt> is a witness that you can insert
--   <tt>x</tt> into some position in list <tt>as</tt> to produce list
--   <tt>bs</tt>. It is essentially <a>Delete</a> flipped.
--   
--   Some examples:
--   
--   <pre>
--   InsZ                   :: Insert '[1,2,3] '[4,1,2,3] 4
--   InsS InsZ              :: Insert '[1,2,3] '[1,4,2,3] 4
--   InsS (InsS InsZ)       :: Insert '[1,2,3] '[1,2,4,3] 4
--   InsS (InsS (InsS InsZ) :: Insert '[1,2,3] '[1,2,3,4] 4
--   </pre>
--   
--   <tt>bs</tt> will always be exactly one item longer than <tt>as</tt>.
data Insert (a :: [k]) (b :: [k]) (c :: k) :: forall k. () => [k] -> [k] -> k -> Type
[InsZ] :: forall k (a :: [k]) (b :: [k]) (c :: k). () => Insert a (c : a) c
[InsS] :: forall k (a :: [k]) (b :: [k]) (c :: k) (as :: [k]) (bs :: [k]) (a1 :: k). () => Insert as bs c -> Insert (a1 : as) (a1 : bs) c
instance forall k (c :: k) (b :: [k]). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Data.Type.List.Edit.DelZ
instance forall k (a1 :: k) (as :: [k]) (bs :: [k]) (c :: k) (x :: Data.Type.List.Edit.Delete as bs c). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Data.Type.List.Edit.DelS x)
instance forall k (a :: [k]) (b :: [k]) (c :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Type.List.Edit.Delete a b c)
instance forall k (a1 :: [k]) (a2 :: [k]) (a3 :: k) (b1 :: [k]) (b2 :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Type.List.Edit.Delete a1 a2 a3) (Data.Type.List.Edit.Delete a1 b1 b2)
instance forall k (a :: [k]) (c :: k). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Data.Type.List.Edit.InsZ
instance forall k (a1 :: k) (as :: [k]) (bs :: [k]) (c :: k) (x :: Data.Type.List.Edit.Insert as bs c). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Data.Type.List.Edit.InsS x)
instance forall k (a :: [k]) (b :: [k]) (c :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Type.List.Edit.Insert a b c)
instance forall k (a1 :: [k]) (a2 :: [k]) (a3 :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Type.List.Edit.Insert a1 a2 a3) (Data.Type.List.Edit.Insert a1 a2 b)
instance forall k (b :: k) (as :: [k]). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Data.Type.Universe.IZ
instance forall k (b1 :: k) (bs :: [k]) (b :: k) (x :: Data.Type.Universe.Index bs b). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Data.Type.Universe.IS x)
instance forall k (as :: [k]) (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Type.Universe.Index as a)
instance forall k (as :: [k]) (a :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Type.Universe.Index as a) (Data.Type.Universe.Index as b)

module Dhall.Typed.Type.Prod
data Prod :: (k -> Type) -> [k] -> Type
[Ø] :: Prod f '[]
[:<] :: f a -> Prod f as -> Prod f (a : as)
infixr 5 :<
traverseProd :: forall f g h as. Applicative h => (forall x. f x -> h (g x)) -> Prod f as -> h (Prod g as)
mapProd :: forall f g as. () => (forall x. f x -> g x) -> Prod f as -> Prod g as
foldMapProd :: forall f as m. Monoid m => (forall x. f x -> m) -> Prod f as -> m
zipProd :: Prod f as -> Prod g as -> Prod (f :*: g) as
singProd :: SList k as -> Prod (PolySing k) as
prodSing :: Prod (PolySing k) as -> SList k as
ixProd :: Prod f as -> Index as a -> f a
data SeqListEq :: Seq a -> [a] -> Type
[SeqListEq] :: SeqListEq xs ys
type family IxProd f as b (p :: Prod f as) (i :: Index as b) :: f b
data SProd (a_a1x9v :: k_a1x8D -> Type) (b_a1x9w :: [k_a1x8D]) (x_a1xcm :: Prod (a_a1x9v :: k_a1x8D -> Type) (b_a1x9w :: [k_a1x8D]))
[SØ] :: forall (k_a1x94 :: Type) (f_a1x8E :: k_a1x94 -> Type). () => SProd f_a1x8E ('[] :: [k_a1x94])  'Ø
[:%<] :: forall (a_a1x9m :: Type) (f_a1x8F :: a_a1x9m -> Type) (a_X1x8H :: a_a1x9m) (as_X1x8J :: [a_a1x9m]) x_a1xcn x_a1xco. () => PolySing (f_a1x8F a_X1x8H) x_a1xcn -> SProd f_a1x8F as_X1x8J x_a1xco -> SProd f_a1x8F ( '(:) a_X1x8H as_X1x8J) ( '(:<) x_a1xcn x_a1xco)
sIxProd :: SProd f as xs -> SIndex as a i -> PolySing (f a) (IxProd f as a xs i)
type family ProdList (xs :: Prod (Const k) ys) :: [k]
data BiProd :: (k -> Type) -> (j -> Type) -> [k] -> [j] -> Type
[BZ] :: BiProd f g '[] '[]
[BS] :: f a -> g b -> BiProd f g as bs -> BiProd f g (a : as) (b : bs)
data SBiProd (a_a1xiY :: k_a1xdd -> Type) (b_a1xiZ :: j_a1xde -> Type) (c_a1xj0 :: [k_a1xdd]) (d_a1xj1 :: [j_a1xde]) (x_a1xot :: BiProd (a_a1xiY :: k_a1xdd -> Type) (b_a1xiZ :: j_a1xde -> Type) (c_a1xj0 :: [k_a1xdd]) (d_a1xj1 :: [j_a1xde]))
[SBZ] :: forall (k_a1xim :: Type) (j_a1xin :: Type) (f_a1xdf :: k_a1xim -> Type) (g_a1xdg :: j_a1xin -> Type). () => SBiProd f_a1xdf g_a1xdg ('[] :: [k_a1xim]) ('[] :: [j_a1xin])  'BZ
[SBS] :: forall (a_a1xiO :: Type) (a_a1xiP :: Type) (f_a1xdh :: a_a1xiO -> Type) (a_X1xdj :: a_a1xiO) (g_a1xdj :: a_a1xiP -> Type) (b_X1xdm :: a_a1xiP) (as_X1xdo :: [a_a1xiO]) (bs_X1xdq :: [a_a1xiP]) x_a1xou x_a1xov x_a1xow. () => PolySing (f_a1xdh a_X1xdj) x_a1xou -> PolySing (g_a1xdj b_X1xdm) x_a1xov -> SBiProd f_a1xdh g_a1xdj as_X1xdo bs_X1xdq x_a1xow -> SBiProd f_a1xdh g_a1xdj ( '(:) a_X1xdj as_X1xdo) ( '(:) b_X1xdm bs_X1xdq) ( 'BS x_a1xou x_a1xov x_a1xow)
instance forall k (f :: k -> *) j (g :: j -> *). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Prod.BZ
instance forall a1 (as :: [a1]) a2 (bs :: [a2]) (g :: a2 -> *) (b :: a2) (f :: a1 -> *) (a3 :: a1) (x1 :: f a3) (x2 :: g b) (x3 :: Dhall.Typed.Type.Prod.BiProd f g as bs). (Dhall.Typed.Type.Singletons.Internal.PolySingI x1, Dhall.Typed.Type.Singletons.Internal.PolySingI x2, Dhall.Typed.Type.Singletons.Internal.PolySingI x3) => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Prod.BS x1 x2 x3)
instance forall j k (f :: k -> *) (g :: j -> *) (as :: [k]) (bs :: [j]). (forall (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (f a), forall (a :: j). Dhall.Typed.Type.Singletons.Internal.PolySingKind (g a)) => Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Prod.BiProd f g as bs)
instance forall j k (f :: k -> *) (g :: j -> *) (as :: [k]) (bs :: [j]) (cs :: [k]) (ds :: [j]). (forall (a :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (f a) (f b), forall (a :: j) (b :: j). Dhall.Typed.Type.Singletons.Internal.SingEq (g a) (g b)) => Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Prod.BiProd f g as bs) (Dhall.Typed.Type.Prod.BiProd f g cs ds)
instance forall k (f :: k -> *). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Prod.Ø
instance forall a1 (as :: [a1]) (f :: a1 -> *) (a2 :: a1) (x1 :: f a2) (x2 :: Dhall.Typed.Type.Prod.Prod f as). (Dhall.Typed.Type.Singletons.Internal.PolySingI x1, Dhall.Typed.Type.Singletons.Internal.PolySingI x2) => Dhall.Typed.Type.Singletons.Internal.PolySingI (x1 'Dhall.Typed.Type.Prod.:< x2)
instance forall k (f :: k -> *) (as :: [k]). (forall (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (f a)) => Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Prod.Prod f as)
instance forall k (f :: k -> *) (as :: [k]) (bs :: [k]). (forall (a :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (f a) (f b)) => Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Prod.Prod f as) (Dhall.Typed.Type.Prod.Prod f bs)


-- | Implementing a typed lambda calculus. Uses De Bruijn indices in
--   separate namespaces (that is, kind, type, term variables all have
--   their own separate De Bruijn indexing)
--   
--   We have a hierarchy: Term -&gt; Type -&gt; Kind -&gt; Sort. We can
--   stop at Sort because we don't allow any Sort variables, so there is no
--   need to talk about the "type" of any Sorts. Disallowing variables
--   effectively stops the chain.
--   
--   It looks like each level has some sets of constructors just from its
--   position on the chain.
--   
--   <ul>
--   <li>At all levels, we have <i>primitives</i>. Term-level primitives
--   are built-in functions and values and literals. Type-level primitives
--   are built-in types and type functions. Dhall has no kind- or
--   sort-level primitives.</li>
--   <li>If a level has variables (Terms, Types, Kinds), we gain some
--   constructors:<ul><li>Var, the variable constructor j Lam, the function
--   abstraction</li><li>App, the function application</li></ul></li>
--   <li>If a level has variables and its "type" also has variables (Terms,
--   Types), we gain some constructors:<ul><li>Poly, the type
--   abstraction</li><li>Inst (instantiation), the type
--   application</li></ul></li>
--   <li>If a level is the "type" of something (n &gt;= 1), we gain a
--   function type constructor, the type of function abstractions in the
--   immediately lower level.</li>
--   <li>If a level is the "type" of a "type" of something (n &gt;= 2), we
--   gain an "constant" constructor that links the two layers below it
--   together. Examples are the Kind sort that links Kinds to Types (all
--   types have kinds of sort Kind), and the Type kind that links types to
--   values (all terms have types of kind Type)</li>
--   <li>If a type is the "type" of something (n &gt;= 1), <i>and</i> it
--   has variables, we have a Pi type constructor, the type of type
--   abstractions (type-polymorphic values) in the lower level.</li>
--   </ul>
--   
--   We actually gain a Pi type for our current level, and each level above
--   our current level (that has variables). So for the Type level, we have
--   Type-Pi and Kind-Pi, and for the Kind level, we have Kind-Pi.
--   
--   So to summarize:
--   
--   <ul>
--   <li>n = 3: Sort has a constant (it is n &gt;= 2) and a function type
--   constructor (it is n &gt;= 1). It could also potentially have
--   primitives, but Dhall has no sort primitives.</li>
--   <li>n = 2: Kind has variables, so it has Var, Lam, and App. It has a
--   constant (they are n &gt;= 2) and a function type constructor and a Pi
--   constructor (it is n &gt;= 1 and has variables). It could also
--   potentially have primitives; Dhall has only record and union kinds as
--   primitives.</li>
--   <li>n = 1: Type has variables, so it has Var, Lam, and App. It has a
--   function type constructor and a Pi constructor (it is n &gt;= 1 and
--   has variables). Because its "type" has variables (Kind), it also has
--   Poly and Inst. It has primitives, and in Dhall ther are several.</li>
--   <li>n = 0: Term has variables, so it has Var, Lam, and App. Because
--   its "type" has variables, it has Poly and Inst. In Dhall, it has
--   multitudes of primitives.</li>
--   </ul>
module Dhall.Typed.LC
instance forall (ts :: [Dhall.Typed.LC.DSort]) (vs :: [Dhall.Typed.LC.DKind ts 'Dhall.Typed.LC.Kind]) (a :: Dhall.Typed.LC.DKind ts 'Dhall.Typed.LC.Kind). Data.Singletons.Internal.SingKind (Dhall.Typed.LC.DType ts vs a)
instance Data.Singletons.Internal.SingKind (Dhall.Typed.LC.DKind ts a)
instance Data.Singletons.Internal.SingKind Dhall.Typed.LC.DSort

module Dhall.Typed.Core

-- | Represents the possible sorts encountered in Dhall.
--   
--   Note that this implementation allows records of kinds with sorts other
--   than <a>Kind</a>, so <tt>{ foo : Kind -&gt; Kind }</tt> would
--   typecheck, even though normal Dhall forbids this.
--   
--   A <a>DSort</a> is always in normal form.
data DSort :: Type
[Kind] :: DSort
[:*>] :: DSort -> DSort -> DSort
[KRecord] :: AggType DSort ls as -> DSort
[KUnion] :: AggType DSort ls as -> DSort

-- | Kind-level let-bindings. Potentially empty, for simplicity.
--   
--   We also need to allow for terms and types. So maybe in the future we
--   need a high-level Let layer uniting all kinds, types, terms, etc.
data KBindings (ts :: [DSort]) (ps :: [DSort])
[KBNil] :: KBindings ts ts
[KBKind] :: DKind ts t -> KBindings (t : ts) ps -> KBindings ts ps

-- | Represents the possible types encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DKind</a> '[r, s] t
--   </pre>
--   
--   Describes a kind of sort <tt>t</tt> with possible kind variables of
--   sorts <tt>r</tt> and <tt>s</tt>.
--   
--   Something of type <tt><a>DKind</a> '[] t</tt> is a kind of sort
--   <tt>t</tt> with no free variables.
data DKind :: [DSort] -> DSort -> Type
[KVar] :: Index ts a -> DKind ts a
[KLam] :: SDSort t -> DKind (t : ts) a -> DKind ts (t :*> a)
[KApp] :: DKind ts (a :*> b) -> DKind ts a -> DKind ts b
[:~>] :: DKind ts  'Kind -> DKind ts  'Kind -> DKind ts  'Kind
[KPi] :: SDSort t -> DKind (t : ts) a -> DKind ts a
[Type] :: DKind ts  'Kind
[TRecord] :: AggType (DKind ts  'Kind) ls as -> DKind ts  'Kind
[TUnion] :: AggType (DKind ts  'Kind) ls as -> DKind ts  'Kind
[KRecordLit] :: SAggType DSort ls as at -> Prod (DKind ts) as -> DKind ts ( 'KRecord at)
[KUnionLit] :: SAggType DSort ls as at -> Index as a -> DKind ts a -> DKind ts ( 'KUnion at)
infixr 1 :~>
data SomeKind :: [DSort] -> Type
[SomeKind] :: SDSort a -> DKind ts a -> SomeKind ts
type a :~> b = a :~> b
infixr 1 :~>

-- | Shift all kind variables in a kind expression of sort <tt>b</tt> to
--   account for a new bound variable of sort <tt>a</tt>, to be inserted at
--   the position indicated by the <a>Insert</a>.
type family KShift ts ps a b (ins :: Insert ts ps a) (x :: DKind ts b) :: DKind ps b
toSomeKind :: PolySingI a => DKind ts a -> SomeKind ts

-- | Ideally we would want this to be encodable within the type. But the
--   main problem here is checking if the LHS of an application is a
--   variable or not. This is the next best thing?
type family KNormalize ts a (x :: DKind ts a) :: DKind ts a

-- | Version of <a>SDKind</a> that exposes itself in normal form.
data NDKind ts a :: DKind ts a -> Type
[NDK] :: SDKind ts a x -> NDKind ts a (KNormalize ts a x)

-- | Substitute in a kind for all occurrences of a kind variable of sort
--   <tt>a</tt> indicated by the <a>Delete</a> within a kind of osrt
--   <tt>b</tt>.
type family KSub ts ps a b (del :: Delete ts ps a) (x :: DKind ps a) (r :: DKind ts b) :: DKind ps b
data SubbedKind ts t :: DKind ts t -> DKind (t : ts) 'Kind -> DKind ts 'Kind -> Type
[SbKd] :: {getSbKd :: SDKind ts t a} -> SubbedKind ts t a b (KSub (t : ts) ts t  'Kind  'DelZ a b)

-- | Type-level let-bindings. Potentially empty, for simplicity.
--   
--   We also need to allow for terms. So maybe in the future we need a
--   high-level Let layer uniting all kinds, types, terms, etc.
data TBindings (ts :: [DSort]) (us :: [DKind ts 'Kind]) (a :: DKind ts 'Kind) (ps :: [DSort]) (qs :: [DKind ps 'Kind]) (b :: DKind ps 'Kind)
[TBNil] :: TBindings ts us a ts us a
[TBKind] :: DKind ts t -> TBindings (t : ts) (Map (KShiftSym ts (t : ts) t  'Kind  'InsZ) us) (KShift ts (t : ts) t  'Kind  'InsZ a) ps qs b -> TBindings ts us a ps qs b
[TBType] :: DType ts us u -> TBindings ts (u : us) a ps qs b -> TBindings ts us a ps qs b

-- | Represents the possible types encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DTerm</a> '[r, s] '[k, j] a
--   </pre>
--   
--   Describes a type of kind <tt>a</tt> with possible:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   </ul>
--   
--   Something of type <tt><a>DType</a> '[] '[] a</tt> is a type of kind
--   <tt>a</tt> with no free variables.
--   
--   Note that the type of "kind-polymorphic values" (functions from kinds
--   to terms) is not yet supported.
--   
--   The kinds of the type variables should all be normalized. All
--   constructors that introduce type variables should normalize
--   automatically, but it's possible create nonsensical types with
--   <a>TVar</a>.
data DType ts :: [DKind ts 'Kind] -> DKind ts 'Kind -> Type
[TVar] :: Index us a -> DType ts us a
[TLam] :: NDKind ts  'Kind u -> DType ts (u : us) a -> DType ts us (u :~> a)
[TApp] :: DType ts us (a :~> b) -> DType ts us a -> DType ts us b
[TPoly] :: SingSing DSort t ( 'WS tt) -> DType (t : ts) (Map (KShiftSym ts (t : ts) t  'Kind  'InsZ) us) a -> DType ts us ( 'KPi tt a)
[TInst] :: SingSing DSort t ( 'WS tt) -> DType ts us ( 'KPi tt b) -> SubbedKind ts t a b sk -> DType ts us sk
[:->] :: DType ts us  'Type -> DType ts us  'Type -> DType ts us  'Type
[Pi] :: NDKind ts  'Kind u -> DType ts (u : us) a -> DType ts us a
[Bool] :: DType ts us  'Type
[Natural] :: DType ts us  'Type
[List] :: DType ts us ( 'Type :~>  'Type)
[Optional] :: DType ts us ( 'Type :~>  'Type)
[Record] :: AggType (DType ts us  'Type) ls as -> DType ts us  'Type
[Union] :: AggType (DType ts us  'Type) ls as -> DType ts us  'Type
[TRecordLit] :: SAggType (DKind ts  'Kind) ls as at -> Prod (DType ts us) as -> DType ts us ( 'TRecord at)
[TUnionLit] :: SAggType (DKind ts  'Kind) ls as at -> Index as a -> DType ts us a -> DType ts us ( 'TUnion at)
infixr 0 :->
infixl 9 `TApp`
data SomeType ts :: [DKind ts 'Kind] -> Type
[SomeType] :: NDKind ts  'Kind a -> DType ts us a -> SomeType ts us
type (:$) =  'TApp
infixl 9 :$
type a :-> b = a :-> b
infixr 0 :->

-- | Shift all type variables in a type expression of kind <tt>b</tt> to
--   account for a new bound variable of kind <tt>a</tt>, to be inserted at
--   the position indicated by the <a>Insert</a>.
type family Shift ts us qs a b (ins :: Insert us qs a) (x :: DType ts us b) :: DType ts qs b
toSomeType :: forall ts us a. (PolySingI a, KNormalize ts  'Kind a ~ a) => DType ts us a -> SomeType ts us

-- | Ideally we would want this to be encodable within the type. But the
--   main problem here is checking if the LHS of an application is a
--   variable or not. This is the next best thing?
--   
--   Normalizing <i>applications</i> of anonymous type functions (both
--   <a>TApp</a> and <a>TInst</a>) is not yet supported. Practically, this
--   means that we can't yet have any values of types that are applications
--   of type functions.
type family TNormalize (ts :: [DSort]) (us :: [DKind ts  'Kind]) (a :: DKind ts  'Kind) (x :: DType ts us a) :: DType ts us a

-- | Version of <a>SDType</a> that exposes itself in normal form.
data NDType ts us a :: DType ts us a -> Type
[NDT] :: SDType ts us a x -> NDType ts us a (TNormalize ts us a x)

-- | Substitute in a type for all occurrences of a type variable of kind
--   <tt>a</tt> indicated by the <a>Delete</a> within a type of kind
--   <tt>b</tt>.
type family Sub ts us qs a b (del :: Delete us qs a) (x :: DType ts qs a) (r :: DType ts us b) :: DType ts qs b
type family ShiftSort ts ps us a (ins :: Insert ts ps a) (x :: DType ts us  'Type) :: DType ps (Map (KShiftSym ts ps a  'Kind ins) us)  'Type
normalizeKindOf :: DType ts us a -> DType ts us (KNormalize ts  'Kind a)

-- | Primitives of Dhall terms, built into the language.
data Prim ts us :: [DType ts us 'Type] -> DType ts us 'Type -> Type
[BoolLit] :: Bool -> Prim ts us '[]  'Bool
[BoolAnd] :: Prim ts us '[ 'Bool,  'Bool]  'Bool
[BoolOr] :: Prim ts us '[ 'Bool,  'Bool]  'Bool
[NaturalLit] :: Natural -> Prim ts us '[]  'Natural
[NaturalFold] :: Prim ts us '[] ( 'Natural :->  'Pi ( 'NDK  'SType) (( 'TVar  'IZ :->  'TVar  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)))
[NaturalBuild] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) (( 'TVar  'IZ :->  'TVar  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :->  'Natural)
[NaturalPlus] :: Prim ts us '[ 'Natural,  'Natural]  'Natural
[NaturalTimes] :: Prim ts us '[ 'Natural,  'Natural]  'Natural
[NaturalIsZero] :: Prim ts us '[] ( 'Natural :->  'Bool)
[ListFold] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) (( 'List :$  'TVar  'IZ) :->  'Pi ( 'NDK  'SType) (( 'TVar ( 'IS  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'TVar  'IZ :->  'TVar  'IZ))))
[ListBuild] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) ( 'Pi ( 'NDK  'SType) (( 'TVar ( 'IS  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'List :$  'TVar  'IZ)))
[ListAppend] :: SDType ts us  'Type a -> Prim ts us '[ 'List :$ a,  'List :$ a] ( 'List :$ a)
[ListHead] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) (( 'List :$  'TVar  'IZ) :-> ( 'Optional :$  'TVar  'IZ)))
[ListLast] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) (( 'List :$  'TVar  'IZ) :-> ( 'Optional :$  'TVar  'IZ)))
[ListReverse] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) (( 'List :$  'TVar  'IZ) :-> ( 'List :$  'TVar  'IZ)))
[Some] :: SDType ts us  'Type a -> Prim ts us '[a] ( 'Optional :$ a)
[None] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) ( 'Optional :$  'TVar  'IZ))

-- | Represents the possible terms encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DTerm</a> '[r, s] '[k, j] '[a, b, c] d
--   </pre>
--   
--   Describes a term of type <tt>d</tt> with possible:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   <li>Variables of type <tt>a</tt>, <tt>b</tt>, <tt>c</tt></li>
--   </ul>
--   
--   Something of type <tt><a>DTerm</a> '[] '[] '[] a</tt> is a term of
--   type <tt>a</tt> with no free variables.
--   
--   Note that "kind-polymorphic values" (functions from kinds to terms)
--   are not yet supported.
data DTerm ts (us :: [DKind ts 'Kind]) :: [DType ts us 'Type] -> DType ts us 'Type -> Type
[Var] :: Index vs a -> DTerm ts us vs a
[Lam] :: NDType ts us  'Type v -> DTerm ts us (v : vs) a -> DTerm ts us vs (v :-> a)
[App] :: DTerm ts us vs (a :-> b) -> DTerm ts us vs a -> DTerm ts us vs b
[Poly] :: SNDKind ts  'Kind u uu -> DTerm ts (u : us) (Map (ShiftSym ts us (u : us) u  'Type  'InsZ) vs) a -> DTerm ts us vs ( 'Pi uu a)
[Inst] :: SNDKind ts  'Kind u uu -> DTerm ts us vs ( 'Pi uu b) -> SDType ts us u a -> DTerm ts us vs (Sub ts (u : us) us u  'Type  'DelZ a b)
[P] :: Prim ts us as a -> Prod (DTerm ts us vs) as -> DTerm ts us vs a
[ListLit] :: NDType ts us  'Type a -> [DTerm ts us vs a] -> DTerm ts us vs ( 'List :$ a)
[OptionalLit] :: NDType ts us  'Type a -> Maybe (DTerm ts us vs a) -> DTerm ts us vs ( 'Optional :$ a)
[RecordLit] :: SAggType (DType ts us  'Type) ls as at -> Prod (DTerm ts us vs) as -> DTerm ts us vs ( 'Record at)
[UnionLit] :: SAggType (DType ts us  'Type) ls as at -> Index as a -> DTerm ts us vs a -> DTerm ts us vs ( 'Union at)
data SomeTerm ts us :: [DType ts us 'Type] -> Type
[SomeTerm] :: NDType ts us  'Type a -> DTerm ts us vs a -> SomeTerm ts us vs
toSomeTerm :: forall ts us vs a. (PolySingI a, TNormalize ts us  'Type a ~ a) => DTerm ts us vs a -> SomeTerm ts us vs
normalizeTypeOf :: DTerm ts us vs a -> DTerm ts us vs (TNormalize ts us  'Type a)

-- | A <a>DExpr</a> fully covers all legal type-checking dhall terms. A
--   value of type
--   
--   <pre>
--   <a>DExpr</a> '[ r, s ] '[ k, j ] '[ a, b ] n
--   </pre>
--   
--   Represents a dhall expression on level <tt>n</tt> (<tt>'FZ</tt> =
--   term, <tt>'FS 'FZ</tt> = type, etc.) with potential:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   <li>Term variables of type <tt>a</tt>, <tt>b</tt></li>
--   </ul>
--   
--   A value of type <tt><a>DExpr</a> '[] '[] '[] n</tt> represents a typed
--   dhall expression with no free variables.
--   
--   You can pattern match on it to get a value of one of the "levels" of
--   the dhall type hierarchy, and also to get the "type" and
--   representation of it.
--   
--   The number of level goes up to 4 :
--   
--   <ul>
--   <li><tt>F0</tt>: term</li>
--   <li><tt>F1</tt>: type</li>
--   <li><tt>F2</tt>: kind</li>
--   <li><tt>F3</tt>: sort</li>
--   <li><tt>F4</tt>: order</li>
--   </ul>
--   
--   Note that you can restrict this to only <a>DExpr</a> past a given
--   "level" by asking for or returning a <tt><a>DExpr</a> ts us vs ('FS
--   n)</tt>, for instance. Such a value will only contain types, kinds,
--   sorts, or order A <tt><a>DExpr</a> ts us vs ('FS ('FS n))</tt> will
--   only contain kinds, sorts, or order, etc.
data DExpr ts us :: [DType ts us 'Type] -> Fin N5 -> Type
[DEOrder] :: DExpr ts us vs F4
[DESort] :: DSort -> DExpr ts us vs F3
[DEKind] :: SomeKind ts -> DExpr ts us vs F2
[DEType] :: SomeType ts us -> DExpr ts us vs F1
[DETerm] :: SomeTerm ts us vs -> DExpr ts us vs F0

-- | Hides the "level" of a <a>DExpr</a>. Pattern match to find it. Can be
--   useful when returning a <a>DExpr</a> of level unknown until runtime,
--   or storing <a>DExpr</a> of multiple levels in a container.
data SomeDExpr ts us :: [DType ts us 'Type] -> Type
[SomeDExpr] :: DExpr ts us vs l -> SomeDExpr ts us vs

-- | Get the meta-level "type" of a <a>DExpr</a>. If it's a term, this will
--   return its type. If it's a type, this returns its type, etc. It
--   essentially goes up one "level" of the Dhall type hierarchy.
--   
--   This will not typecheck if given a "Level 4" fin, so you cannot pass
--   in <a>DEOrder</a>.
dExprType :: DExpr ts us vs n -> DExpr ts us vs (ShiftFin N5 n)
deKind :: PolySingI a => DKind ts a -> DExpr ts us vs F2
deType :: (PolySingI a, KNormalize ts  'Kind a ~ a) => DType ts us a -> DExpr ts us vs F1
deTerm :: (PolySingI a, TNormalize ts us  'Type a ~ a) => DTerm ts us vs a -> DExpr ts us vs F0

-- | Meta-level type describing a collection or aggregation of types. Used
--   for specifying records and unions.
--   
--   Currently does not check for uniqueness. But it should hopefully some
--   day. The tricky part is finding a witness type that works both at the
--   term level and at the lifted type level.
data AggType k (ls :: [Text]) (as :: [k])
[ATZ] :: AggType k '[] '[]
[ATS] :: SText l -> WrappedSing k (a :: k) -> AggType k ls as -> AggType k (l : ls) (a : as)

-- | Term-level let-bindings. Potentially empty, for simplicity.
data Bindings (ts :: [DSort]) (us :: [DKind ts 'Kind]) (vs :: [DType ts us 'Type]) (a :: DType ts us 'Type) (ps :: [DSort]) (qs :: [DKind ps 'Kind]) (rs :: [DType ps qs 'Type]) (b :: DType ps qs 'Type)
[BNil] :: Bindings ts us vs a ts us vs a
[BKind] :: DKind ts t -> Bindings (t : ts) (Map (KShiftSym ts (t : ts) t  'Kind  'InsZ) us) (Map (ShiftSortSym ts (t : ts) us t  'InsZ) vs) (ShiftSort ts (t : ts) us t  'InsZ a) ps qs rs b -> Bindings ts us vs a ps qs rs b
[BType] :: DType ts us u -> Bindings ts (u : us) (Map (ShiftSym ts us (u : us) u  'Type  'InsZ) vs) (Shift ts us (u : us) u  'Type  'InsZ a) ps qs rs b -> Bindings ts us vs a ps qs rs b
[BTerm] :: DTerm ts us vs v -> Bindings ts us (v : vs) a ps qs rs b -> Bindings ts us vs a ps qs rs b
sortOf :: DKind '[] a -> SDSort a
kindOf :: DType ts '[] a -> SDKind ts  'Kind a
typeOf :: DTerm ts us '[] a -> SDType ts us  'Type a
sortOfWith :: Prod SDSort ts -> DKind ts a -> SDSort a
kindOfWith :: Prod (SDKind ts  'Kind) us -> DType ts us a -> SDKind ts  'Kind a
typeOfWith :: Prod (SDType ts us  'Type) vs -> DTerm ts us vs a -> SDType ts us  'Type a
data SDSort (x_a1ATZ :: DSort)
[SKind] :: SDSort  'Kind
[:%*>] :: forall x_a1AU0 x_a1AU1. () => SDSort x_a1AU0 -> SDSort x_a1AU1 -> SDSort ( '(:*>) x_a1AU0 x_a1AU1)
[SKRecord] :: forall (ls_X1AMI :: [Text]) (as_X1AMK :: [DSort]) x_a1AU2. () => PolySing (AggType DSort ls_X1AMI as_X1AMK) x_a1AU2 -> SDSort ( 'KRecord x_a1AU2)
[SKUnion] :: forall (ls_X1AMK :: [Text]) (as_X1AMM :: [DSort]) x_a1AU5. () => PolySing (AggType DSort ls_X1AMK as_X1AMM) x_a1AU5 -> SDSort ( 'KUnion x_a1AU5)
data SDKind (a_a1B1c :: [DSort]) (b_a1B1d :: DSort) (x_a1B6F :: DKind (a_a1B1c :: [DSort]) (b_a1B1d :: DSort))
[SKVar] :: forall (ts_a1AVu :: [DSort]) (a_a1AVv :: DSort) x_a1B6G. () => PolySing (Index ts_a1AVu a_a1AVv) x_a1B6G -> SDKind ts_a1AVu a_a1AVv ( 'KVar x_a1B6G)
[SKLam] :: forall (t_X1AVx :: DSort) (ts_a1AVx :: [DSort]) (a_X1AVA :: DSort) x_a1B6L x_a1B6M. () => SingSing DSort t_X1AVx ( 'WS x_a1B6L) -> SDKind ( '(:) t_X1AVx ts_a1AVx) a_X1AVA x_a1B6M -> SDKind ts_a1AVx ( '(:*>) t_X1AVx a_X1AVA) ( 'KLam x_a1B6L x_a1B6M)
[SKApp] :: forall (ts_a1AVz :: [DSort]) (a_X1AVB :: DSort) (b_a1AVB :: DSort) x_a1B70 x_a1B7e. () => SDKind ts_a1AVz ( '(:*>) a_X1AVB b_a1AVB) x_a1B70 -> SDKind ts_a1AVz a_X1AVB x_a1B7e -> SDKind ts_a1AVz b_a1AVB ( 'KApp x_a1B70 x_a1B7e)
[:%~>] :: forall (ts_a1AVC :: [DSort]) x_a1B7s x_a1B7G. () => SDKind ts_a1AVC  'Kind x_a1B7s -> SDKind ts_a1AVC  'Kind x_a1B7G -> SDKind ts_a1AVC  'Kind ( '(:~>) x_a1B7s x_a1B7G)
[SKPi] :: forall (t_X1AVE :: DSort) (ts_a1AVE :: [DSort]) (a_a1AVF :: DSort) x_a1B7U x_a1B7V. () => SingSing DSort t_X1AVE ( 'WS x_a1B7U) -> SDKind ( '(:) t_X1AVE ts_a1AVE) a_a1AVF x_a1B7V -> SDKind ts_a1AVE a_a1AVF ( 'KPi x_a1B7U x_a1B7V)
[SType] :: forall (ts_a1AVG :: [DSort]). () => SDKind ts_a1AVG  'Kind  'Type
[STRecord] :: forall (ts_a1AVH :: [DSort]) (ls_X1AVJ :: [Text]) (as_X1AVL :: [DKind ts_a1AVH  'Kind]) x_a1B89. () => PolySing (AggType (DKind ts_a1AVH  'Kind) ls_X1AVJ as_X1AVL) x_a1B89 -> SDKind ts_a1AVH  'Kind ( 'TRecord x_a1B89)
[STUnion] :: forall (ts_a1AVK :: [DSort]) (ls_X1AVM :: [Text]) (as_X1AVO :: [DKind ts_a1AVK  'Kind]) x_a1B9f. () => PolySing (AggType (DKind ts_a1AVK  'Kind) ls_X1AVM as_X1AVO) x_a1B9f -> SDKind ts_a1AVK  'Kind ( 'TUnion x_a1B9f)
[SKRecordLit] :: forall (ls_X1AVO :: [Text]) (as_X1AVQ :: [DSort]) (at_X1AVS :: AggType DSort ls_X1AVO as_X1AVQ) (ts_a1AVQ :: [DSort]) x_a1Bal x_a1Bao. () => SingSing (AggType DSort ls_X1AVO as_X1AVQ) at_X1AVS ( 'WS x_a1Bal) -> PolySing (Prod (DKind ts_a1AVQ) as_X1AVQ) x_a1Bao -> SDKind ts_a1AVQ ( 'KRecord at_X1AVS) ( 'KRecordLit x_a1Bal x_a1Bao)
[SKUnionLit] :: forall (ls_X1AVS :: [Text]) (as_X1AVU :: [DSort]) (at_X1AVW :: AggType DSort ls_X1AVS as_X1AVU) (a_X1AVY :: DSort) (ts_a1AVV :: [DSort]) x_a1Bb6 x_a1Bb9 x_a1Bbe. () => SingSing (AggType DSort ls_X1AVS as_X1AVU) at_X1AVW ( 'WS x_a1Bb6) -> PolySing (Index as_X1AVU a_X1AVY) x_a1Bb9 -> SDKind ts_a1AVV a_X1AVY x_a1Bbe -> SDKind ts_a1AVV ( 'KUnion at_X1AVW) ( 'KUnionLit x_a1Bb6 x_a1Bb9 x_a1Bbe)
data SNDKind (ts_a1Bim :: [DSort]) (a_a1Bin :: DSort) (b_a1C4H :: DKind ts_a1Bim a_a1Bin) (x_a1Cb0 :: NDKind (ts_a1Bim :: [DSort]) (a_a1Bin :: DSort) (b_a1C4H :: DKind ts_a1Bim a_a1Bin))
[SNDK] :: forall (ts_a1Bio :: [DSort]) (a_a1Bip :: DSort) (x_X1Bir :: DKind ts_a1Bio a_a1Bip) x_a1Cb1. () => SingSing (DKind ts_a1Bio a_a1Bip) x_X1Bir ( 'WS x_a1Cb1) -> SNDKind ts_a1Bio a_a1Bip (KNormalize ts_a1Bio a_a1Bip x_X1Bir) ( 'NDK x_a1Cb1)
data SSubbedKind (ts_a1CbG :: [DSort]) (t_a1CbH :: DSort) (a_a1Cfs :: DKind ts_a1CbG t_a1CbH) (b_a1Cft :: DKind ( '(:) t_a1CbH ts_a1CbG) 'Kind) (c_a1Cfu :: DKind ts_a1CbG 'Kind) (x_a1Cj6 :: SubbedKind (ts_a1CbG :: [DSort]) (t_a1CbH :: DSort) (a_a1Cfs :: DKind ts_a1CbG t_a1CbH) (b_a1Cft :: DKind ( '(:) t_a1CbH ts_a1CbG) 'Kind) (c_a1Cfu :: DKind ts_a1CbG 'Kind))
[SSbKd] :: forall (ts_a1CbI :: [DSort]) (t_a1CbJ :: DSort) (a_a1CbK :: DKind ts_a1CbI t_a1CbJ) (b_a1CbL :: DKind ( '(:) t_a1CbJ ts_a1CbI)  'Kind) x_a1Cj7. () => {sGetSbKd :: SingSing (DKind ts_a1CbI t_a1CbJ) a_a1CbK ( 'WS x_a1Cj7)} -> SSubbedKind ts_a1CbI t_a1CbJ a_a1CbK b_a1CbL (KSub ( '(:) t_a1CbJ ts_a1CbI) ts_a1CbI t_a1CbJ  'Kind ( 'DelZ :: Delete ( '(:) t_a1CbJ ts_a1CbI) ts_a1CbI t_a1CbJ) a_a1CbK b_a1CbL) ( 'SbKd x_a1Cj7)
data SDType (ts_a1Ckh :: [DSort]) (a_a1CvY :: [DKind ts_a1Ckh 'Kind]) (b_a1CvZ :: DKind ts_a1Ckh 'Kind) (x_a1CEf :: DType (ts_a1Ckh :: [DSort]) (a_a1CvY :: [DKind ts_a1Ckh 'Kind]) (b_a1CvZ :: DKind ts_a1Ckh 'Kind))
[STVar] :: forall (ts_a1Ckk :: [DSort]) (us_a1Cki :: [DKind ts_a1Ckk  'Kind]) (a_a1Ckj :: DKind ts_a1Ckk  'Kind) x_a1CEg. () => PolySing (Index us_a1Cki a_a1Ckj) x_a1CEg -> SDType ts_a1Ckk us_a1Cki a_a1Ckj ( 'TVar x_a1CEg)
[STLam] :: forall (ts_a1Ckl :: [DSort]) (u_X1Ckn :: DKind ts_a1Ckl  'Kind) (us_a1Ckn :: [DKind ts_a1Ckl  'Kind]) (a_X1Ckq :: DKind ts_a1Ckl  'Kind) x_a1CEl x_a1CEo. () => PolySing (NDKind ts_a1Ckl  'Kind u_X1Ckn) x_a1CEl -> SDType ts_a1Ckl ( '(:) u_X1Ckn us_a1Ckn) a_X1Ckq x_a1CEo -> SDType ts_a1Ckl us_a1Ckn ( '(:~>) u_X1Ckn a_X1Ckq) ( 'TLam x_a1CEl x_a1CEo)
[STApp] :: forall (ts_a1Ckp :: [DSort]) (us_a1Ckq :: [DKind ts_a1Ckp  'Kind]) (a_X1Cks :: DKind ts_a1Ckp  'Kind) (b_a1Cks :: DKind ts_a1Ckp  'Kind) x_a1CEX x_a1CFw. () => SDType ts_a1Ckp us_a1Ckq ( '(:~>) a_X1Cks b_a1Cks) x_a1CEX -> SDType ts_a1Ckp us_a1Ckq a_X1Cks x_a1CFw -> SDType ts_a1Ckp us_a1Ckq b_a1Cks ( 'TApp x_a1CEX x_a1CFw)
[STPoly] :: forall (t_X1Cku :: DSort) (tt_X1Ckw :: SDSort t_X1Cku) (ts_a1Ckv :: [DSort]) (us_a1Ckw :: [DKind ts_a1Ckv  'Kind]) (a_X1CkA :: DKind ( '(:) t_X1Cku ts_a1Ckv)  'Kind) x_a1CG5 x_a1CG9. () => SingSing (WrappedSing DSort t_X1Cku) ( 'WS tt_X1Ckw) ( 'WS x_a1CG5) -> SDType ( '(:) t_X1Cku ts_a1Ckv) (Map (KShiftSym ts_a1Ckv ( '(:) t_X1Cku ts_a1Ckv) t_X1Cku  'Kind ( 'InsZ :: Insert ts_a1Ckv ( '(:) t_X1Cku ts_a1Ckv) t_X1Cku)) us_a1Ckw) a_X1CkA x_a1CG9 -> SDType ts_a1Ckv us_a1Ckw ( 'KPi tt_X1Ckw a_X1CkA) ( 'TPoly x_a1CG5 x_a1CG9)
[STInst] :: forall (t_X1Ckz :: DSort) (tt_X1CkB :: SDSort t_X1Ckz) (ts_a1CkA :: [DSort]) (us_a1CkB :: [DKind ts_a1CkA  'Kind]) (b_X1CkF :: DKind ( '(:) t_X1Ckz ts_a1CkA)  'Kind) (a_X1CkH :: DKind ts_a1CkA t_X1Ckz) (sk_a1CkE :: DKind ts_a1CkA  'Kind) x_a1CUZ x_a1CV3 x_a1CVC. () => SingSing (WrappedSing DSort t_X1Ckz) ( 'WS tt_X1CkB) ( 'WS x_a1CUZ) -> SDType ts_a1CkA us_a1CkB ( 'KPi tt_X1CkB b_X1CkF) x_a1CV3 -> PolySing (SubbedKind ts_a1CkA t_X1Ckz a_X1CkH b_X1CkF sk_a1CkE) x_a1CVC -> SDType ts_a1CkA us_a1CkB sk_a1CkE ( 'TInst x_a1CUZ x_a1CV3 x_a1CVC)
[:%->] :: forall (ts_a1CkF :: [DSort]) (us_a1CkG :: [DKind ts_a1CkF  'Kind]) x_a1CVH x_a1CY9. () => SDType ts_a1CkF us_a1CkG ( 'Type :: DKind ts_a1CkF  'Kind) x_a1CVH -> SDType ts_a1CkF us_a1CkG ( 'Type :: DKind ts_a1CkF  'Kind) x_a1CY9 -> SDType ts_a1CkF us_a1CkG ( 'Type :: DKind ts_a1CkF  'Kind) ( '(:->) x_a1CVH x_a1CY9)
[SPi] :: forall (ts_a1CkH :: [DSort]) (u_X1CkJ :: DKind ts_a1CkH  'Kind) (us_a1CkJ :: [DKind ts_a1CkH  'Kind]) (a_a1CkK :: DKind ts_a1CkH  'Kind) x_a1D0B x_a1D0E. () => PolySing (NDKind ts_a1CkH  'Kind u_X1CkJ) x_a1D0B -> SDType ts_a1CkH ( '(:) u_X1CkJ us_a1CkJ) a_a1CkK x_a1D0E -> SDType ts_a1CkH us_a1CkJ a_a1CkK ( 'Pi x_a1D0B x_a1D0E)
[SBool] :: forall (ts_a1CkL :: [DSort]) (us_a1CkM :: [DKind ts_a1CkL  'Kind]). () => SDType ts_a1CkL us_a1CkM ( 'Type :: DKind ts_a1CkL  'Kind)  'Bool
[SNatural] :: forall (ts_a1CkN :: [DSort]) (us_a1CkO :: [DKind ts_a1CkN  'Kind]). () => SDType ts_a1CkN us_a1CkO ( 'Type :: DKind ts_a1CkN  'Kind)  'Natural
[SList] :: forall (ts_a1CkP :: [DSort]) (us_a1CkQ :: [DKind ts_a1CkP  'Kind]). () => SDType ts_a1CkP us_a1CkQ ((:~>) ( 'Type :: DKind ts_a1CkP  'Kind) ( 'Type :: DKind ts_a1CkP  'Kind))  'List
[SOptional] :: forall (ts_a1CkR :: [DSort]) (us_a1CkS :: [DKind ts_a1CkR  'Kind]). () => SDType ts_a1CkR us_a1CkS ((:~>) ( 'Type :: DKind ts_a1CkR  'Kind) ( 'Type :: DKind ts_a1CkR  'Kind))  'Optional
[SRecord] :: forall (ts_a1CkT :: [DSort]) (us_a1CkU :: [DKind ts_a1CkT  'Kind]) (ls_X1CkW :: [Text]) (as_X1CkY :: [DType ts_a1CkT us_a1CkU ( 'Type :: DKind ts_a1CkT  'Kind)]) x_a1D1d. () => PolySing (AggType (DType ts_a1CkT us_a1CkU ( 'Type :: DKind ts_a1CkT  'Kind)) ls_X1CkW as_X1CkY) x_a1D1d -> SDType ts_a1CkT us_a1CkU ( 'Type :: DKind ts_a1CkT  'Kind) ( 'Record x_a1D1d)
[SUnion] :: forall (ts_a1CkX :: [DSort]) (us_a1CkY :: [DKind ts_a1CkX  'Kind]) (ls_X1Cl0 :: [Text]) (as_X1Cl2 :: [DType ts_a1CkX us_a1CkY ( 'Type :: DKind ts_a1CkX  'Kind)]) x_a1Dbr. () => PolySing (AggType (DType ts_a1CkX us_a1CkY ( 'Type :: DKind ts_a1CkX  'Kind)) ls_X1Cl0 as_X1Cl2) x_a1Dbr -> SDType ts_a1CkX us_a1CkY ( 'Type :: DKind ts_a1CkX  'Kind) ( 'Union x_a1Dbr)
[STRecordLit] :: forall (ts_a1Cl1 :: [DSort]) (ls_X1Cl3 :: [Text]) (as_X1Cl5 :: [DKind ts_a1Cl1  'Kind]) (at_X1Cl7 :: AggType (DKind ts_a1Cl1  'Kind) ls_X1Cl3 as_X1Cl5) (us_a1Cl5 :: [DKind ts_a1Cl1  'Kind]) x_a1DlF x_a1DmL. () => SingSing (AggType (DKind ts_a1Cl1  'Kind) ls_X1Cl3 as_X1Cl5) at_X1Cl7 ( 'WS x_a1DlF) -> PolySing (Prod (DType ts_a1Cl1 us_a1Cl5) as_X1Cl5) x_a1DmL -> SDType ts_a1Cl1 us_a1Cl5 ( 'TRecord at_X1Cl7) ( 'TRecordLit x_a1DlF x_a1DmL)
[STUnionLit] :: forall (ts_a1Cl6 :: [DSort]) (ls_X1Cl8 :: [Text]) (as_X1Cla :: [DKind ts_a1Cl6  'Kind]) (at_X1Clc :: AggType (DKind ts_a1Cl6  'Kind) ls_X1Cl8 as_X1Cla) (a_X1Cle :: DKind ts_a1Cl6  'Kind) (us_a1Clb :: [DKind ts_a1Cl6  'Kind]) x_a1DpA x_a1DqG x_a1DqL. () => SingSing (AggType (DKind ts_a1Cl6  'Kind) ls_X1Cl8 as_X1Cla) at_X1Clc ( 'WS x_a1DpA) -> PolySing (Index as_X1Cla a_X1Cle) x_a1DqG -> SDType ts_a1Cl6 us_a1Clb a_X1Cle x_a1DqL -> SDType ts_a1Cl6 us_a1Clb ( 'TUnion at_X1Clc) ( 'TUnionLit x_a1DpA x_a1DqG x_a1DqL)
data SNDType (ts_a1DE3 :: [DSort]) (us_a1DE4 :: [DKind ts_a1DE3 'Kind]) (a_a1DE5 :: DKind ts_a1DE3 'Kind) (b_a1Ec4 :: DType ts_a1DE3 us_a1DE4 a_a1DE5) (x_a1EkK :: NDType (ts_a1DE3 :: [DSort]) (us_a1DE4 :: [DKind ts_a1DE3 'Kind]) (a_a1DE5 :: DKind ts_a1DE3 'Kind) (b_a1Ec4 :: DType ts_a1DE3 us_a1DE4 a_a1DE5))
[SNDT] :: forall (ts_a1DE6 :: [DSort]) (us_a1DE7 :: [DKind ts_a1DE6  'Kind]) (a_a1DE8 :: DKind ts_a1DE6  'Kind) (x_X1DEa :: DType ts_a1DE6 us_a1DE7 a_a1DE8) x_a1EkL. () => SingSing (DType ts_a1DE6 us_a1DE7 a_a1DE8) x_X1DEa ( 'WS x_a1EkL) -> SNDType ts_a1DE6 us_a1DE7 a_a1DE8 (TNormalize ts_a1DE6 us_a1DE7 a_a1DE8 x_X1DEa) ( 'NDT x_a1EkL)
data SPrim (ts_a1Em4 :: [DSort]) (us_a1Em5 :: [DKind ts_a1Em4 'Kind]) (a_a1EHy :: [DType ts_a1Em4 us_a1Em5 ( 'Type :: DKind ts_a1Em4 'Kind)]) (b_a1EHz :: DType ts_a1Em4 us_a1Em5 ( 'Type :: DKind ts_a1Em4 'Kind)) (x_a1EMt :: Prim (ts_a1Em4 :: [DSort]) (us_a1Em5 :: [DKind ts_a1Em4 'Kind]) (a_a1EHy :: [DType ts_a1Em4 us_a1Em5 ( 'Type :: DKind ts_a1Em4 'Kind)]) (b_a1EHz :: DType ts_a1Em4 us_a1Em5 ( 'Type :: DKind ts_a1Em4 'Kind)))
[SBoolLit] :: forall (ts_a1Em6 :: [DSort]) (us_a1Em7 :: [DKind ts_a1Em6  'Kind]) x_a1EMu. () => PolySing Bool x_a1EMu -> SPrim ts_a1Em6 us_a1Em7 ('[] :: [DType ts_a1Em6 us_a1Em7 ( 'Type :: DKind ts_a1Em6  'Kind)]) ( 'Bool :: DType ts_a1Em6 us_a1Em7 ( 'Type :: DKind ts_a1Em6  'Kind)) ( 'BoolLit x_a1EMu)
[SBoolAnd] :: forall (ts_a1Em8 :: [DSort]) (us_a1Em9 :: [DKind ts_a1Em8  'Kind]). () => SPrim ts_a1Em8 us_a1Em9 ( '(:) ( 'Bool :: DType ts_a1Em8 us_a1Em9 ( 'Type :: DKind ts_a1Em8  'Kind)) ( '(:) ( 'Bool :: DType ts_a1Em8 us_a1Em9 ( 'Type :: DKind ts_a1Em8  'Kind)) ('[] :: [DType ts_a1Em8 us_a1Em9 ( 'Type :: DKind ts_a1Em8  'Kind)]))) ( 'Bool :: DType ts_a1Em8 us_a1Em9 ( 'Type :: DKind ts_a1Em8  'Kind))  'BoolAnd
[SBoolOr] :: forall (ts_a1Ema :: [DSort]) (us_a1Emb :: [DKind ts_a1Ema  'Kind]). () => SPrim ts_a1Ema us_a1Emb ( '(:) ( 'Bool :: DType ts_a1Ema us_a1Emb ( 'Type :: DKind ts_a1Ema  'Kind)) ( '(:) ( 'Bool :: DType ts_a1Ema us_a1Emb ( 'Type :: DKind ts_a1Ema  'Kind)) ('[] :: [DType ts_a1Ema us_a1Emb ( 'Type :: DKind ts_a1Ema  'Kind)]))) ( 'Bool :: DType ts_a1Ema us_a1Emb ( 'Type :: DKind ts_a1Ema  'Kind))  'BoolOr
[SNaturalLit] :: forall (ts_a1Emc :: [DSort]) (us_a1Emd :: [DKind ts_a1Emc  'Kind]) x_a1EMv. () => PolySing Natural x_a1EMv -> SPrim ts_a1Emc us_a1Emd ('[] :: [DType ts_a1Emc us_a1Emd ( 'Type :: DKind ts_a1Emc  'Kind)]) ( 'Natural :: DType ts_a1Emc us_a1Emd ( 'Type :: DKind ts_a1Emc  'Kind)) ( 'NaturalLit x_a1EMv)
[SNaturalFold] :: forall (ts_a1Eme :: [DSort]) (us_a1Emf :: [DKind ts_a1Eme  'Kind]). () => SPrim ts_a1Eme us_a1Emf ('[] :: [DType ts_a1Eme us_a1Emf ( 'Type :: DKind ts_a1Eme  'Kind)]) ((:->) ( 'Natural :: DType ts_a1Eme us_a1Emf ( 'Type :: DKind ts_a1Eme  'Kind)) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Eme  'Kind ( 'Type :: DKind ts_a1Eme  'Kind))) ((:->) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eme  'Kind) us_a1Emf) ( 'Type :: DKind ts_a1Eme  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eme  'Kind) us_a1Emf) ( 'Type :: DKind ts_a1Eme  'Kind)))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eme  'Kind) us_a1Emf) ( 'Type :: DKind ts_a1Eme  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eme  'Kind) us_a1Emf) ( 'Type :: DKind ts_a1Eme  'Kind)))))))  'NaturalFold
[SNaturalBuild] :: forall (ts_a1Emg :: [DSort]) (us_a1Emh :: [DKind ts_a1Emg  'Kind]). () => SPrim ts_a1Emg us_a1Emh ('[] :: [DType ts_a1Emg us_a1Emh ( 'Type :: DKind ts_a1Emg  'Kind)]) ((:->) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Emg  'Kind ( 'Type :: DKind ts_a1Emg  'Kind))) ((:->) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emg  'Kind) us_a1Emh) ( 'Type :: DKind ts_a1Emg  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emg  'Kind) us_a1Emh) ( 'Type :: DKind ts_a1Emg  'Kind)))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emg  'Kind) us_a1Emh) ( 'Type :: DKind ts_a1Emg  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emg  'Kind) us_a1Emh) ( 'Type :: DKind ts_a1Emg  'Kind)))))) ( 'Natural :: DType ts_a1Emg us_a1Emh ( 'Type :: DKind ts_a1Emg  'Kind)))  'NaturalBuild
[SNaturalPlus] :: forall (ts_a1Emi :: [DSort]) (us_a1Emj :: [DKind ts_a1Emi  'Kind]). () => SPrim ts_a1Emi us_a1Emj ( '(:) ( 'Natural :: DType ts_a1Emi us_a1Emj ( 'Type :: DKind ts_a1Emi  'Kind)) ( '(:) ( 'Natural :: DType ts_a1Emi us_a1Emj ( 'Type :: DKind ts_a1Emi  'Kind)) ('[] :: [DType ts_a1Emi us_a1Emj ( 'Type :: DKind ts_a1Emi  'Kind)]))) ( 'Natural :: DType ts_a1Emi us_a1Emj ( 'Type :: DKind ts_a1Emi  'Kind))  'NaturalPlus
[SNaturalTimes] :: forall (ts_a1Emk :: [DSort]) (us_a1Eml :: [DKind ts_a1Emk  'Kind]). () => SPrim ts_a1Emk us_a1Eml ( '(:) ( 'Natural :: DType ts_a1Emk us_a1Eml ( 'Type :: DKind ts_a1Emk  'Kind)) ( '(:) ( 'Natural :: DType ts_a1Emk us_a1Eml ( 'Type :: DKind ts_a1Emk  'Kind)) ('[] :: [DType ts_a1Emk us_a1Eml ( 'Type :: DKind ts_a1Emk  'Kind)]))) ( 'Natural :: DType ts_a1Emk us_a1Eml ( 'Type :: DKind ts_a1Emk  'Kind))  'NaturalTimes
[SNaturalIsZero] :: forall (ts_a1Emm :: [DSort]) (us_a1Emn :: [DKind ts_a1Emm  'Kind]). () => SPrim ts_a1Emm us_a1Emn ('[] :: [DType ts_a1Emm us_a1Emn ( 'Type :: DKind ts_a1Emm  'Kind)]) ((:->) ( 'Natural :: DType ts_a1Emm us_a1Emn ( 'Type :: DKind ts_a1Emm  'Kind)) ( 'Bool :: DType ts_a1Emm us_a1Emn ( 'Type :: DKind ts_a1Emm  'Kind)))  'NaturalIsZero
[SListFold] :: forall (ts_a1Emo :: [DSort]) (us_a1Emp :: [DKind ts_a1Emo  'Kind]). () => SPrim ts_a1Emo us_a1Emp ('[] :: [DType ts_a1Emo us_a1Emp ( 'Type :: DKind ts_a1Emo  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Emo  'Kind ( 'Type :: DKind ts_a1Emo  'Kind))) ((:->) ((:$) ( 'List :: DType ts_a1Emo ( '(:) ( 'Type :: DKind ts_a1Emo  'Kind) us_a1Emp) ((:~>) ( 'Type :: DKind ts_a1Emo  'Kind) ( 'Type :: DKind ts_a1Emo  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emo  'Kind) us_a1Emp) ( 'Type :: DKind ts_a1Emo  'Kind)))) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Emo  'Kind ( 'Type :: DKind ts_a1Emo  'Kind))) ((:->) ((:->) ( 'TVar ( 'IS ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emo  'Kind) us_a1Emp) ( 'Type :: DKind ts_a1Emo  'Kind)) :: Index ( '(:) ( 'Type :: DKind ts_a1Emo  'Kind) ( '(:) ( 'Type :: DKind ts_a1Emo  'Kind) us_a1Emp)) ( 'Type :: DKind ts_a1Emo  'Kind))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emo  'Kind) ( '(:) ( 'Type :: DKind ts_a1Emo  'Kind) us_a1Emp)) ( 'Type :: DKind ts_a1Emo  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emo  'Kind) ( '(:) ( 'Type :: DKind ts_a1Emo  'Kind) us_a1Emp)) ( 'Type :: DKind ts_a1Emo  'Kind))))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emo  'Kind) ( '(:) ( 'Type :: DKind ts_a1Emo  'Kind) us_a1Emp)) ( 'Type :: DKind ts_a1Emo  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emo  'Kind) ( '(:) ( 'Type :: DKind ts_a1Emo  'Kind) us_a1Emp)) ( 'Type :: DKind ts_a1Emo  'Kind))))))))  'ListFold
[SListBuild] :: forall (ts_a1Emq :: [DSort]) (us_a1Emr :: [DKind ts_a1Emq  'Kind]). () => SPrim ts_a1Emq us_a1Emr ('[] :: [DType ts_a1Emq us_a1Emr ( 'Type :: DKind ts_a1Emq  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Emq  'Kind ( 'Type :: DKind ts_a1Emq  'Kind))) ((:->) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Emq  'Kind ( 'Type :: DKind ts_a1Emq  'Kind))) ((:->) ((:->) ( 'TVar ( 'IS ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emq  'Kind) us_a1Emr) ( 'Type :: DKind ts_a1Emq  'Kind)) :: Index ( '(:) ( 'Type :: DKind ts_a1Emq  'Kind) ( '(:) ( 'Type :: DKind ts_a1Emq  'Kind) us_a1Emr)) ( 'Type :: DKind ts_a1Emq  'Kind))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emq  'Kind) ( '(:) ( 'Type :: DKind ts_a1Emq  'Kind) us_a1Emr)) ( 'Type :: DKind ts_a1Emq  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emq  'Kind) ( '(:) ( 'Type :: DKind ts_a1Emq  'Kind) us_a1Emr)) ( 'Type :: DKind ts_a1Emq  'Kind))))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emq  'Kind) ( '(:) ( 'Type :: DKind ts_a1Emq  'Kind) us_a1Emr)) ( 'Type :: DKind ts_a1Emq  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emq  'Kind) ( '(:) ( 'Type :: DKind ts_a1Emq  'Kind) us_a1Emr)) ( 'Type :: DKind ts_a1Emq  'Kind)))))) ((:$) ( 'List :: DType ts_a1Emq ( '(:) ( 'Type :: DKind ts_a1Emq  'Kind) us_a1Emr) ((:~>) ( 'Type :: DKind ts_a1Emq  'Kind) ( 'Type :: DKind ts_a1Emq  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emq  'Kind) us_a1Emr) ( 'Type :: DKind ts_a1Emq  'Kind))))))  'ListBuild
[SListAppend] :: forall (ts_a1Ems :: [DSort]) (us_a1Emt :: [DKind ts_a1Ems  'Kind]) (a_X1Emv :: DType ts_a1Ems us_a1Emt ( 'Type :: DKind ts_a1Ems  'Kind)) x_a1EMx. () => SingSing (DType ts_a1Ems us_a1Emt ( 'Type :: DKind ts_a1Ems  'Kind)) a_X1Emv ( 'WS x_a1EMx) -> SPrim ts_a1Ems us_a1Emt ( '(:) ((:$) ( 'List :: DType ts_a1Ems us_a1Emt ((:~>) ( 'Type :: DKind ts_a1Ems  'Kind) ( 'Type :: DKind ts_a1Ems  'Kind))) a_X1Emv) ( '(:) ((:$) ( 'List :: DType ts_a1Ems us_a1Emt ((:~>) ( 'Type :: DKind ts_a1Ems  'Kind) ( 'Type :: DKind ts_a1Ems  'Kind))) a_X1Emv) ('[] :: [DType ts_a1Ems us_a1Emt ( 'Type :: DKind ts_a1Ems  'Kind)]))) ((:$) ( 'List :: DType ts_a1Ems us_a1Emt ((:~>) ( 'Type :: DKind ts_a1Ems  'Kind) ( 'Type :: DKind ts_a1Ems  'Kind))) a_X1Emv) ( 'ListAppend x_a1EMx)
[SListHead] :: forall (ts_a1Emv :: [DSort]) (us_a1Emw :: [DKind ts_a1Emv  'Kind]). () => SPrim ts_a1Emv us_a1Emw ('[] :: [DType ts_a1Emv us_a1Emw ( 'Type :: DKind ts_a1Emv  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Emv  'Kind ( 'Type :: DKind ts_a1Emv  'Kind))) ((:->) ((:$) ( 'List :: DType ts_a1Emv ( '(:) ( 'Type :: DKind ts_a1Emv  'Kind) us_a1Emw) ((:~>) ( 'Type :: DKind ts_a1Emv  'Kind) ( 'Type :: DKind ts_a1Emv  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emv  'Kind) us_a1Emw) ( 'Type :: DKind ts_a1Emv  'Kind)))) ((:$) ( 'Optional :: DType ts_a1Emv ( '(:) ( 'Type :: DKind ts_a1Emv  'Kind) us_a1Emw) ((:~>) ( 'Type :: DKind ts_a1Emv  'Kind) ( 'Type :: DKind ts_a1Emv  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emv  'Kind) us_a1Emw) ( 'Type :: DKind ts_a1Emv  'Kind))))))  'ListHead
[SListLast] :: forall (ts_a1Emx :: [DSort]) (us_a1Emy :: [DKind ts_a1Emx  'Kind]). () => SPrim ts_a1Emx us_a1Emy ('[] :: [DType ts_a1Emx us_a1Emy ( 'Type :: DKind ts_a1Emx  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Emx  'Kind ( 'Type :: DKind ts_a1Emx  'Kind))) ((:->) ((:$) ( 'List :: DType ts_a1Emx ( '(:) ( 'Type :: DKind ts_a1Emx  'Kind) us_a1Emy) ((:~>) ( 'Type :: DKind ts_a1Emx  'Kind) ( 'Type :: DKind ts_a1Emx  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emx  'Kind) us_a1Emy) ( 'Type :: DKind ts_a1Emx  'Kind)))) ((:$) ( 'Optional :: DType ts_a1Emx ( '(:) ( 'Type :: DKind ts_a1Emx  'Kind) us_a1Emy) ((:~>) ( 'Type :: DKind ts_a1Emx  'Kind) ( 'Type :: DKind ts_a1Emx  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emx  'Kind) us_a1Emy) ( 'Type :: DKind ts_a1Emx  'Kind))))))  'ListLast
[SListReverse] :: forall (ts_a1Emz :: [DSort]) (us_a1EmA :: [DKind ts_a1Emz  'Kind]). () => SPrim ts_a1Emz us_a1EmA ('[] :: [DType ts_a1Emz us_a1EmA ( 'Type :: DKind ts_a1Emz  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Emz  'Kind ( 'Type :: DKind ts_a1Emz  'Kind))) ((:->) ((:$) ( 'List :: DType ts_a1Emz ( '(:) ( 'Type :: DKind ts_a1Emz  'Kind) us_a1EmA) ((:~>) ( 'Type :: DKind ts_a1Emz  'Kind) ( 'Type :: DKind ts_a1Emz  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emz  'Kind) us_a1EmA) ( 'Type :: DKind ts_a1Emz  'Kind)))) ((:$) ( 'List :: DType ts_a1Emz ( '(:) ( 'Type :: DKind ts_a1Emz  'Kind) us_a1EmA) ((:~>) ( 'Type :: DKind ts_a1Emz  'Kind) ( 'Type :: DKind ts_a1Emz  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Emz  'Kind) us_a1EmA) ( 'Type :: DKind ts_a1Emz  'Kind))))))  'ListReverse
[SSome] :: forall (ts_a1EmB :: [DSort]) (us_a1EmC :: [DKind ts_a1EmB  'Kind]) (a_X1EmE :: DType ts_a1EmB us_a1EmC ( 'Type :: DKind ts_a1EmB  'Kind)) x_a1EOZ. () => SingSing (DType ts_a1EmB us_a1EmC ( 'Type :: DKind ts_a1EmB  'Kind)) a_X1EmE ( 'WS x_a1EOZ) -> SPrim ts_a1EmB us_a1EmC ( '(:) a_X1EmE ('[] :: [DType ts_a1EmB us_a1EmC ( 'Type :: DKind ts_a1EmB  'Kind)])) ((:$) ( 'Optional :: DType ts_a1EmB us_a1EmC ((:~>) ( 'Type :: DKind ts_a1EmB  'Kind) ( 'Type :: DKind ts_a1EmB  'Kind))) a_X1EmE) ( 'Some x_a1EOZ)
[SNone] :: forall (ts_a1EmE :: [DSort]) (us_a1EmF :: [DKind ts_a1EmE  'Kind]). () => SPrim ts_a1EmE us_a1EmF ('[] :: [DType ts_a1EmE us_a1EmF ( 'Type :: DKind ts_a1EmE  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1EmE  'Kind ( 'Type :: DKind ts_a1EmE  'Kind))) ((:$) ( 'Optional :: DType ts_a1EmE ( '(:) ( 'Type :: DKind ts_a1EmE  'Kind) us_a1EmF) ((:~>) ( 'Type :: DKind ts_a1EmE  'Kind) ( 'Type :: DKind ts_a1EmE  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EmE  'Kind) us_a1EmF) ( 'Type :: DKind ts_a1EmE  'Kind)))))  'None
data SDTerm (ts_a1EZu :: [DSort]) (us_a1EZv :: [DKind ts_a1EZu 'Kind]) (a_a1FDo :: [DType ts_a1EZu us_a1EZv ( 'Type :: DKind ts_a1EZu 'Kind)]) (b_a1FDp :: DType ts_a1EZu us_a1EZv ( 'Type :: DKind ts_a1EZu 'Kind)) (x_a1FPW :: DTerm (ts_a1EZu :: [DSort]) (us_a1EZv :: [DKind ts_a1EZu 'Kind]) (a_a1FDo :: [DType ts_a1EZu us_a1EZv ( 'Type :: DKind ts_a1EZu 'Kind)]) (b_a1FDp :: DType ts_a1EZu us_a1EZv ( 'Type :: DKind ts_a1EZu 'Kind)))
[SVar] :: forall (ts_a1EZy :: [DSort]) (us_a1EZz :: [DKind ts_a1EZy  'Kind]) (vs_a1EZw :: [DType ts_a1EZy us_a1EZz ( 'Type :: DKind ts_a1EZy  'Kind)]) (a_a1EZx :: DType ts_a1EZy us_a1EZz ( 'Type :: DKind ts_a1EZy  'Kind)) x_a1FPX. () => PolySing (Index vs_a1EZw a_a1EZx) x_a1FPX -> SDTerm ts_a1EZy us_a1EZz vs_a1EZw a_a1EZx ( 'Var x_a1FPX)
[SLam] :: forall (ts_a1EZA :: [DSort]) (us_a1EZB :: [DKind ts_a1EZA  'Kind]) (v_X1EZD :: DType ts_a1EZA us_a1EZB ( 'Type :: DKind ts_a1EZA  'Kind)) (vs_a1EZD :: [DType ts_a1EZA us_a1EZB ( 'Type :: DKind ts_a1EZA  'Kind)]) (a_X1EZG :: DType ts_a1EZA us_a1EZB ( 'Type :: DKind ts_a1EZA  'Kind)) x_a1FQ2 x_a1FRZ. () => PolySing (NDType ts_a1EZA us_a1EZB ( 'Type :: DKind ts_a1EZA  'Kind) v_X1EZD) x_a1FQ2 -> SDTerm ts_a1EZA us_a1EZB ( '(:) v_X1EZD vs_a1EZD) a_X1EZG x_a1FRZ -> SDTerm ts_a1EZA us_a1EZB vs_a1EZD ( '(:->) v_X1EZD a_X1EZG) ( 'Lam x_a1FQ2 x_a1FRZ)
[SApp] :: forall (ts_a1EZF :: [DSort]) (us_a1EZG :: [DKind ts_a1EZF  'Kind]) (vs_a1EZH :: [DType ts_a1EZF us_a1EZG ( 'Type :: DKind ts_a1EZF  'Kind)]) (a_X1EZJ :: DType ts_a1EZF us_a1EZG ( 'Type :: DKind ts_a1EZF  'Kind)) (b_a1EZJ :: DType ts_a1EZF us_a1EZG ( 'Type :: DKind ts_a1EZF  'Kind)) x_a1FSx x_a1FT5. () => SDTerm ts_a1EZF us_a1EZG vs_a1EZH ( '(:->) a_X1EZJ b_a1EZJ) x_a1FSx -> SDTerm ts_a1EZF us_a1EZG vs_a1EZH a_X1EZJ x_a1FT5 -> SDTerm ts_a1EZF us_a1EZG vs_a1EZH b_a1EZJ ( 'App x_a1FSx x_a1FT5)
[SPoly] :: forall (ts_a1EZK :: [DSort]) (u_X1EZM :: DKind ts_a1EZK  'Kind) (uu_X1EZO :: NDKind ts_a1EZK  'Kind u_X1EZM) (us_a1EZN :: [DKind ts_a1EZK  'Kind]) (vs_a1EZO :: [DType ts_a1EZK us_a1EZN ( 'Type :: DKind ts_a1EZK  'Kind)]) (a_X1EZS :: DType ts_a1EZK ( '(:) u_X1EZM us_a1EZN) ( 'Type :: DKind ts_a1EZK  'Kind)) x_a1FTD x_a1FTG. () => SingSing (NDKind ts_a1EZK  'Kind u_X1EZM) uu_X1EZO ( 'WS x_a1FTD) -> SDTerm ts_a1EZK ( '(:) u_X1EZM us_a1EZN) (Map (ShiftSym ts_a1EZK us_a1EZN ( '(:) u_X1EZM us_a1EZN) u_X1EZM ( 'Type :: DKind ts_a1EZK  'Kind) ( 'InsZ :: Insert us_a1EZN ( '(:) u_X1EZM us_a1EZN) u_X1EZM)) vs_a1EZO) a_X1EZS x_a1FTG -> SDTerm ts_a1EZK us_a1EZN vs_a1EZO ( 'Pi uu_X1EZO a_X1EZS) ( 'Poly x_a1FTD x_a1FTG)
[SInst] :: forall (ts_a1EZQ :: [DSort]) (u_X1EZS :: DKind ts_a1EZQ  'Kind) (uu_X1EZU :: NDKind ts_a1EZQ  'Kind u_X1EZS) (us_a1EZT :: [DKind ts_a1EZQ  'Kind]) (vs_a1EZU :: [DType ts_a1EZQ us_a1EZT ( 'Type :: DKind ts_a1EZQ  'Kind)]) (b_X1EZY :: DType ts_a1EZQ ( '(:) u_X1EZS us_a1EZT) ( 'Type :: DKind ts_a1EZQ  'Kind)) (a_X1F00 :: DType ts_a1EZQ us_a1EZT u_X1EZS) x_a1GHW x_a1GHZ x_a1GIx. () => SingSing (NDKind ts_a1EZQ  'Kind u_X1EZS) uu_X1EZU ( 'WS x_a1GHW) -> SDTerm ts_a1EZQ us_a1EZT vs_a1EZU ( 'Pi uu_X1EZU b_X1EZY) x_a1GHZ -> SingSing (DType ts_a1EZQ us_a1EZT u_X1EZS) a_X1F00 ( 'WS x_a1GIx) -> SDTerm ts_a1EZQ us_a1EZT vs_a1EZU (Sub ts_a1EZQ ( '(:) u_X1EZS us_a1EZT) us_a1EZT u_X1EZS ( 'Type :: DKind ts_a1EZQ  'Kind) ( 'DelZ :: Delete ( '(:) u_X1EZS us_a1EZT) us_a1EZT u_X1EZS) a_X1F00 b_X1EZY) ( 'Inst x_a1GHW x_a1GHZ x_a1GIx)
[SP] :: forall (ts_a1EZX :: [DSort]) (us_a1EZY :: [DKind ts_a1EZX  'Kind]) (as_X1F00 :: [DType ts_a1EZX us_a1EZY ( 'Type :: DKind ts_a1EZX  'Kind)]) (a_a1F00 :: DType ts_a1EZX us_a1EZY ( 'Type :: DKind ts_a1EZX  'Kind)) (vs_a1F01 :: [DType ts_a1EZX us_a1EZY ( 'Type :: DKind ts_a1EZX  'Kind)]) x_a1GJ6 x_a1GJF. () => PolySing (Prim ts_a1EZX us_a1EZY as_X1F00 a_a1F00) x_a1GJ6 -> PolySing (Prod (DTerm ts_a1EZX us_a1EZY vs_a1F01) as_X1F00) x_a1GJF -> SDTerm ts_a1EZX us_a1EZY vs_a1F01 a_a1F00 ( 'P x_a1GJ6 x_a1GJF)
[SListLit] :: forall (ts_a1F02 :: [DSort]) (us_a1F03 :: [DKind ts_a1F02  'Kind]) (a_X1F05 :: DType ts_a1F02 us_a1F03 ( 'Type :: DKind ts_a1F02  'Kind)) (vs_a1F05 :: [DType ts_a1F02 us_a1F03 ( 'Type :: DKind ts_a1F02  'Kind)]) x_a1GOx x_a1GQu. () => PolySing (NDType ts_a1F02 us_a1F03 ( 'Type :: DKind ts_a1F02  'Kind) a_X1F05) x_a1GOx -> PolySing [DTerm ts_a1F02 us_a1F03 vs_a1F05 a_X1F05] x_a1GQu -> SDTerm ts_a1F02 us_a1F03 vs_a1F05 ((:$) ( 'List :: DType ts_a1F02 us_a1F03 ((:~>) ( 'Type :: DKind ts_a1F02  'Kind) ( 'Type :: DKind ts_a1F02  'Kind))) a_X1F05) ( 'ListLit x_a1GOx x_a1GQu)
[SOptionalLit] :: forall (ts_a1F06 :: [DSort]) (us_a1F07 :: [DKind ts_a1F06  'Kind]) (a_X1F09 :: DType ts_a1F06 us_a1F07 ( 'Type :: DKind ts_a1F06  'Kind)) (vs_a1F09 :: [DType ts_a1F06 us_a1F07 ( 'Type :: DKind ts_a1F06  'Kind)]) x_a1GZA x_a1H1x. () => PolySing (NDType ts_a1F06 us_a1F07 ( 'Type :: DKind ts_a1F06  'Kind) a_X1F09) x_a1GZA -> PolySing (Maybe (DTerm ts_a1F06 us_a1F07 vs_a1F09 a_X1F09)) x_a1H1x -> SDTerm ts_a1F06 us_a1F07 vs_a1F09 ((:$) ( 'Optional :: DType ts_a1F06 us_a1F07 ((:~>) ( 'Type :: DKind ts_a1F06  'Kind) ( 'Type :: DKind ts_a1F06  'Kind))) a_X1F09) ( 'OptionalLit x_a1GZA x_a1H1x)
[SRecordLit] :: forall (ts_a1F0a :: [DSort]) (us_a1F0b :: [DKind ts_a1F0a  'Kind]) (ls_X1F0d :: [Text]) (as_X1F0f :: [DType ts_a1F0a us_a1F0b ( 'Type :: DKind ts_a1F0a  'Kind)]) (at_X1F0h :: AggType (DType ts_a1F0a us_a1F0b ( 'Type :: DKind ts_a1F0a  'Kind)) ls_X1F0d as_X1F0f) (vs_a1F0f :: [DType ts_a1F0a us_a1F0b ( 'Type :: DKind ts_a1F0a  'Kind)]) x_a1HaD x_a1HkR. () => SingSing (AggType (DType ts_a1F0a us_a1F0b ( 'Type :: DKind ts_a1F0a  'Kind)) ls_X1F0d as_X1F0f) at_X1F0h ( 'WS x_a1HaD) -> PolySing (Prod (DTerm ts_a1F0a us_a1F0b vs_a1F0f) as_X1F0f) x_a1HkR -> SDTerm ts_a1F0a us_a1F0b vs_a1F0f ( 'Record at_X1F0h) ( 'RecordLit x_a1HaD x_a1HkR)
[SUnionLit] :: forall (ts_a1F0g :: [DSort]) (us_a1F0h :: [DKind ts_a1F0g  'Kind]) (ls_X1F0j :: [Text]) (as_X1F0l :: [DType ts_a1F0g us_a1F0h ( 'Type :: DKind ts_a1F0g  'Kind)]) (at_X1F0n :: AggType (DType ts_a1F0g us_a1F0h ( 'Type :: DKind ts_a1F0g  'Kind)) ls_X1F0j as_X1F0l) (a_X1F0p :: DType ts_a1F0g us_a1F0h ( 'Type :: DKind ts_a1F0g  'Kind)) (vs_a1F0m :: [DType ts_a1F0g us_a1F0h ( 'Type :: DKind ts_a1F0g  'Kind)]) x_a1HpJ x_a1HzX x_a1HA2. () => SingSing (AggType (DType ts_a1F0g us_a1F0h ( 'Type :: DKind ts_a1F0g  'Kind)) ls_X1F0j as_X1F0l) at_X1F0n ( 'WS x_a1HpJ) -> PolySing (Index as_X1F0l a_X1F0p) x_a1HzX -> SDTerm ts_a1F0g us_a1F0h vs_a1F0m a_X1F0p x_a1HA2 -> SDTerm ts_a1F0g us_a1F0h vs_a1F0m ( 'Union at_X1F0n) ( 'UnionLit x_a1HpJ x_a1HzX x_a1HA2)
data SAggType (k_a1AGC :: Type) (ls_a1AGD :: [Text]) (as_a1AGE :: [k_a1AGC]) (x_a1ALH :: AggType (k_a1AGC :: Type) (ls_a1AGD :: [Text]) (as_a1AGE :: [k_a1AGC]))
[SATZ] :: forall (k_a1AGF :: Type). () => SAggType k_a1AGF ('[] :: [Text]) ('[] :: [k_a1AGF])  'ATZ
[SATS] :: forall (k_a1AGG :: Type) (l_X1AGI :: Text) (a_X1AGK :: k_a1AGG) (ls_X1AGM :: [Text]) (as_X1AGO :: [k_a1AGG]) x_a1ALI x_a1ALK x_a1ALN. () => SingSing Text l_X1AGI ( 'WS x_a1ALI) -> PolySing (WrappedSing k_a1AGG a_X1AGK) x_a1ALK -> SAggType k_a1AGG ls_X1AGM as_X1AGO x_a1ALN -> SAggType k_a1AGG ( '(:) l_X1AGI ls_X1AGM) ( '(:) a_X1AGK as_X1AGO) ( 'ATS x_a1ALI x_a1ALK x_a1ALN)
sShift :: SInsert us qs a ins -> SDType ts us b x -> SDType ts qs b (Shift ts us qs a b ins x)
sShift1 :: SDType ts us b x -> SDType ts (a : us) b (Shift ts us (a : us) a b  'InsZ x)
sSub :: SDelete us qs a del -> SDType ts qs a x -> SDType ts us b r -> SDType ts qs b (Sub ts us qs a b del x r)
sSub1 :: SDType ts us a x -> SDType ts (a : us) b r -> SDType ts us b (Sub ts (a : us) us a b  'DelZ x r)
skSub :: SDelete ts rs a del -> SDKind rs a x -> SDKind ts b r -> SDKind rs b (KSub ts rs a b del x r)
skSub1 :: SDKind ts a x -> SDKind (a : ts) b r -> SDKind ts b (KSub (a : ts) ts a b  'DelZ x r)
skNormalize :: SDKind ts a x -> SDKind ts a (KNormalize ts a x)
stNormalize :: SDType ts us a x -> SDType ts us a (TNormalize ts us a x)
data KShiftSym ts ps a b :: Insert ts ps a -> DKind ts b ~> DKind ps b
data ShiftSym ts us qs a b :: Insert us qs a -> DType ts us b ~> DType ts qs b
data ShiftSortSym ts ps us a (ins :: Insert ts ps a) :: DType ts us 'Type ~> DType ps (Map (KShiftSym ts ps a 'Kind ins) us) 'Type
type family Map (f :: a ~> b) (xs :: [a]) :: [b]
data MapSym (f :: a ~> b) :: [a] ~> [b]

module Dhall.Typed.Context
data Context ts us :: [DType ts us 'Type] -> Type
[CtxNil] :: Context '[] '[] '[]
[ConsSort] :: Text -> SDSort t -> Context ts us vs -> Context (t : ts) (Map (KShiftSym ts (t : ts) t  'Kind  'InsZ) us) (Map (ShiftSortSym ts (t : ts) us t  'InsZ) vs)
[ConsKind] :: Text -> NDKind ts  'Kind u -> Context ts us vs -> Context ts (u : us) (Map (ShiftSym ts us (u : us) u  'Type  'InsZ) vs)
[ConsType] :: Text -> NDType ts us  'Type v -> Context ts us vs -> Context ts us (v : vs)
data ContextItem ts us :: [DType ts us 'Type] -> Type
[TCISort] :: Index ts t -> SDSort t -> ContextItem ts us vs
[TCIKind] :: Index us u -> NDKind ts  'Kind u -> ContextItem ts us vs
[TCIType] :: Index vs v -> NDType ts us  'Type v -> ContextItem ts us vs
lookupCtx :: forall ts us vs. () => Text -> Integer -> Context ts us vs -> Maybe (ContextItem ts us vs)
data ShiftSortSym ts ps us a (ins :: Insert ts ps a) :: DType ts us 'Type ~> DType ps (Map (KShiftSym ts ps a 'Kind ins) us) 'Type

module Dhall.Typed
toTyped :: forall ts us vs. () => Context ts us vs -> Expr () X -> Either TypeMessage (SomeDExpr ts us vs)
fromTyped :: DExpr ts us vs n -> Expr () X
fromDTerm :: DTerm ts us vs a -> Expr () X
fromDType :: DType ts us a -> Expr () X
fromDKind :: DKind ts a -> Expr () X
fromDSort :: DSort -> Expr () X
instance GHC.Show.Show Dhall.Typed.TypeMessage
