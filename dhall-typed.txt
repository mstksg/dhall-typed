-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/dhall-typed#readme</a>
@package dhall-typed
@version 0.1.0.0

module Dhall.Typed.Type.Bool
type family (x :: Bool) && (y :: Bool) :: Bool

module Dhall.Typed.Type.N
data N
Z :: N
S :: N -> N

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
type SN = (Sing :: N -> Type)
fromNatural :: Natural -> N
toNatural :: N -> Natural
type ZSym0 = Z
data SSym0 :: (~>) N N
type SSym1 (t6989586621679138827 :: N) = S t6989586621679138827
data IsLength :: [k] -> N -> Type
[ILZ] :: IsLength '[]  'Z
[ILS] :: IsLength as n -> IsLength (a : as) ( 'S n)
data Fin :: N -> Type
[FZ] :: Fin ( 'S n)
[FS] :: Fin n -> Fin ( 'S n)
data SFin n :: Fin n -> Type
[SFZ] :: SFin ( 'S n)  'FZ
[SFS] :: SFin n x -> SFin ( 'S n) ( 'FS x)
type family ShiftFin n (i :: Fin n) :: Fin n
data LTE :: N -> N -> Type
[LTEZ] :: LTE  'Z m
[LTES] :: LTE n m -> LTE ( 'S n) ( 'S m)
type N0 =  'Z
type N1 =  'S N0
type N2 =  'S N1
type N3 =  'S N2
type N4 =  'S N3
type N5 =  'S N4
type F0 =  'FZ
type F1 =  'FS F0
type F2 =  'FS F1
type F3 =  'FS F2
type F4 =  'FS F3
type F5 =  'FS F4
sf0 :: SFin ( 'S n) F0
sf1 :: SFin ( 'S ( 'S n)) F1
sf2 :: SFin ( 'S ( 'S ( 'S n))) F2
sf3 :: SFin ( 'S ( 'S ( 'S ( 'S n)))) F3
sf4 :: SFin ( 'S ( 'S ( 'S ( 'S ( 'S n))))) F4
sf5 :: SFin ( 'S ( 'S ( 'S ( 'S ( 'S ( 'S n)))))) F5
instance GHC.Show.Show Dhall.Typed.Type.N.N
instance GHC.Classes.Ord Dhall.Typed.Type.N.N
instance GHC.Classes.Eq Dhall.Typed.Type.N.N
instance Data.Singletons.ShowSing.ShowSing Dhall.Typed.Type.N.N => GHC.Show.Show (Data.Singletons.Internal.Sing z)
instance Data.Singletons.Prelude.Eq.PEq Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.ShowsPrec_6989586621679144336Sym0
instance Data.Singletons.Prelude.Show.PShow Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.ShowsPrec_6989586621679144336Sym1 a6989586621679144333)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.ShowsPrec_6989586621679144336Sym2 a6989586621679144334 a6989586621679144333)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.Compare_6989586621679140792Sym0
instance Data.Singletons.Prelude.Ord.POrd Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.Compare_6989586621679140792Sym1 a6989586621679140790)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.SSym0
instance Data.Singletons.Internal.SingI Dhall.Typed.Type.N.SSym0
instance Data.Singletons.Internal.SingKind Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Ord.SOrd Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Ord.SOrd Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Show.SShow Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Show.SShow Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Eq.SEq Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Eq.SEq Dhall.Typed.Type.N.N
instance Data.Singletons.Decide.SDecide Dhall.Typed.Type.N.N => Data.Singletons.Decide.SDecide Dhall.Typed.Type.N.N
instance Data.Singletons.Internal.SingI 'Dhall.Typed.Type.N.Z
instance Data.Singletons.Internal.SingI n => Data.Singletons.Internal.SingI ('Dhall.Typed.Type.N.S n)
instance Data.Singletons.Internal.SingI (Data.Singletons.Internal.TyCon1 'Dhall.Typed.Type.N.S)

module Dhall.Typed.Plugin
plugin :: Plugin

module Dhall.Typed.Type.Option
data Option :: (k -> Type) -> Maybe k -> Type
[Noot] :: Option f  'Nothing
[Juus] :: f a -> Option f ( 'Just a)

module Dhall.Typed.Type.Singletons.TH
genPolySing :: DsMonad q => Name -> q [Dec]
genPolySingWith :: DsMonad q => GenPolySingOpts -> Name -> q [Dec]
data GenPolySingOpts
GPSO :: !Bool -> !Bool -> !GenOpts -> !GenOpts -> GenPolySingOpts
[gpsoSing] :: GenPolySingOpts -> !Bool
[gpsoSingI] :: GenPolySingOpts -> !Bool
[gpsoPSK] :: GenPolySingOpts -> !GenOpts
[gpsoSingEq] :: GenPolySingOpts -> !GenOpts
defaultGPSO :: GenPolySingOpts
data GenOpts
GOInfer :: GenOpts
GOSkip :: GenOpts
GOHead :: Q [Dec] -> GenOpts
genPolySingKind :: forall q. DsMonad q => q [Dec] -> q [Dec]
genSingEq :: forall q. DsMonad q => q [Dec] -> q [Dec]
instance GHC.Base.Functor Dhall.Typed.Type.Singletons.TH.V2
instance GHC.Base.Applicative Dhall.Typed.Type.Singletons.TH.V2
instance GHC.Base.Monad Dhall.Typed.Type.Singletons.TH.V2
instance Data.Default.Class.Default Dhall.Typed.Type.Singletons.TH.GenPolySingOpts

module Dhall.Typed.Type.Singletons
type family PolySing k = (s :: k -> Type) | s -> k
class PolySingI (x :: k)
polySing :: PolySingI x => PolySing k x
class PolySingKind k
fromPolySing :: PolySingKind k => PolySing k x -> k
toPolySing :: PolySingKind k => k -> SomePolySing k
data SomePolySing k
[SomePS] :: PolySing k x -> SomePolySing k
newtype WrappedSing k (x :: k)
WS :: PolySing k x -> WrappedSing k
[getWS] :: WrappedSing k -> PolySing k x
newtype SingSing k x :: WrappedSing k x -> Type
[SiSi] :: forall k x (ws :: WrappedSing k x). () => {getSiSi :: PolySing k x} -> SingSing k x ws
type PolySingOfI (x :: PolySing k y) = PolySingI y
class SingEq f g
singEq :: forall x y. SingEq f g => PolySing f x -> PolySing g y -> Decision (x :~~: y)
data SConst (a_axGx :: Type) (b_axGy :: k_axGw) (x_a1sr5 :: Const (a_axGx :: Type) (b_axGy :: k_axGw))
[SConst] :: forall (a_axGx :: Type) (b_axGy :: k_axGw) x_a1sr6. () => {sGetConst :: PolySing a_axGx x_a1sr6} -> SConst (a_axGx :: Type) (b_axGy :: k_axGw) ( 'Const x_a1sr6)
data SMaybe (a_11 :: Type) (x_a1swW :: Maybe (a_11 :: Type))
[SNothing] :: forall (a_11 :: Type). () => SMaybe (a_11 :: Type)  'Nothing
[SJust] :: forall (a_11 :: Type) x_a1swX. () => PolySing a_11 x_a1swX -> SMaybe (a_11 :: Type) ( 'Just x_a1swX)
data SList k :: [k] -> Type
[:%] :: PolySing k x -> SList k xs -> SList k (x : xs)
[SNil] :: SList k '[]
infixr 5 :%
data STup2 a b :: (a, b) -> Type
[STup2] :: PolySing a x -> PolySing b y -> STup2 a b '(x, y)
data SBool :: Bool -> Type
[SFalse] :: SBool  'False
[STrue] :: SBool  'True
data SProxy (t_a1iG6 :: k_a1iG5) (x_a1sBo :: Proxy (t_a1iG6 :: k_a1iG5))
[SProxy] :: forall (t_a1iG6 :: k_a1iG5). () => SProxy (t_a1iG6 :: k_a1iG5)  'Proxy
data STup0 :: () -> Type
[STup0] :: STup0  '()
type family ToNat (n :: Natural) = (m :: Nat) | m -> n
type family FromNat (m :: Nat) = (n :: Natural) | n -> m
data SNatural :: Natural -> Type
[SNat] :: KnownNat (ToNat n) => SNatural n
withKnownNatural :: forall n r. KnownNat n => (KnownNat (ToNat (FromNat n)) => r) -> r
type family ToSym (t :: Text) = (s :: Symbol) | s -> t
type family FromSym (s :: Symbol) = (t :: Text) | t -> s
data SText :: Text -> Type
[SText] :: KnownSymbol (ToSym t) => SText t
withKnownText :: forall n r. KnownSymbol n => (KnownSymbol (ToSym (FromSym n)) => r) -> r
instance GHC.TypeLits.KnownSymbol (Dhall.Typed.Type.Singletons.ToSym t) => Dhall.Typed.Type.Singletons.Internal.PolySingI t
instance Dhall.Typed.Type.Singletons.Internal.PolySingKind Data.Text.Internal.Text
instance Dhall.Typed.Type.Singletons.Internal.SingEq Data.Text.Internal.Text Data.Text.Internal.Text
instance GHC.TypeNats.KnownNat (Dhall.Typed.Type.Singletons.ToNat n) => Dhall.Typed.Type.Singletons.Internal.PolySingI n
instance Dhall.Typed.Type.Singletons.Internal.PolySingKind GHC.Natural.Natural
instance Dhall.Typed.Type.Singletons.Internal.SingEq GHC.Natural.Natural GHC.Natural.Natural
instance forall k (t :: k). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Data.Proxy.Proxy
instance forall k (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Proxy.Proxy a)
instance forall k (a :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Proxy.Proxy a) (Data.Proxy.Proxy a)
instance Dhall.Typed.Type.Singletons.Internal.PolySingI 'GHC.Maybe.Nothing
instance forall a (x :: a). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('GHC.Maybe.Just x)
instance Dhall.Typed.Type.Singletons.Internal.PolySingKind a => Dhall.Typed.Type.Singletons.Internal.PolySingKind (GHC.Maybe.Maybe a)
instance Dhall.Typed.Type.Singletons.Internal.SingEq a a => Dhall.Typed.Type.Singletons.Internal.SingEq (GHC.Maybe.Maybe a) (GHC.Maybe.Maybe a)
instance forall k (b :: k) a (x :: a). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Data.Functor.Const.Const x)
instance forall k a (b :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind a => Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Functor.Const.Const a b)
instance forall k a b (c :: k). Dhall.Typed.Type.Singletons.Internal.SingEq a b => Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Functor.Const.Const a c) (Data.Functor.Const.Const b c)

module Dhall.Typed.Type.Index

-- | Witness an item in a type-level list by providing its index.
data Index (a :: [k]) (b :: k) :: forall k. () => [k] -> k -> Type
[IZ] :: forall k (a :: [k]) (b :: k) (as :: [k]). () => Index (b : as) b
[IS] :: forall k (a :: [k]) (b :: k) (bs :: [k]) (b1 :: k). () => Index bs b -> Index (b1 : bs) b
data SIndex (a_a1vVk :: [k_a1vVj]) (b_a1vVl :: k_a1vVj) (x_a1vVz :: Index (a_a1vVk :: [k_a1vVj]) (b_a1vVl :: k_a1vVj))
[SIZ] :: forall (k_a1vVj :: Type) (b_a1vVl :: k_a1vVj) (as_a1vVm :: [k_a1vVj]). () => SIndex ( '(:) b_a1vVl as_a1vVm) b_a1vVl  'IZ
[SIS] :: forall (k_a1vVj :: Type) (bs_a1vVp :: [k_a1vVj]) (b_a1vVl :: k_a1vVj) (b1_a1vVq :: k_a1vVj) x_a1vVA. () => SIndex bs_a1vVp b_a1vVl x_a1vVA -> SIndex ( '(:) b1_a1vVq bs_a1vVp) b_a1vVl ( 'IS x_a1vVA)
sSameIx :: SIndex as a i -> SIndex as a j -> Maybe (i :~: j)
fromSIndex :: SIndex as a i -> Index as a
data SSIndex (a_a1vVk :: [k_a1vVj]) (b_a1vVl :: k_a1vVj) (x_a1vVz :: Index a_a1vVk b_a1vVl) (x_a1w2s :: SIndex (a_a1vVk :: [k_a1vVj]) (b_a1vVl :: k_a1vVj) (x_a1vVz :: Index a_a1vVk b_a1vVl))
[SSIZ] :: forall (k_a1vVj :: Type) (b_a1vVl :: k_a1vVj) (as_X1vVn :: [k_a1vVj]). () => SSIndex ( '(:) b_a1vVl as_X1vVn) b_a1vVl ( 'IZ :: Index ( '(:) b_a1vVl as_X1vVn) b_a1vVl)  'SIZ
[SSIS] :: forall (k_a1vVj :: Type) (bs_X1vVq :: [k_a1vVj]) (b_a1vVl :: k_a1vVj) (b1_X1vVs :: k_a1vVj) (x_X1vVD :: Index bs_X1vVq b_a1vVl) x_a1w2t. () => SingSing (Index bs_X1vVq b_a1vVl) x_X1vVD ( 'WS x_a1w2t) -> SSIndex ( '(:) b1_X1vVs bs_X1vVq) b_a1vVl ( 'IS x_X1vVD :: Index ( '(:) b1_X1vVs bs_X1vVq) b_a1vVl) ( 'SIS x_a1w2t)
indexN :: Index as a -> N
data Delete :: [k] -> [k] -> k -> Type
[DelZ] :: Delete (a : as) as a
[DelS] :: Delete as bs c -> Delete (a : as) (a : bs) c
del :: Delete as bs a -> Index as b -> Maybe (Index bs b)
type family ISMaybe (i :: Maybe (Index as a)) :: Maybe (Index (b : as) a)
type family Del as bs a b (d :: Delete as bs a) (i :: Index as b) :: Maybe (Index bs b)
data SDelete (a_a1wav :: [k_a1w3d]) (b_a1waw :: [k_a1w3d]) (c_a1wax :: k_a1w3d) (x_a1wge :: Delete (a_a1wav :: [k_a1w3d]) (b_a1waw :: [k_a1w3d]) (c_a1wax :: k_a1w3d))
[SDelZ] :: forall (k_a1wa5 :: Type) (a_a1w3e :: k_a1wa5) (as_a1w3f :: [k_a1wa5]). () => SDelete ( '(:) a_a1w3e as_a1w3f) as_a1w3f a_a1w3e  'DelZ
[SDelS] :: forall (a_a1wam :: Type) (as_X1w3h :: [a_a1wam]) (bs_X1w3j :: [a_a1wam]) (c_a1w3i :: a_a1wam) (a_X1w3m :: a_a1wam) x_a1wgf. () => SDelete as_X1w3h bs_X1w3j c_a1w3i x_a1wgf -> SDelete ( '(:) a_X1w3m as_X1w3h) ( '(:) a_X1w3m bs_X1w3j) c_a1w3i ( 'DelS x_a1wgf)
sDel :: SDelete as bs a del -> SIndex as b i -> GetDeleted as bs a b del i
data GetDeleted as bs a b :: Delete as bs a -> Index as b -> Type
[GotDeleted] :: Del as bs a b del i ~  'Nothing => (a :~: b) -> GetDeleted as bs a b del i
[ThatsToxic] :: Del as bs a b del i ~  'Just j => SIndex bs b j -> GetDeleted as bs a b del i

-- | This is just flipped delete, heh.
data Insert :: [k] -> [k] -> k -> Type
[InsZ] :: Insert as (a : as) a
[InsS] :: Insert as bs c -> Insert (a : as) (a : bs) c
insert :: Insert as bs a -> Index as b -> Index bs b
type family Ins as bs a b (ins :: Insert as bs a) (i :: Index as b) :: Index bs b
sIns :: forall as bs a b ins i. () => SInsert as bs a ins -> SIndex as b i -> SIndex bs b (Ins as bs a b ins i)
data SInsert (a_a1wtJ :: [k_a1wgS]) (b_a1wtK :: [k_a1wgS]) (c_a1wtL :: k_a1wgS) (x_a1wzh :: Insert (a_a1wtJ :: [k_a1wgS]) (b_a1wtK :: [k_a1wgS]) (c_a1wtL :: k_a1wgS))
[SInsZ] :: forall (a_a1wtk :: Type) (as_a1wgT :: [a_a1wtk]) (a_a1wgU :: a_a1wtk). () => SInsert as_a1wgT ( '(:) a_a1wgU as_a1wgT) a_a1wgU  'InsZ
[SInsS] :: forall (a_a1wtA :: Type) (as_X1wgW :: [a_a1wtA]) (bs_X1wgY :: [a_a1wtA]) (c_a1wgX :: a_a1wtA) (a_X1wh1 :: a_a1wtA) x_a1wzi. () => SInsert as_X1wgW bs_X1wgY c_a1wgX x_a1wzi -> SInsert ( '(:) a_X1wh1 as_X1wgW) ( '(:) a_X1wh1 bs_X1wgY) c_a1wgX ( 'InsS x_a1wzi)

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
instance forall a1 (as :: [a1]) (a2 :: a1). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Index.InsZ
instance forall a1 (a2 :: a1) (as :: [a1]) (bs :: [a1]) (c :: a1) (x :: Dhall.Typed.Type.Index.Insert as bs c). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Index.InsS x)
instance forall k (a :: [k]) (b :: [k]) (c :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Index.Insert a b c)
instance forall k (a1 :: [k]) (a2 :: [k]) (a3 :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Index.Insert a1 a2 a3) (Dhall.Typed.Type.Index.Insert a1 a2 b)
instance forall k (a :: k) (as :: [k]). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Index.DelZ
instance forall a1 (a2 :: a1) (as :: [a1]) (bs :: [a1]) (c :: a1) (x :: Dhall.Typed.Type.Index.Delete as bs c). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Index.DelS x)
instance forall k (a :: [k]) (b :: [k]) (c :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Index.Delete a b c)
instance forall k (a1 :: [k]) (a2 :: [k]) (a3 :: k) (b1 :: [k]) (b2 :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Index.Delete a1 a2 a3) (Dhall.Typed.Type.Index.Delete a1 b1 b2)
instance forall k (as :: [k]) (a :: k) (i :: Data.Type.Universe.Index as a). GHC.Show.Show (Dhall.Typed.Type.Index.SIndex as a i)
instance forall k (b :: k) (as :: [k]). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Index.SIZ
instance forall k (b1 :: k) (bs :: [k]) (b :: k) (y :: Data.Type.Universe.Index bs b) (x :: Dhall.Typed.Type.Index.SIndex bs b y). Dhall.Typed.Type.Singletons.Internal.PolySingOfI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Index.SIS x)
instance forall k (as :: [k]) (a :: k) (x :: Data.Type.Universe.Index as a). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Index.SIndex as a x)
instance forall k (as :: [k]) (a :: k) (x :: Data.Type.Universe.Index as a) (b :: k) (y :: Data.Type.Universe.Index as b). Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Index.SIndex as a x) (Dhall.Typed.Type.Index.SIndex as b y)
instance forall k (as :: [k]) (a :: k). Data.Singletons.Internal.SingKind (Data.Type.Universe.Index as a)
instance forall k (b :: k) (as :: [k]). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Data.Type.Universe.IZ
instance forall k (b1 :: k) (bs :: [k]) (b :: k) (x :: Data.Type.Universe.Index bs b). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Data.Type.Universe.IS x)
instance forall k (as :: [k]) (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Type.Universe.Index as a)
instance forall k (as :: [k]) (a :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Type.Universe.Index as a) (Data.Type.Universe.Index as b)

module Dhall.Typed.Type.Prod
data Prod :: (k -> Type) -> [k] -> Type
[Ø] :: Prod f '[]
[:<] :: f a -> Prod f as -> Prod f (a : as)
infixr 5 :<
traverseProd :: forall f g h as. Applicative h => (forall x. f x -> h (g x)) -> Prod f as -> h (Prod g as)
mapProd :: forall f g as. () => (forall x. f x -> g x) -> Prod f as -> Prod g as
zipProd :: Prod f as -> Prod g as -> Prod (f :*: g) as
singProd :: SList k as -> Prod (PolySing k) as
prodSing :: Prod (PolySing k) as -> SList k as
ixProd :: Prod f as -> Index as a -> f a
data SeqListEq :: Seq a -> [a] -> Type
[SeqListEq] :: SeqListEq xs ys
type family IxProd f as b (p :: Prod f as) (i :: Index as b) :: f b
data SProd (a_a1xYQ :: k_a1xXY -> Type) (b_a1xYR :: [k_a1xXY]) (x_a1y1H :: Prod (a_a1xYQ :: k_a1xXY -> Type) (b_a1xYR :: [k_a1xXY]))
[SØ] :: forall (k_a1xYp :: Type) (f_a1xXZ :: k_a1xYp -> Type). () => SProd f_a1xXZ ('[] :: [k_a1xYp])  'Ø
[:%<] :: forall (a_a1xYH :: Type) (f_a1xY0 :: a_a1xYH -> Type) (a_X1xY2 :: a_a1xYH) (as_X1xY4 :: [a_a1xYH]) x_a1y1I x_a1y1J. () => PolySing (f_a1xY0 a_X1xY2) x_a1y1I -> SProd f_a1xY0 as_X1xY4 x_a1y1J -> SProd f_a1xY0 ( '(:) a_X1xY2 as_X1xY4) ( '(:<) x_a1y1I x_a1y1J)
sIxProd :: SProd f as xs -> SIndex as a i -> PolySing (f a) (IxProd f as a xs i)
type family ProdList (xs :: Prod (Const k) ys) :: [k]
data BiProd :: (k -> Type) -> (j -> Type) -> [k] -> [j] -> Type
[BZ] :: BiProd f g '[] '[]
[BS] :: f a -> g b -> BiProd f g as bs -> BiProd f g (a : as) (b : bs)
data SBiProd (a_a1y8j :: k_a1y2y -> Type) (b_a1y8k :: j_a1y2z -> Type) (c_a1y8l :: [k_a1y2y]) (d_a1y8m :: [j_a1y2z]) (x_a1ydO :: BiProd (a_a1y8j :: k_a1y2y -> Type) (b_a1y8k :: j_a1y2z -> Type) (c_a1y8l :: [k_a1y2y]) (d_a1y8m :: [j_a1y2z]))
[SBZ] :: forall (k_a1y7H :: Type) (j_a1y7I :: Type) (f_a1y2A :: k_a1y7H -> Type) (g_a1y2B :: j_a1y7I -> Type). () => SBiProd f_a1y2A g_a1y2B ('[] :: [k_a1y7H]) ('[] :: [j_a1y7I])  'BZ
[SBS] :: forall (a_a1y89 :: Type) (a_a1y8a :: Type) (f_a1y2C :: a_a1y89 -> Type) (a_X1y2E :: a_a1y89) (g_a1y2E :: a_a1y8a -> Type) (b_X1y2H :: a_a1y8a) (as_X1y2J :: [a_a1y89]) (bs_X1y2L :: [a_a1y8a]) x_a1ydP x_a1ydQ x_a1ydR. () => PolySing (f_a1y2C a_X1y2E) x_a1ydP -> PolySing (g_a1y2E b_X1y2H) x_a1ydQ -> SBiProd f_a1y2C g_a1y2E as_X1y2J bs_X1y2L x_a1ydR -> SBiProd f_a1y2C g_a1y2E ( '(:) a_X1y2E as_X1y2J) ( '(:) b_X1y2H bs_X1y2L) ( 'BS x_a1ydP x_a1ydQ x_a1ydR)
instance forall k (f :: k -> *) j (g :: j -> *). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Prod.BZ
instance forall a1 (as :: [a1]) a2 (bs :: [a2]) (g :: a2 -> *) (b :: a2) (f :: a1 -> *) (a3 :: a1) (x1 :: f a3) (x2 :: g b) (x3 :: Dhall.Typed.Type.Prod.BiProd f g as bs). (Dhall.Typed.Type.Singletons.Internal.PolySingI x1, Dhall.Typed.Type.Singletons.Internal.PolySingI x2, Dhall.Typed.Type.Singletons.Internal.PolySingI x3) => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Prod.BS x1 x2 x3)
instance forall j k (f :: k -> *) (g :: j -> *) (as :: [k]) (bs :: [j]). (forall (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (f a), forall (a :: j). Dhall.Typed.Type.Singletons.Internal.PolySingKind (g a)) => Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Prod.BiProd f g as bs)
instance forall j k (f :: k -> *) (g :: j -> *) (as :: [k]) (bs :: [j]) (cs :: [k]) (ds :: [j]). (forall (a :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (f a) (f b), forall (a :: j) (b :: j). Dhall.Typed.Type.Singletons.Internal.SingEq (g a) (g b)) => Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Prod.BiProd f g as bs) (Dhall.Typed.Type.Prod.BiProd f g cs ds)
instance forall k (f :: k -> *). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Prod.Ø
instance forall a1 (as :: [a1]) (f :: a1 -> *) (a2 :: a1) (x1 :: f a2) (x2 :: Dhall.Typed.Type.Prod.Prod f as). (Dhall.Typed.Type.Singletons.Internal.PolySingI x1, Dhall.Typed.Type.Singletons.Internal.PolySingI x2) => Dhall.Typed.Type.Singletons.Internal.PolySingI (x1 'Dhall.Typed.Type.Prod.:< x2)
instance forall k (f :: k -> *) (as :: [k]). (forall (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (f a)) => Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Prod.Prod f as)
instance forall k (f :: k -> *) (as :: [k]) (bs :: [k]). (forall (a :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (f a) (f b)) => Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Prod.Prod f as) (Dhall.Typed.Type.Prod.Prod f bs)


-- | Implementing a typed lambda calculus. Uses De Bruijn indices in
--   separate namespaces (that is, kind, type, term variables all have
--   their own separate De Bruijn indexing)
--   
--   We have a hierarchy: Term -&gt; Type -&gt; Kind -&gt; Sort. We can
--   stop at Sort because we don't allow any Sort variables, so there is no
--   need to talk about the "type" of any Sorts. Disallowing variables
--   effectively stops the chain.
--   
--   It looks like each level has some sets of constructors just from its
--   position on the chain.
--   
--   <ul>
--   <li>At all levels, we have <i>primitives</i>. Term-level primitives
--   are built-in functions and values and literals. Type-level primitives
--   are built-in types and type functions. Dhall has no kind- or
--   sort-level primitives.</li>
--   <li>If a level has variables (Terms, Types, Kinds), we gain some
--   constructors:<ul><li>Var, the variable constructor j Lam, the function
--   abstraction</li><li>App, the function application</li></ul></li>
--   <li>If a level has variables and its "type" also has variables (Terms,
--   Types), we gain some constructors:<ul><li>Poly, the type
--   abstraction</li><li>Inst (instantiation), the type
--   application</li></ul></li>
--   <li>If a level is the "type" of something (n &gt;= 1), we gain a
--   function type constructor, the type of function abstractions in the
--   immediately lower level.</li>
--   <li>If a level is the "type" of a "type" of something (n &gt;= 2), we
--   gain an "constant" constructor that links the two layers below it
--   together. Examples are the Kind sort that links Kinds to Types (all
--   types have kinds of sort Kind), and the Type kind that links types to
--   values (all terms have types of kind Type)</li>
--   <li>If a type is the "type" of something (n &gt;= 1), <i>and</i> it
--   has variables, we have a Pi type constructor, the type of type
--   abstractions (type-polymorphic values) in the lower level.</li>
--   </ul>
--   
--   We actually gain a Pi type for our current level, and each level above
--   our current level (that has variables). So for the Type level, we have
--   Type-Pi and Kind-Pi, and for the Kind level, we have Kind-Pi.
--   
--   So to summarize:
--   
--   <ul>
--   <li>n = 3: Sort has a constant (it is n &gt;= 2) and a function type
--   constructor (it is n &gt;= 1). It could also potentially have
--   primitives, but Dhall has no sort primitives.</li>
--   <li>n = 2: Kind has variables, so it has Var, Lam, and App. It has a
--   constant (they are n &gt;= 2) and a function type constructor and a Pi
--   constructor (it is n &gt;= 1 and has variables). It could also
--   potentially have primitives; Dhall has only record and union kinds as
--   primitives.</li>
--   <li>n = 1: Type has variables, so it has Var, Lam, and App. It has a
--   function type constructor and a Pi constructor (it is n &gt;= 1 and
--   has variables). Because its "type" has variables (Kind), it also has
--   Poly and Inst. It has primitives, and in Dhall ther are several.</li>
--   <li>n = 0: Term has variables, so it has Var, Lam, and App. Because
--   its "type" has variables, it has Poly and Inst. In Dhall, it has
--   multitudes of primitives.</li>
--   </ul>
module Dhall.Typed.LC
instance forall (ts :: [Dhall.Typed.LC.DSort]) (vs :: [Dhall.Typed.LC.DKind ts 'Dhall.Typed.LC.Kind]) (a :: Dhall.Typed.LC.DKind ts 'Dhall.Typed.LC.Kind). Data.Singletons.Internal.SingKind (Dhall.Typed.LC.DType ts vs a)
instance Data.Singletons.Internal.SingKind (Dhall.Typed.LC.DKind ts a)
instance Data.Singletons.Internal.SingKind Dhall.Typed.LC.DSort

module Dhall.Typed.Core

-- | Represents the possible sorts encountered in Dhall.
--   
--   Note that this implementation allows records of kinds with sorts other
--   than <a>Kind</a>, so <tt>{ foo : Kind -&gt; Kind }</tt> would
--   typecheck, even though normal Dhall forbids this.
--   
--   A <a>DSort</a> is always in normal form.
data DSort :: Type
[Kind] :: DSort
[:*>] :: DSort -> DSort -> DSort
[KRecord] :: AggType () ls as -> DSort
[KUnion] :: AggType () ls as -> DSort

-- | Represents the possible types encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DKind</a> '[r, s] t
--   </pre>
--   
--   Describes a kind of sort <tt>t</tt> with possible kind variables of
--   sorts <tt>r</tt> and <tt>s</tt>.
--   
--   Something of type <tt><a>DKind</a> '[] t</tt> is a kind of sort
--   <tt>t</tt> with no free variables.
data DKind :: [DSort] -> DSort -> Type
[KVar] :: Index ts a -> DKind ts a
[KLam] :: SDSort t -> DKind (t : ts) a -> DKind ts (t :*> a)
[KApp] :: DKind ts (a :*> b) -> DKind ts a -> DKind ts b
[:~>] :: DKind ts  'Kind -> DKind ts  'Kind -> DKind ts  'Kind
[KPi] :: SDSort t -> DKind (t : ts) a -> DKind ts a
[Type] :: DKind ts  'Kind
infixr 1 :~>
data SomeKind :: [DSort] -> Type
[SomeKind] :: SDSort a -> DKind ts a -> SomeKind ts
type a :~> b = a :~> b
infixr 1 :~>

-- | Shift all kind variables in a kind expression of sort <tt>b</tt> to
--   account for a new bound variable of sort <tt>a</tt>, to be inserted at
--   the position indicated by the <a>Insert</a>.
type family KShift ts ps a b (ins :: Insert ts ps a) (x :: DKind ts b) :: DKind ps b
toSomeKind :: PolySingI a => DKind ts a -> SomeKind ts

-- | Ideally we would want this to be encodable within the type. But the
--   main problem here is checking if the LHS of an application is a
--   variable or not. This is the next best thing?
type family KNormalize ts a (x :: DKind ts a) :: DKind ts a

-- | Version of <a>SDKind</a> that exposes itself in normal form.
data NDKind ts a :: DKind ts a -> Type
[NDK] :: SDKind ts a x -> NDKind ts a (KNormalize ts a x)

-- | Substitute in a kind for all occurrences of a kind variable of sort
--   <tt>a</tt> indicated by the <a>Delete</a> within a kind of osrt
--   <tt>b</tt>.
type family KSub ts rs a b (del :: Delete ts rs a) (x :: DKind rs a) (r :: DKind ts b) :: DKind rs b

-- | Represents the possible types encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DTerm</a> '[r, s] '[k, j] a
--   </pre>
--   
--   Describes a type of kind <tt>a</tt> with possible:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   </ul>
--   
--   Something of type <tt><a>DType</a> '[] '[] a</tt> is a type of kind
--   <tt>a</tt> with no free variables.
--   
--   Note that the type of "kind-polymorphic values" (functions from kinds
--   to terms) is not yet supported.
--   
--   The kinds of the type variables should all be normalized. All
--   constructors that introduce type variables should normalize
--   automatically, but it's possible create nonsensical types with
--   <a>TVar</a>.
data DType ts :: [DKind ts 'Kind] -> DKind ts 'Kind -> Type
[TVar] :: Index us a -> DType ts us a
[TLam] :: NDKind ts  'Kind u -> DType ts (u : us) a -> DType ts us (u :~> a)
[TApp] :: DType ts us (a :~> b) -> DType ts us a -> DType ts us b
[TPoly] :: SingSing DSort t ( 'WS tt) -> DType (t : ts) (Map (KShiftSym ts (t : ts) t  'Kind  'InsZ) us) a -> DType ts us ( 'KPi tt a)
[TInst] :: DType ts us ( 'KPi tt b) -> SDKind ts t a -> DType ts us (KSub (t : ts) ts t  'Kind  'DelZ a b)
[:->] :: DType ts us  'Type -> DType ts us  'Type -> DType ts us  'Type
[Pi] :: NDKind ts  'Kind u -> DType ts (u : us) a -> DType ts us a
[Bool] :: DType ts us  'Type
[Natural] :: DType ts us  'Type
[List] :: DType ts us ( 'Type :~>  'Type)
[Optional] :: DType ts us ( 'Type :~>  'Type)
infixr 0 :->
infixl 9 `TApp`
data SomeType ts :: [DKind ts 'Kind] -> Type
[SomeType] :: NDKind ts  'Kind a -> DType ts us a -> SomeType ts us
type (:$) =  'TApp
infixl 9 :$
type a :-> b = a :-> b
infixr 0 :->

-- | Shift all type variables in a type expression of kind <tt>b</tt> to
--   account for a new bound variable of kind <tt>a</tt>, to be inserted at
--   the position indicated by the <a>Insert</a>.
type family Shift ts us qs a b (ins :: Insert us qs a) (x :: DType ts us b) :: DType ts qs b
toSomeType :: forall ts us a. (PolySingI a, KNormalize ts  'Kind a ~ a) => DType ts us a -> SomeType ts us

-- | Ideally we would want this to be encodable within the type. But the
--   main problem here is checking if the LHS of an application is a
--   variable or not. This is the next best thing?
type family TNormalize ts us a (x :: DType ts us a) :: DType ts us a

-- | Version of <a>SDType</a> that exposes itself in normal form.
data NDType ts us a :: DType ts us a -> Type
[NDT] :: SDType ts us a x -> NDType ts us a (TNormalize ts us a x)

-- | Substitute in a type for all occurrences of a type variable of kind
--   <tt>a</tt> indicated by the <a>Delete</a> within a type of kind
--   <tt>b</tt>.
type family Sub ts us qs a b (del :: Delete us qs a) (x :: DType ts qs a) (r :: DType ts us b) :: DType ts qs b
normalizeKindOf :: DType ts us a -> DType ts us (KNormalize ts  'Kind a)

-- | Primitives of Dhall terms, built into the language.
data Prim ts us :: [DType ts us 'Type] -> DType ts us 'Type -> Type
[BoolLit] :: Bool -> Prim ts us '[]  'Bool
[NaturalLit] :: Natural -> Prim ts us '[]  'Natural
[NaturalFold] :: Prim ts us '[] ( 'Natural :->  'Pi ( 'NDK  'SType) (( 'TVar  'IZ :->  'TVar  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)))
[NaturalBuild] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) (( 'TVar  'IZ :->  'TVar  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :->  'Natural)
[NaturalPlus] :: Prim ts us '[ 'Natural,  'Natural]  'Natural
[NaturalTimes] :: Prim ts us '[ 'Natural,  'Natural]  'Natural
[NaturalIsZero] :: Prim ts us '[] ( 'Natural :->  'Bool)
[ListFold] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) (( 'List :$  'TVar  'IZ) :->  'Pi ( 'NDK  'SType) (( 'TVar ( 'IS  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'TVar  'IZ :->  'TVar  'IZ))))
[ListBuild] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) ( 'Pi ( 'NDK  'SType) (( 'TVar ( 'IS  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'List :$  'TVar  'IZ)))
[ListAppend] :: SDType ts us  'Type a -> Prim ts us '[ 'List :$ a,  'List :$ a] ( 'List :$ a)
[ListHead] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) (( 'List :$  'TVar  'IZ) :-> ( 'Optional :$  'TVar  'IZ)))
[ListLast] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) (( 'List :$  'TVar  'IZ) :-> ( 'Optional :$  'TVar  'IZ)))
[ListReverse] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) (( 'List :$  'TVar  'IZ) :-> ( 'List :$  'TVar  'IZ)))
[Some] :: SDType ts us  'Type a -> Prim ts us '[a] ( 'Optional :$ a)
[None] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) ( 'Optional :$  'TVar  'IZ))

-- | Represents the possible terms encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DTerm</a> '[r, s] '[k, j] '[a, b, c] d
--   </pre>
--   
--   Describes a term of type <tt>d</tt> with possible:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   <li>Variables of type <tt>a</tt>, <tt>b</tt>, <tt>c</tt></li>
--   </ul>
--   
--   Something of type <tt><a>DTerm</a> '[] '[] '[] a</tt> is a term of
--   type <tt>a</tt> with no free variables.
--   
--   Note that "kind-polymorphic values" (functions from kinds to terms)
--   are not yet supported.
data DTerm ts (us :: [DKind ts 'Kind]) :: [DType ts us 'Type] -> DType ts us 'Type -> Type
[Var] :: Index vs a -> DTerm ts us vs a
[Lam] :: NDType ts us  'Type v -> DTerm ts us (v : vs) a -> DTerm ts us vs (v :-> a)
[App] :: DTerm ts us vs (a :-> b) -> DTerm ts us vs a -> DTerm ts us vs b
[Poly] :: SNDKind ts  'Kind u uu -> DTerm ts (u : us) (Map (ShiftSym ts us (u : us) u  'Type  'InsZ) vs) a -> DTerm ts us vs ( 'Pi uu a)
[Inst] :: SNDKind ts  'Kind u uu -> DTerm ts us vs ( 'Pi uu b) -> NDType ts us u a -> DTerm ts us vs (Sub ts (u : us) us u  'Type  'DelZ a b)
[P] :: Prim ts us as a -> Prod (DTerm ts us vs) as -> DTerm ts us vs a
[ListLit] :: NDType ts us  'Type a -> [DTerm ts us vs a] -> DTerm ts us vs ( 'List :$ a)
[OptionalLit] :: NDType ts us  'Type a -> Maybe (DTerm ts us vs a) -> DTerm ts us vs ( 'Optional :$ a)
data SomeTerm ts us :: [DType ts us 'Type] -> Type
[SomeTerm] :: NDType ts us  'Type a -> DTerm ts us vs a -> SomeTerm ts us vs
toSomeTerm :: forall ts us vs a. (PolySingI a, TNormalize ts us  'Type a ~ a) => DTerm ts us vs a -> SomeTerm ts us vs
normalizeTypeOf :: DTerm ts us vs a -> DTerm ts us vs (TNormalize ts us  'Type a)

-- | A <a>DExpr</a> fully covers all legal type-checking dhall terms. A
--   value of type
--   
--   <pre>
--   <a>DExpr</a> '[ r, s ] '[ k, j ] '[ a, b ] n
--   </pre>
--   
--   Represents a dhall expression on level <tt>n</tt> (<tt>'FZ</tt> =
--   term, <tt>'FS 'FZ</tt> = type, etc.) with potential:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   <li>Term variables of type <tt>a</tt>, <tt>b</tt></li>
--   </ul>
--   
--   A value of type <tt><a>DExpr</a> '[] '[] '[] n</tt> represents a typed
--   dhall expression with no free variables.
--   
--   You can pattern match on it to get a value of one of the "levels" of
--   the dhall type hierarchy, and also to get the "type" and
--   representation of it.
--   
--   The number of level goes up to 4 :
--   
--   <ul>
--   <li><tt>F0</tt>: term</li>
--   <li><tt>F1</tt>: type</li>
--   <li><tt>F2</tt>: kind</li>
--   <li><tt>F3</tt>: sort</li>
--   <li><tt>F4</tt>: order</li>
--   </ul>
--   
--   Note that you can restrict this to only <a>DExpr</a> past a given
--   "level" by asking for or returning a <tt><a>DExpr</a> ts us vs ('FS
--   n)</tt>, for instance. Such a value will only contain types, kinds,
--   sorts, or order A <tt><a>DExpr</a> ts us vs ('FS ('FS n))</tt> will
--   only contain kinds, sorts, or order, etc.
data DExpr ts us :: [DType ts us 'Type] -> Fin N5 -> Type
[DEOrder] :: DExpr ts us vs F4
[DESort] :: DSort -> DExpr ts us vs F3
[DEKind] :: SomeKind ts -> DExpr ts us vs F2
[DEType] :: SomeType ts us -> DExpr ts us vs F1
[DETerm] :: SomeTerm ts us vs -> DExpr ts us vs F0

-- | Hides the "level" of a <a>DExpr</a>. Pattern match to find it. Can be
--   useful when returning a <a>DExpr</a> of level unknown until runtime,
--   or storing <a>DExpr</a> of multiple levels in a container.
data SomeDExpr ts us :: [DType ts us 'Type] -> Type
[SomeDExpr] :: DExpr ts us vs l -> SomeDExpr ts us vs

-- | Get the meta-level "type" of a <a>DExpr</a>. If it's a term, this will
--   return its type. If it's a type, this returns its type, etc. It
--   essentially goes up one "level" of the Dhall type hierarchy.
--   
--   This will not typecheck if given a "Level 4" fin, so you cannot pass
--   in <a>DEOrder</a>.
dExprType :: DExpr ts us vs n -> DExpr ts us vs (ShiftFin N5 n)
deKind :: PolySingI a => DKind ts a -> DExpr ts us vs F2
deType :: (PolySingI a, KNormalize ts  'Kind a ~ a) => DType ts us a -> DExpr ts us vs F1
deTerm :: (PolySingI a, TNormalize ts us  'Type a ~ a) => DTerm ts us vs a -> DExpr ts us vs F0

-- | Meta-level type describing a collection or aggregation of types. Used
--   for specifying records and unions. data AggType k :: [Text] -&gt; [k]
--   -&gt; Type where
data AggType k (ls :: [Text]) (as :: [k])
[ATZ] :: AggType k '[] '[]
[ATS] :: SText l -> WrappedSing k (a :: k) -> AggType k ls as -> AggType k (l : ls) (a : as)
sortOf :: DKind '[] a -> SDSort a
kindOf :: DType ts '[] a -> SDKind ts  'Kind a
typeOf :: DTerm ts us '[] a -> SDType ts us  'Type a
sortOfWith :: Prod SDSort ts -> DKind ts a -> SDSort a
kindOfWith :: Prod (SDKind ts  'Kind) us -> DType ts us a -> SDKind ts  'Kind a
typeOfWith :: Prod (SDType ts us  'Type) vs -> DTerm ts us vs a -> SDType ts us  'Type a
data SDSort (x_a1BFA :: DSort)
[SKind] :: SDSort  'Kind
[:%*>] :: forall x_a1BFB x_a1BFC. () => SDSort x_a1BFB -> SDSort x_a1BFC -> SDSort ( '(:*>) x_a1BFB x_a1BFC)
[SKRecord] :: forall (ls_X1Byj :: [Text]) (as_X1Byl :: [()]) x_a1BFD. () => PolySing (AggType () ls_X1Byj as_X1Byl) x_a1BFD -> SDSort ( 'KRecord x_a1BFD)
[SKUnion] :: forall (ls_X1Byl :: [Text]) (as_X1Byn :: [()]) x_a1BFG. () => PolySing (AggType () ls_X1Byl as_X1Byn) x_a1BFG -> SDSort ( 'KUnion x_a1BFG)
data SDKind (a_a1BLr :: [DSort]) (b_a1BLs :: DSort) (x_a1BPl :: DKind (a_a1BLr :: [DSort]) (b_a1BLs :: DSort))
[SKVar] :: forall (ts_a1BGY :: [DSort]) (a_a1BGZ :: DSort) x_a1BPm. () => PolySing (Index ts_a1BGY a_a1BGZ) x_a1BPm -> SDKind ts_a1BGY a_a1BGZ ( 'KVar x_a1BPm)
[SKLam] :: forall (t_X1BH1 :: DSort) (ts_a1BH1 :: [DSort]) (a_X1BH4 :: DSort) x_a1BPr x_a1BPs. () => SingSing DSort t_X1BH1 ( 'WS x_a1BPr) -> SDKind ( '(:) t_X1BH1 ts_a1BH1) a_X1BH4 x_a1BPs -> SDKind ts_a1BH1 ( '(:*>) t_X1BH1 a_X1BH4) ( 'KLam x_a1BPr x_a1BPs)
[SKApp] :: forall (ts_a1BH3 :: [DSort]) (a_X1BH5 :: DSort) (b_a1BH5 :: DSort) x_a1BPC x_a1BPM. () => SDKind ts_a1BH3 ( '(:*>) a_X1BH5 b_a1BH5) x_a1BPC -> SDKind ts_a1BH3 a_X1BH5 x_a1BPM -> SDKind ts_a1BH3 b_a1BH5 ( 'KApp x_a1BPC x_a1BPM)
[:%~>] :: forall (ts_a1BH6 :: [DSort]) x_a1BPW x_a1BQ6. () => SDKind ts_a1BH6  'Kind x_a1BPW -> SDKind ts_a1BH6  'Kind x_a1BQ6 -> SDKind ts_a1BH6  'Kind ( '(:~>) x_a1BPW x_a1BQ6)
[SKPi] :: forall (t_X1BH8 :: DSort) (ts_a1BH8 :: [DSort]) (a_a1BH9 :: DSort) x_a1BQg x_a1BQh. () => SingSing DSort t_X1BH8 ( 'WS x_a1BQg) -> SDKind ( '(:) t_X1BH8 ts_a1BH8) a_a1BH9 x_a1BQh -> SDKind ts_a1BH8 a_a1BH9 ( 'KPi x_a1BQg x_a1BQh)
[SType] :: forall (ts_a1BHa :: [DSort]). () => SDKind ts_a1BHa  'Kind  'Type
data SNDKind (ts_a1BTw :: [DSort]) (a_a1BTx :: DSort) (b_a1C6Q :: DKind ts_a1BTw a_a1BTx) (x_a1Cbq :: NDKind (ts_a1BTw :: [DSort]) (a_a1BTx :: DSort) (b_a1C6Q :: DKind ts_a1BTw a_a1BTx))
[SNDK] :: forall (ts_a1BTy :: [DSort]) (a_a1BTz :: DSort) (x_X1BTB :: DKind ts_a1BTy a_a1BTz) x_a1Cbr. () => SingSing (DKind ts_a1BTy a_a1BTz) x_X1BTB ( 'WS x_a1Cbr) -> SNDKind ts_a1BTy a_a1BTz (KNormalize ts_a1BTy a_a1BTz x_X1BTB) ( 'NDK x_a1Cbr)
data SDType (ts_a1Ccf :: [DSort]) (a_a1Ckh :: [DKind ts_a1Ccf 'Kind]) (b_a1Cki :: DKind ts_a1Ccf 'Kind) (x_a1Cpj :: DType (ts_a1Ccf :: [DSort]) (a_a1Ckh :: [DKind ts_a1Ccf 'Kind]) (b_a1Cki :: DKind ts_a1Ccf 'Kind))
[STVar] :: forall (ts_a1Cci :: [DSort]) (us_a1Ccg :: [DKind ts_a1Cci  'Kind]) (a_a1Cch :: DKind ts_a1Cci  'Kind) x_a1Cpk. () => PolySing (Index us_a1Ccg a_a1Cch) x_a1Cpk -> SDType ts_a1Cci us_a1Ccg a_a1Cch ( 'TVar x_a1Cpk)
[STLam] :: forall (ts_a1Ccj :: [DSort]) (u_X1Ccl :: DKind ts_a1Ccj  'Kind) (us_a1Ccl :: [DKind ts_a1Ccj  'Kind]) (a_X1Cco :: DKind ts_a1Ccj  'Kind) x_a1Cpp x_a1Cps. () => PolySing (NDKind ts_a1Ccj  'Kind u_X1Ccl) x_a1Cpp -> SDType ts_a1Ccj ( '(:) u_X1Ccl us_a1Ccl) a_X1Cco x_a1Cps -> SDType ts_a1Ccj us_a1Ccl ( '(:~>) u_X1Ccl a_X1Cco) ( 'TLam x_a1Cpp x_a1Cps)
[STApp] :: forall (ts_a1Ccn :: [DSort]) (us_a1Cco :: [DKind ts_a1Ccn  'Kind]) (a_X1Ccq :: DKind ts_a1Ccn  'Kind) (b_a1Ccq :: DKind ts_a1Ccn  'Kind) x_a1CpS x_a1Cqi. () => SDType ts_a1Ccn us_a1Cco ( '(:~>) a_X1Ccq b_a1Ccq) x_a1CpS -> SDType ts_a1Ccn us_a1Cco a_X1Ccq x_a1Cqi -> SDType ts_a1Ccn us_a1Cco b_a1Ccq ( 'TApp x_a1CpS x_a1Cqi)
[STPoly] :: forall (t_X1Ccs :: DSort) (tt_X1Ccu :: SDSort t_X1Ccs) (ts_a1Cct :: [DSort]) (us_a1Ccu :: [DKind ts_a1Cct  'Kind]) (a_X1Ccy :: DKind ( '(:) t_X1Ccs ts_a1Cct)  'Kind) x_a1CqI x_a1CqM. () => SingSing (WrappedSing DSort t_X1Ccs) ( 'WS tt_X1Ccu) ( 'WS x_a1CqI) -> SDType ( '(:) t_X1Ccs ts_a1Cct) (Map (KShiftSym ts_a1Cct ( '(:) t_X1Ccs ts_a1Cct) t_X1Ccs  'Kind ( 'InsZ :: Insert ts_a1Cct ( '(:) t_X1Ccs ts_a1Cct) t_X1Ccs)) us_a1Ccu) a_X1Ccy x_a1CqM -> SDType ts_a1Cct us_a1Ccu ( 'KPi tt_X1Ccu a_X1Ccy) ( 'TPoly x_a1CqI x_a1CqM)
[STInst] :: forall (ts_a1Ccw :: [DSort]) (us_a1Ccx :: [DKind ts_a1Ccw  'Kind]) (t_X1CcB :: DSort) (tt_X1CcA :: SDSort t_X1CcB) (b_X1CcC :: DKind ( '(:) t_X1CcB ts_a1Ccw)  'Kind) (a_X1CcF :: DKind ts_a1Ccw t_X1CcB) x_a1CFt x_a1CFT. () => SDType ts_a1Ccw us_a1Ccx ( 'KPi tt_X1CcA b_X1CcC) x_a1CFt -> SingSing (DKind ts_a1Ccw t_X1CcB) a_X1CcF ( 'WS x_a1CFT) -> SDType ts_a1Ccw us_a1Ccx (KSub ( '(:) t_X1CcB ts_a1Ccw) ts_a1Ccw t_X1CcB  'Kind ( 'DelZ :: Delete ( '(:) t_X1CcB ts_a1Ccw) ts_a1Ccw t_X1CcB) a_X1CcF b_X1CcC) ( 'TInst x_a1CFt x_a1CFT)
[:%->] :: forall (ts_a1CcC :: [DSort]) (us_a1CcD :: [DKind ts_a1CcC  'Kind]) x_a1CG3 x_a1CHM. () => SDType ts_a1CcC us_a1CcD ( 'Type :: DKind ts_a1CcC  'Kind) x_a1CG3 -> SDType ts_a1CcC us_a1CcD ( 'Type :: DKind ts_a1CcC  'Kind) x_a1CHM -> SDType ts_a1CcC us_a1CcD ( 'Type :: DKind ts_a1CcC  'Kind) ( '(:->) x_a1CG3 x_a1CHM)
[SPi] :: forall (ts_a1CcE :: [DSort]) (u_X1CcG :: DKind ts_a1CcE  'Kind) (us_a1CcG :: [DKind ts_a1CcE  'Kind]) (a_a1CcH :: DKind ts_a1CcE  'Kind) x_a1CJv x_a1CJy. () => PolySing (NDKind ts_a1CcE  'Kind u_X1CcG) x_a1CJv -> SDType ts_a1CcE ( '(:) u_X1CcG us_a1CcG) a_a1CcH x_a1CJy -> SDType ts_a1CcE us_a1CcG a_a1CcH ( 'Pi x_a1CJv x_a1CJy)
[SBool] :: forall (ts_a1CcI :: [DSort]) (us_a1CcJ :: [DKind ts_a1CcI  'Kind]). () => SDType ts_a1CcI us_a1CcJ ( 'Type :: DKind ts_a1CcI  'Kind)  'Bool
[SNatural] :: forall (ts_a1CcK :: [DSort]) (us_a1CcL :: [DKind ts_a1CcK  'Kind]). () => SDType ts_a1CcK us_a1CcL ( 'Type :: DKind ts_a1CcK  'Kind)  'Natural
[SList] :: forall (ts_a1CcM :: [DSort]) (us_a1CcN :: [DKind ts_a1CcM  'Kind]). () => SDType ts_a1CcM us_a1CcN ((:~>) ( 'Type :: DKind ts_a1CcM  'Kind) ( 'Type :: DKind ts_a1CcM  'Kind))  'List
[SOptional] :: forall (ts_a1CcO :: [DSort]) (us_a1CcP :: [DKind ts_a1CcO  'Kind]). () => SDType ts_a1CcO us_a1CcP ((:~>) ( 'Type :: DKind ts_a1CcO  'Kind) ( 'Type :: DKind ts_a1CcO  'Kind))  'Optional
data SNDType (ts_a1CQX :: [DSort]) (us_a1CQY :: [DKind ts_a1CQX 'Kind]) (a_a1CQZ :: DKind ts_a1CQX 'Kind) (b_a1Det :: DType ts_a1CQX us_a1CQY a_a1CQZ) (x_a1Dl9 :: NDType (ts_a1CQX :: [DSort]) (us_a1CQY :: [DKind ts_a1CQX 'Kind]) (a_a1CQZ :: DKind ts_a1CQX 'Kind) (b_a1Det :: DType ts_a1CQX us_a1CQY a_a1CQZ))
[SNDT] :: forall (ts_a1CR0 :: [DSort]) (us_a1CR1 :: [DKind ts_a1CR0  'Kind]) (a_a1CR2 :: DKind ts_a1CR0  'Kind) (x_X1CR4 :: DType ts_a1CR0 us_a1CR1 a_a1CR2) x_a1Dla. () => SingSing (DType ts_a1CR0 us_a1CR1 a_a1CR2) x_X1CR4 ( 'WS x_a1Dla) -> SNDType ts_a1CR0 us_a1CR1 a_a1CR2 (TNormalize ts_a1CR0 us_a1CR1 a_a1CR2 x_X1CR4) ( 'NDT x_a1Dla)
data SPrim (ts_a1Dmi :: [DSort]) (us_a1Dmj :: [DKind ts_a1Dmi 'Kind]) (a_a1DGS :: [DType ts_a1Dmi us_a1Dmj ( 'Type :: DKind ts_a1Dmi 'Kind)]) (b_a1DGT :: DType ts_a1Dmi us_a1Dmj ( 'Type :: DKind ts_a1Dmi 'Kind)) (x_a1DLx :: Prim (ts_a1Dmi :: [DSort]) (us_a1Dmj :: [DKind ts_a1Dmi 'Kind]) (a_a1DGS :: [DType ts_a1Dmi us_a1Dmj ( 'Type :: DKind ts_a1Dmi 'Kind)]) (b_a1DGT :: DType ts_a1Dmi us_a1Dmj ( 'Type :: DKind ts_a1Dmi 'Kind)))
[SBoolLit] :: forall (ts_a1Dmk :: [DSort]) (us_a1Dml :: [DKind ts_a1Dmk  'Kind]) x_a1DLy. () => PolySing Bool x_a1DLy -> SPrim ts_a1Dmk us_a1Dml ('[] :: [DType ts_a1Dmk us_a1Dml ( 'Type :: DKind ts_a1Dmk  'Kind)]) ( 'Bool :: DType ts_a1Dmk us_a1Dml ( 'Type :: DKind ts_a1Dmk  'Kind)) ( 'BoolLit x_a1DLy)
[SNaturalLit] :: forall (ts_a1Dmm :: [DSort]) (us_a1Dmn :: [DKind ts_a1Dmm  'Kind]) x_a1DLz. () => PolySing Natural x_a1DLz -> SPrim ts_a1Dmm us_a1Dmn ('[] :: [DType ts_a1Dmm us_a1Dmn ( 'Type :: DKind ts_a1Dmm  'Kind)]) ( 'Natural :: DType ts_a1Dmm us_a1Dmn ( 'Type :: DKind ts_a1Dmm  'Kind)) ( 'NaturalLit x_a1DLz)
[SNaturalFold] :: forall (ts_a1Dmo :: [DSort]) (us_a1Dmp :: [DKind ts_a1Dmo  'Kind]). () => SPrim ts_a1Dmo us_a1Dmp ('[] :: [DType ts_a1Dmo us_a1Dmp ( 'Type :: DKind ts_a1Dmo  'Kind)]) ((:->) ( 'Natural :: DType ts_a1Dmo us_a1Dmp ( 'Type :: DKind ts_a1Dmo  'Kind)) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Dmo  'Kind ( 'Type :: DKind ts_a1Dmo  'Kind))) ((:->) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Dmo  'Kind) us_a1Dmp) ( 'Type :: DKind ts_a1Dmo  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Dmo  'Kind) us_a1Dmp) ( 'Type :: DKind ts_a1Dmo  'Kind)))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Dmo  'Kind) us_a1Dmp) ( 'Type :: DKind ts_a1Dmo  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Dmo  'Kind) us_a1Dmp) ( 'Type :: DKind ts_a1Dmo  'Kind)))))))  'NaturalFold
[SNaturalBuild] :: forall (ts_a1Dmq :: [DSort]) (us_a1Dmr :: [DKind ts_a1Dmq  'Kind]). () => SPrim ts_a1Dmq us_a1Dmr ('[] :: [DType ts_a1Dmq us_a1Dmr ( 'Type :: DKind ts_a1Dmq  'Kind)]) ((:->) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Dmq  'Kind ( 'Type :: DKind ts_a1Dmq  'Kind))) ((:->) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Dmq  'Kind) us_a1Dmr) ( 'Type :: DKind ts_a1Dmq  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Dmq  'Kind) us_a1Dmr) ( 'Type :: DKind ts_a1Dmq  'Kind)))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Dmq  'Kind) us_a1Dmr) ( 'Type :: DKind ts_a1Dmq  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Dmq  'Kind) us_a1Dmr) ( 'Type :: DKind ts_a1Dmq  'Kind)))))) ( 'Natural :: DType ts_a1Dmq us_a1Dmr ( 'Type :: DKind ts_a1Dmq  'Kind)))  'NaturalBuild
[SNaturalPlus] :: forall (ts_a1Dms :: [DSort]) (us_a1Dmt :: [DKind ts_a1Dms  'Kind]). () => SPrim ts_a1Dms us_a1Dmt ( '(:) ( 'Natural :: DType ts_a1Dms us_a1Dmt ( 'Type :: DKind ts_a1Dms  'Kind)) ( '(:) ( 'Natural :: DType ts_a1Dms us_a1Dmt ( 'Type :: DKind ts_a1Dms  'Kind)) ('[] :: [DType ts_a1Dms us_a1Dmt ( 'Type :: DKind ts_a1Dms  'Kind)]))) ( 'Natural :: DType ts_a1Dms us_a1Dmt ( 'Type :: DKind ts_a1Dms  'Kind))  'NaturalPlus
[SNaturalTimes] :: forall (ts_a1Dmu :: [DSort]) (us_a1Dmv :: [DKind ts_a1Dmu  'Kind]). () => SPrim ts_a1Dmu us_a1Dmv ( '(:) ( 'Natural :: DType ts_a1Dmu us_a1Dmv ( 'Type :: DKind ts_a1Dmu  'Kind)) ( '(:) ( 'Natural :: DType ts_a1Dmu us_a1Dmv ( 'Type :: DKind ts_a1Dmu  'Kind)) ('[] :: [DType ts_a1Dmu us_a1Dmv ( 'Type :: DKind ts_a1Dmu  'Kind)]))) ( 'Natural :: DType ts_a1Dmu us_a1Dmv ( 'Type :: DKind ts_a1Dmu  'Kind))  'NaturalTimes
[SNaturalIsZero] :: forall (ts_a1Dmw :: [DSort]) (us_a1Dmx :: [DKind ts_a1Dmw  'Kind]). () => SPrim ts_a1Dmw us_a1Dmx ('[] :: [DType ts_a1Dmw us_a1Dmx ( 'Type :: DKind ts_a1Dmw  'Kind)]) ((:->) ( 'Natural :: DType ts_a1Dmw us_a1Dmx ( 'Type :: DKind ts_a1Dmw  'Kind)) ( 'Bool :: DType ts_a1Dmw us_a1Dmx ( 'Type :: DKind ts_a1Dmw  'Kind)))  'NaturalIsZero
[SListFold] :: forall (ts_a1Dmy :: [DSort]) (us_a1Dmz :: [DKind ts_a1Dmy  'Kind]). () => SPrim ts_a1Dmy us_a1Dmz ('[] :: [DType ts_a1Dmy us_a1Dmz ( 'Type :: DKind ts_a1Dmy  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Dmy  'Kind ( 'Type :: DKind ts_a1Dmy  'Kind))) ((:->) ((:$) ( 'List :: DType ts_a1Dmy ( '(:) ( 'Type :: DKind ts_a1Dmy  'Kind) us_a1Dmz) ((:~>) ( 'Type :: DKind ts_a1Dmy  'Kind) ( 'Type :: DKind ts_a1Dmy  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Dmy  'Kind) us_a1Dmz) ( 'Type :: DKind ts_a1Dmy  'Kind)))) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Dmy  'Kind ( 'Type :: DKind ts_a1Dmy  'Kind))) ((:->) ((:->) ( 'TVar ( 'IS ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Dmy  'Kind) us_a1Dmz) ( 'Type :: DKind ts_a1Dmy  'Kind)) :: Index ( '(:) ( 'Type :: DKind ts_a1Dmy  'Kind) ( '(:) ( 'Type :: DKind ts_a1Dmy  'Kind) us_a1Dmz)) ( 'Type :: DKind ts_a1Dmy  'Kind))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Dmy  'Kind) ( '(:) ( 'Type :: DKind ts_a1Dmy  'Kind) us_a1Dmz)) ( 'Type :: DKind ts_a1Dmy  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Dmy  'Kind) ( '(:) ( 'Type :: DKind ts_a1Dmy  'Kind) us_a1Dmz)) ( 'Type :: DKind ts_a1Dmy  'Kind))))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Dmy  'Kind) ( '(:) ( 'Type :: DKind ts_a1Dmy  'Kind) us_a1Dmz)) ( 'Type :: DKind ts_a1Dmy  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Dmy  'Kind) ( '(:) ( 'Type :: DKind ts_a1Dmy  'Kind) us_a1Dmz)) ( 'Type :: DKind ts_a1Dmy  'Kind))))))))  'ListFold
[SListBuild] :: forall (ts_a1DmA :: [DSort]) (us_a1DmB :: [DKind ts_a1DmA  'Kind]). () => SPrim ts_a1DmA us_a1DmB ('[] :: [DType ts_a1DmA us_a1DmB ( 'Type :: DKind ts_a1DmA  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1DmA  'Kind ( 'Type :: DKind ts_a1DmA  'Kind))) ((:->) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1DmA  'Kind ( 'Type :: DKind ts_a1DmA  'Kind))) ((:->) ((:->) ( 'TVar ( 'IS ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1DmA  'Kind) us_a1DmB) ( 'Type :: DKind ts_a1DmA  'Kind)) :: Index ( '(:) ( 'Type :: DKind ts_a1DmA  'Kind) ( '(:) ( 'Type :: DKind ts_a1DmA  'Kind) us_a1DmB)) ( 'Type :: DKind ts_a1DmA  'Kind))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1DmA  'Kind) ( '(:) ( 'Type :: DKind ts_a1DmA  'Kind) us_a1DmB)) ( 'Type :: DKind ts_a1DmA  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1DmA  'Kind) ( '(:) ( 'Type :: DKind ts_a1DmA  'Kind) us_a1DmB)) ( 'Type :: DKind ts_a1DmA  'Kind))))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1DmA  'Kind) ( '(:) ( 'Type :: DKind ts_a1DmA  'Kind) us_a1DmB)) ( 'Type :: DKind ts_a1DmA  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1DmA  'Kind) ( '(:) ( 'Type :: DKind ts_a1DmA  'Kind) us_a1DmB)) ( 'Type :: DKind ts_a1DmA  'Kind)))))) ((:$) ( 'List :: DType ts_a1DmA ( '(:) ( 'Type :: DKind ts_a1DmA  'Kind) us_a1DmB) ((:~>) ( 'Type :: DKind ts_a1DmA  'Kind) ( 'Type :: DKind ts_a1DmA  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1DmA  'Kind) us_a1DmB) ( 'Type :: DKind ts_a1DmA  'Kind))))))  'ListBuild
[SListAppend] :: forall (ts_a1DmC :: [DSort]) (us_a1DmD :: [DKind ts_a1DmC  'Kind]) (a_X1DmF :: DType ts_a1DmC us_a1DmD ( 'Type :: DKind ts_a1DmC  'Kind)) x_a1DLB. () => SingSing (DType ts_a1DmC us_a1DmD ( 'Type :: DKind ts_a1DmC  'Kind)) a_X1DmF ( 'WS x_a1DLB) -> SPrim ts_a1DmC us_a1DmD ( '(:) ((:$) ( 'List :: DType ts_a1DmC us_a1DmD ((:~>) ( 'Type :: DKind ts_a1DmC  'Kind) ( 'Type :: DKind ts_a1DmC  'Kind))) a_X1DmF) ( '(:) ((:$) ( 'List :: DType ts_a1DmC us_a1DmD ((:~>) ( 'Type :: DKind ts_a1DmC  'Kind) ( 'Type :: DKind ts_a1DmC  'Kind))) a_X1DmF) ('[] :: [DType ts_a1DmC us_a1DmD ( 'Type :: DKind ts_a1DmC  'Kind)]))) ((:$) ( 'List :: DType ts_a1DmC us_a1DmD ((:~>) ( 'Type :: DKind ts_a1DmC  'Kind) ( 'Type :: DKind ts_a1DmC  'Kind))) a_X1DmF) ( 'ListAppend x_a1DLB)
[SListHead] :: forall (ts_a1DmF :: [DSort]) (us_a1DmG :: [DKind ts_a1DmF  'Kind]). () => SPrim ts_a1DmF us_a1DmG ('[] :: [DType ts_a1DmF us_a1DmG ( 'Type :: DKind ts_a1DmF  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1DmF  'Kind ( 'Type :: DKind ts_a1DmF  'Kind))) ((:->) ((:$) ( 'List :: DType ts_a1DmF ( '(:) ( 'Type :: DKind ts_a1DmF  'Kind) us_a1DmG) ((:~>) ( 'Type :: DKind ts_a1DmF  'Kind) ( 'Type :: DKind ts_a1DmF  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1DmF  'Kind) us_a1DmG) ( 'Type :: DKind ts_a1DmF  'Kind)))) ((:$) ( 'Optional :: DType ts_a1DmF ( '(:) ( 'Type :: DKind ts_a1DmF  'Kind) us_a1DmG) ((:~>) ( 'Type :: DKind ts_a1DmF  'Kind) ( 'Type :: DKind ts_a1DmF  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1DmF  'Kind) us_a1DmG) ( 'Type :: DKind ts_a1DmF  'Kind))))))  'ListHead
[SListLast] :: forall (ts_a1DmH :: [DSort]) (us_a1DmI :: [DKind ts_a1DmH  'Kind]). () => SPrim ts_a1DmH us_a1DmI ('[] :: [DType ts_a1DmH us_a1DmI ( 'Type :: DKind ts_a1DmH  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1DmH  'Kind ( 'Type :: DKind ts_a1DmH  'Kind))) ((:->) ((:$) ( 'List :: DType ts_a1DmH ( '(:) ( 'Type :: DKind ts_a1DmH  'Kind) us_a1DmI) ((:~>) ( 'Type :: DKind ts_a1DmH  'Kind) ( 'Type :: DKind ts_a1DmH  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1DmH  'Kind) us_a1DmI) ( 'Type :: DKind ts_a1DmH  'Kind)))) ((:$) ( 'Optional :: DType ts_a1DmH ( '(:) ( 'Type :: DKind ts_a1DmH  'Kind) us_a1DmI) ((:~>) ( 'Type :: DKind ts_a1DmH  'Kind) ( 'Type :: DKind ts_a1DmH  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1DmH  'Kind) us_a1DmI) ( 'Type :: DKind ts_a1DmH  'Kind))))))  'ListLast
[SListReverse] :: forall (ts_a1DmJ :: [DSort]) (us_a1DmK :: [DKind ts_a1DmJ  'Kind]). () => SPrim ts_a1DmJ us_a1DmK ('[] :: [DType ts_a1DmJ us_a1DmK ( 'Type :: DKind ts_a1DmJ  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1DmJ  'Kind ( 'Type :: DKind ts_a1DmJ  'Kind))) ((:->) ((:$) ( 'List :: DType ts_a1DmJ ( '(:) ( 'Type :: DKind ts_a1DmJ  'Kind) us_a1DmK) ((:~>) ( 'Type :: DKind ts_a1DmJ  'Kind) ( 'Type :: DKind ts_a1DmJ  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1DmJ  'Kind) us_a1DmK) ( 'Type :: DKind ts_a1DmJ  'Kind)))) ((:$) ( 'List :: DType ts_a1DmJ ( '(:) ( 'Type :: DKind ts_a1DmJ  'Kind) us_a1DmK) ((:~>) ( 'Type :: DKind ts_a1DmJ  'Kind) ( 'Type :: DKind ts_a1DmJ  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1DmJ  'Kind) us_a1DmK) ( 'Type :: DKind ts_a1DmJ  'Kind))))))  'ListReverse
[SSome] :: forall (ts_a1DmL :: [DSort]) (us_a1DmM :: [DKind ts_a1DmL  'Kind]) (a_X1DmO :: DType ts_a1DmL us_a1DmM ( 'Type :: DKind ts_a1DmL  'Kind)) x_a1DNk. () => SingSing (DType ts_a1DmL us_a1DmM ( 'Type :: DKind ts_a1DmL  'Kind)) a_X1DmO ( 'WS x_a1DNk) -> SPrim ts_a1DmL us_a1DmM ( '(:) a_X1DmO ('[] :: [DType ts_a1DmL us_a1DmM ( 'Type :: DKind ts_a1DmL  'Kind)])) ((:$) ( 'Optional :: DType ts_a1DmL us_a1DmM ((:~>) ( 'Type :: DKind ts_a1DmL  'Kind) ( 'Type :: DKind ts_a1DmL  'Kind))) a_X1DmO) ( 'Some x_a1DNk)
[SNone] :: forall (ts_a1DmO :: [DSort]) (us_a1DmP :: [DKind ts_a1DmO  'Kind]). () => SPrim ts_a1DmO us_a1DmP ('[] :: [DType ts_a1DmO us_a1DmP ( 'Type :: DKind ts_a1DmO  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1DmO  'Kind ( 'Type :: DKind ts_a1DmO  'Kind))) ((:$) ( 'Optional :: DType ts_a1DmO ( '(:) ( 'Type :: DKind ts_a1DmO  'Kind) us_a1DmP) ((:~>) ( 'Type :: DKind ts_a1DmO  'Kind) ( 'Type :: DKind ts_a1DmO  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1DmO  'Kind) us_a1DmP) ( 'Type :: DKind ts_a1DmO  'Kind)))))  'None
data SDTerm (ts_a1DVF :: [DSort]) (us_a1DVG :: [DKind ts_a1DVF 'Kind]) (a_a1Evt :: [DType ts_a1DVF us_a1DVG ( 'Type :: DKind ts_a1DVF 'Kind)]) (b_a1Evu :: DType ts_a1DVF us_a1DVG ( 'Type :: DKind ts_a1DVF 'Kind)) (x_a1EDs :: DTerm (ts_a1DVF :: [DSort]) (us_a1DVG :: [DKind ts_a1DVF 'Kind]) (a_a1Evt :: [DType ts_a1DVF us_a1DVG ( 'Type :: DKind ts_a1DVF 'Kind)]) (b_a1Evu :: DType ts_a1DVF us_a1DVG ( 'Type :: DKind ts_a1DVF 'Kind)))
[SVar] :: forall (ts_a1DVJ :: [DSort]) (us_a1DVK :: [DKind ts_a1DVJ  'Kind]) (vs_a1DVH :: [DType ts_a1DVJ us_a1DVK ( 'Type :: DKind ts_a1DVJ  'Kind)]) (a_a1DVI :: DType ts_a1DVJ us_a1DVK ( 'Type :: DKind ts_a1DVJ  'Kind)) x_a1EDt. () => PolySing (Index vs_a1DVH a_a1DVI) x_a1EDt -> SDTerm ts_a1DVJ us_a1DVK vs_a1DVH a_a1DVI ( 'Var x_a1EDt)
[SLam] :: forall (ts_a1DVL :: [DSort]) (us_a1DVM :: [DKind ts_a1DVL  'Kind]) (v_X1DVO :: DType ts_a1DVL us_a1DVM ( 'Type :: DKind ts_a1DVL  'Kind)) (vs_a1DVO :: [DType ts_a1DVL us_a1DVM ( 'Type :: DKind ts_a1DVL  'Kind)]) (a_X1DVR :: DType ts_a1DVL us_a1DVM ( 'Type :: DKind ts_a1DVL  'Kind)) x_a1EDy x_a1EEV. () => PolySing (NDType ts_a1DVL us_a1DVM ( 'Type :: DKind ts_a1DVL  'Kind) v_X1DVO) x_a1EDy -> SDTerm ts_a1DVL us_a1DVM ( '(:) v_X1DVO vs_a1DVO) a_X1DVR x_a1EEV -> SDTerm ts_a1DVL us_a1DVM vs_a1DVO ( '(:->) v_X1DVO a_X1DVR) ( 'Lam x_a1EDy x_a1EEV)
[SApp] :: forall (ts_a1DVQ :: [DSort]) (us_a1DVR :: [DKind ts_a1DVQ  'Kind]) (vs_a1DVS :: [DType ts_a1DVQ us_a1DVR ( 'Type :: DKind ts_a1DVQ  'Kind)]) (a_X1DVU :: DType ts_a1DVQ us_a1DVR ( 'Type :: DKind ts_a1DVQ  'Kind)) (b_a1DVU :: DType ts_a1DVQ us_a1DVR ( 'Type :: DKind ts_a1DVQ  'Kind)) x_a1EFn x_a1EFP. () => SDTerm ts_a1DVQ us_a1DVR vs_a1DVS ( '(:->) a_X1DVU b_a1DVU) x_a1EFn -> SDTerm ts_a1DVQ us_a1DVR vs_a1DVS a_X1DVU x_a1EFP -> SDTerm ts_a1DVQ us_a1DVR vs_a1DVS b_a1DVU ( 'App x_a1EFn x_a1EFP)
[SPoly] :: forall (ts_a1DVV :: [DSort]) (u_X1DVX :: DKind ts_a1DVV  'Kind) (uu_X1DVZ :: NDKind ts_a1DVV  'Kind u_X1DVX) (us_a1DVY :: [DKind ts_a1DVV  'Kind]) (vs_a1DVZ :: [DType ts_a1DVV us_a1DVY ( 'Type :: DKind ts_a1DVV  'Kind)]) (a_X1DW3 :: DType ts_a1DVV ( '(:) u_X1DVX us_a1DVY) ( 'Type :: DKind ts_a1DVV  'Kind)) x_a1EGh x_a1EGk. () => SingSing (NDKind ts_a1DVV  'Kind u_X1DVX) uu_X1DVZ ( 'WS x_a1EGh) -> SDTerm ts_a1DVV ( '(:) u_X1DVX us_a1DVY) (Map (ShiftSym ts_a1DVV us_a1DVY ( '(:) u_X1DVX us_a1DVY) u_X1DVX ( 'Type :: DKind ts_a1DVV  'Kind) ( 'InsZ :: Insert us_a1DVY ( '(:) u_X1DVX us_a1DVY) u_X1DVX)) vs_a1DVZ) a_X1DW3 x_a1EGk -> SDTerm ts_a1DVV us_a1DVY vs_a1DVZ ( 'Pi uu_X1DVZ a_X1DW3) ( 'Poly x_a1EGh x_a1EGk)
[SInst] :: forall (ts_a1DW1 :: [DSort]) (u_X1DW3 :: DKind ts_a1DW1  'Kind) (uu_X1DW5 :: NDKind ts_a1DW1  'Kind u_X1DW3) (us_a1DW4 :: [DKind ts_a1DW1  'Kind]) (vs_a1DW5 :: [DType ts_a1DW1 us_a1DW4 ( 'Type :: DKind ts_a1DW1  'Kind)]) (b_X1DW9 :: DType ts_a1DW1 ( '(:) u_X1DW3 us_a1DW4) ( 'Type :: DKind ts_a1DW1  'Kind)) (a_X1DWb :: DType ts_a1DW1 us_a1DW4 u_X1DW3) x_a1FjA x_a1FjD x_a1Fk5. () => SingSing (NDKind ts_a1DW1  'Kind u_X1DW3) uu_X1DW5 ( 'WS x_a1FjA) -> SDTerm ts_a1DW1 us_a1DW4 vs_a1DW5 ( 'Pi uu_X1DW5 b_X1DW9) x_a1FjD -> PolySing (NDType ts_a1DW1 us_a1DW4 u_X1DW3 a_X1DWb) x_a1Fk5 -> SDTerm ts_a1DW1 us_a1DW4 vs_a1DW5 (Sub ts_a1DW1 ( '(:) u_X1DW3 us_a1DW4) us_a1DW4 u_X1DW3 ( 'Type :: DKind ts_a1DW1  'Kind) ( 'DelZ :: Delete ( '(:) u_X1DW3 us_a1DW4) us_a1DW4 u_X1DW3) a_X1DWb b_X1DW9) ( 'Inst x_a1FjA x_a1FjD x_a1Fk5)
[SP] :: forall (ts_a1DW8 :: [DSort]) (us_a1DW9 :: [DKind ts_a1DW8  'Kind]) (as_X1DWb :: [DType ts_a1DW8 us_a1DW9 ( 'Type :: DKind ts_a1DW8  'Kind)]) (a_a1DWb :: DType ts_a1DW8 us_a1DW9 ( 'Type :: DKind ts_a1DW8  'Kind)) (vs_a1DWc :: [DType ts_a1DW8 us_a1DW9 ( 'Type :: DKind ts_a1DW8  'Kind)]) x_a1Fk9 x_a1FkE. () => PolySing (Prim ts_a1DW8 us_a1DW9 as_X1DWb a_a1DWb) x_a1Fk9 -> PolySing (Prod (DTerm ts_a1DW8 us_a1DW9 vs_a1DWc) as_X1DWb) x_a1FkE -> SDTerm ts_a1DW8 us_a1DW9 vs_a1DWc a_a1DWb ( 'P x_a1Fk9 x_a1FkE)
[SListLit] :: forall (ts_a1DWd :: [DSort]) (us_a1DWe :: [DKind ts_a1DWd  'Kind]) (a_X1DWg :: DType ts_a1DWd us_a1DWe ( 'Type :: DKind ts_a1DWd  'Kind)) (vs_a1DWg :: [DType ts_a1DWd us_a1DWe ( 'Type :: DKind ts_a1DWd  'Kind)]) x_a1FoE x_a1Fq1. () => PolySing (NDType ts_a1DWd us_a1DWe ( 'Type :: DKind ts_a1DWd  'Kind) a_X1DWg) x_a1FoE -> PolySing [DTerm ts_a1DWd us_a1DWe vs_a1DWg a_X1DWg] x_a1Fq1 -> SDTerm ts_a1DWd us_a1DWe vs_a1DWg ((:$) ( 'List :: DType ts_a1DWd us_a1DWe ((:~>) ( 'Type :: DKind ts_a1DWd  'Kind) ( 'Type :: DKind ts_a1DWd  'Kind))) a_X1DWg) ( 'ListLit x_a1FoE x_a1Fq1)
[SOptionalLit] :: forall (ts_a1DWh :: [DSort]) (us_a1DWi :: [DKind ts_a1DWh  'Kind]) (a_X1DWk :: DType ts_a1DWh us_a1DWi ( 'Type :: DKind ts_a1DWh  'Kind)) (vs_a1DWk :: [DType ts_a1DWh us_a1DWi ( 'Type :: DKind ts_a1DWh  'Kind)]) x_a1Fxt x_a1FyQ. () => PolySing (NDType ts_a1DWh us_a1DWi ( 'Type :: DKind ts_a1DWh  'Kind) a_X1DWk) x_a1Fxt -> PolySing (Maybe (DTerm ts_a1DWh us_a1DWi vs_a1DWk a_X1DWk)) x_a1FyQ -> SDTerm ts_a1DWh us_a1DWi vs_a1DWk ((:$) ( 'Optional :: DType ts_a1DWh us_a1DWi ((:~>) ( 'Type :: DKind ts_a1DWh  'Kind) ( 'Type :: DKind ts_a1DWh  'Kind))) a_X1DWk) ( 'OptionalLit x_a1Fxt x_a1FyQ)
data SAggType (k_a1Bsd :: Type) (ls_a1Bse :: [Text]) (as_a1Bsf :: [k_a1Bsd]) (x_a1Bxi :: AggType (k_a1Bsd :: Type) (ls_a1Bse :: [Text]) (as_a1Bsf :: [k_a1Bsd]))
[SATZ] :: forall (k_a1Bsg :: Type). () => SAggType k_a1Bsg ('[] :: [Text]) ('[] :: [k_a1Bsg])  'ATZ
[SATS] :: forall (k_a1Bsh :: Type) (l_X1Bsj :: Text) (a_X1Bsl :: k_a1Bsh) (ls_X1Bsn :: [Text]) (as_X1Bsp :: [k_a1Bsh]) x_a1Bxj x_a1Bxl x_a1Bxo. () => SingSing Text l_X1Bsj ( 'WS x_a1Bxj) -> PolySing (WrappedSing k_a1Bsh a_X1Bsl) x_a1Bxl -> SAggType k_a1Bsh ls_X1Bsn as_X1Bsp x_a1Bxo -> SAggType k_a1Bsh ( '(:) l_X1Bsj ls_X1Bsn) ( '(:) a_X1Bsl as_X1Bsp) ( 'ATS x_a1Bxj x_a1Bxl x_a1Bxo)
sShift :: SInsert us qs a ins -> SDType ts us b x -> SDType ts qs b (Shift ts us qs a b ins x)
sShift1 :: SDType ts us b x -> SDType ts (a : us) b (Shift ts us (a : us) a b  'InsZ x)
sSub :: SDelete us qs a del -> SDType ts qs a x -> SDType ts us b r -> SDType ts qs b (Sub ts us qs a b del x r)
sSub1 :: SDType ts us a x -> SDType ts (a : us) b r -> SDType ts us b (Sub ts (a : us) us a b  'DelZ x r)
skSub :: SDelete ts rs a del -> SDKind rs a x -> SDKind ts b r -> SDKind rs b (KSub ts rs a b del x r)
skSub1 :: SDKind ts a x -> SDKind (a : ts) b r -> SDKind ts b (KSub (a : ts) ts a b  'DelZ x r)
skNormalize :: SDKind ts a x -> SDKind ts a (KNormalize ts a x)
stNormalize :: SDType ts us a x -> SDType ts us a (TNormalize ts us a x)
data KShiftSym ts ps a b :: Insert ts ps a -> DKind ts b ~> DKind ps b
data ShiftSym ts us qs a b :: Insert us qs a -> DType ts us b ~> DType ts qs b
type family Map (f :: a ~> b) (xs :: [a]) :: [b]
data MapSym (f :: a ~> b) :: [a] ~> [b]

module Dhall.Typed
toTyped :: forall ts us vs. () => Context ts us vs -> Expr () X -> Either TypeMessage (SomeDExpr ts us vs)
fromTyped :: DExpr ts us vs n -> Expr () X
fromDTerm :: DTerm ts us vs a -> Expr () X
fromDType :: DType ts us a -> Expr () X
fromDKind :: DKind ts a -> Expr () X
fromDSort :: DSort -> Expr () X
