-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/dhall-typed#readme</a>
@package dhall-typed
@version 0.1.0.0

module Dhall.Typed.Type.N
data N
Z :: N
S :: N -> N

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
type SN = (Sing :: N -> Type)
fromNatural :: Natural -> N
toNatural :: N -> Natural
type ZSym0 = Z
data SSym0 :: (~>) N N
type SSym1 (t6989586621679134417 :: N) = S t6989586621679134417
data IsLength :: [k] -> N -> Type
[ILZ] :: IsLength '[]  'Z
[ILS] :: IsLength as n -> IsLength (a : as) ( 'S n)
data Fin :: N -> Type
[FZ] :: Fin ( 'S n)
[FS] :: Fin n -> Fin ( 'S n)
data SFin n :: Fin n -> Type
[SFZ] :: SFin ( 'S n)  'FZ
[SFS] :: SFin n x -> SFin ( 'S n) ( 'FS x)
type family ShiftFin n (i :: Fin n) :: Fin n
data LTE :: N -> N -> Type
[LTEZ] :: LTE  'Z m
[LTES] :: LTE n m -> LTE ( 'S n) ( 'S m)
type N0 =  'Z
type N1 =  'S N0
type N2 =  'S N1
type N3 =  'S N2
type N4 =  'S N3
type N5 =  'S N4
type F0 =  'FZ
type F1 =  'FS F0
type F2 =  'FS F1
type F3 =  'FS F2
type F4 =  'FS F3
type F5 =  'FS F4
sf0 :: SFin ( 'S n) F0
sf1 :: SFin ( 'S ( 'S n)) F1
sf2 :: SFin ( 'S ( 'S ( 'S n))) F2
sf3 :: SFin ( 'S ( 'S ( 'S ( 'S n)))) F3
sf4 :: SFin ( 'S ( 'S ( 'S ( 'S ( 'S n))))) F4
sf5 :: SFin ( 'S ( 'S ( 'S ( 'S ( 'S ( 'S n)))))) F5
instance GHC.Show.Show Dhall.Typed.Type.N.N
instance GHC.Classes.Ord Dhall.Typed.Type.N.N
instance GHC.Classes.Eq Dhall.Typed.Type.N.N
instance Data.Singletons.ShowSing.ShowSing Dhall.Typed.Type.N.N => GHC.Show.Show (Data.Singletons.Internal.Sing z)
instance Data.Singletons.Prelude.Eq.PEq Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.ShowsPrec_6989586621679139938Sym0
instance Data.Singletons.Prelude.Show.PShow Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.ShowsPrec_6989586621679139938Sym1 a6989586621679139935)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.ShowsPrec_6989586621679139938Sym2 a6989586621679139936 a6989586621679139935)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.Compare_6989586621679136394Sym0
instance Data.Singletons.Prelude.Ord.POrd Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.Compare_6989586621679136394Sym1 a6989586621679136392)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.SSym0
instance Data.Singletons.Internal.SingI Dhall.Typed.Type.N.SSym0
instance Data.Singletons.Internal.SingKind Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Ord.SOrd Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Ord.SOrd Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Show.SShow Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Show.SShow Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Eq.SEq Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Eq.SEq Dhall.Typed.Type.N.N
instance Data.Singletons.Decide.SDecide Dhall.Typed.Type.N.N => Data.Singletons.Decide.SDecide Dhall.Typed.Type.N.N
instance Data.Singletons.Internal.SingI 'Dhall.Typed.Type.N.Z
instance Data.Singletons.Internal.SingI n => Data.Singletons.Internal.SingI ('Dhall.Typed.Type.N.S n)
instance Data.Singletons.Internal.SingI (Data.Singletons.Internal.TyCon1 'Dhall.Typed.Type.N.S)

module Dhall.Typed.Plugin
plugin :: Plugin

module Dhall.Typed.Type.Option
data Option :: (k -> Type) -> Maybe k -> Type
[Noot] :: Option f  'Nothing
[Juus] :: f a -> Option f ( 'Just a)

module Dhall.Typed.Type.Singletons.TH
genPolySing :: DsMonad q => Name -> q [Dec]
genPolySingWith :: DsMonad q => GenPolySingOpts -> Name -> q [Dec]
data GenPolySingOpts
GPSO :: !Bool -> !Bool -> !GenOpts -> !GenOpts -> GenPolySingOpts
[gpsoSing] :: GenPolySingOpts -> !Bool
[gpsoSingI] :: GenPolySingOpts -> !Bool
[gpsoPSK] :: GenPolySingOpts -> !GenOpts
[gpsoSingEq] :: GenPolySingOpts -> !GenOpts
defaultGPSO :: GenPolySingOpts
data GenOpts
GOInfer :: GenOpts
GOSkip :: GenOpts
GOHead :: Q [Dec] -> GenOpts
genPolySingKind :: forall q. DsMonad q => q [Dec] -> q [Dec]
genSingEq :: forall q. DsMonad q => q [Dec] -> q [Dec]
instance GHC.Base.Functor Dhall.Typed.Type.Singletons.TH.V2
instance GHC.Base.Applicative Dhall.Typed.Type.Singletons.TH.V2
instance GHC.Base.Monad Dhall.Typed.Type.Singletons.TH.V2
instance Data.Default.Class.Default Dhall.Typed.Type.Singletons.TH.GenPolySingOpts

module Dhall.Typed.Type.Singletons
type family PolySing k = (s :: k -> Type) | s -> k
class PolySingI (x :: k)
polySing :: PolySingI x => PolySing k x
class PolySingKind k
fromPolySing :: PolySingKind k => PolySing k x -> k
toPolySing :: PolySingKind k => k -> SomePolySing k
data SomePolySing k
[SomePS] :: PolySing k x -> SomePolySing k
newtype WrappedSing k (x :: k)
WS :: PolySing k x -> WrappedSing k
[getWS] :: WrappedSing k -> PolySing k x
newtype SingSing k x :: WrappedSing k x -> Type
[SiSi] :: forall k x (ws :: WrappedSing k x). () => {getSiSi :: PolySing k x} -> SingSing k x ws
type PolySingOfI (x :: PolySing k y) = PolySingI y
class SingEq f g
singEq :: forall x y. SingEq f g => PolySing f x -> PolySing g y -> Decision (x :~~: y)
data SConst (a_awxB :: Type) (b_awxC :: k_awxA) (x_a1rBl :: Const (a_awxB :: Type) (b_awxC :: k_awxA))
[SConst] :: forall (a_awxB :: Type) (b_awxC :: k_awxA) x_a1rBm. () => {sGetConst :: PolySing a_awxB x_a1rBm} -> SConst (a_awxB :: Type) (b_awxC :: k_awxA) ( 'Const x_a1rBm)
data SMaybe (a_11 :: Type) (x_a1rHc :: Maybe (a_11 :: Type))
[SNothing] :: forall (a_11 :: Type). () => SMaybe (a_11 :: Type)  'Nothing
[SJust] :: forall (a_11 :: Type) x_a1rHd. () => PolySing a_11 x_a1rHd -> SMaybe (a_11 :: Type) ( 'Just x_a1rHd)
data SList k :: [k] -> Type
[:%] :: PolySing k x -> SList k xs -> SList k (x : xs)
[SNil] :: SList k '[]
infixr 5 :%
data STup2 a b :: (a, b) -> Type
[STup2] :: PolySing a x -> PolySing b y -> STup2 a b '(x, y)
data SBool :: Bool -> Type
[SFalse] :: SBool  'False
[STrue] :: SBool  'True
data SProxy (t_a1hQb :: k_a1hQa) (x_a1rLE :: Proxy (t_a1hQb :: k_a1hQa))
[SProxy] :: forall (t_a1hQb :: k_a1hQa). () => SProxy (t_a1hQb :: k_a1hQa)  'Proxy
data STup0 :: () -> Type
[STup0] :: STup0  '()
type family ToNat (n :: Natural) = (m :: Nat) | m -> n
type family FromNat (m :: Nat) = (n :: Natural) | n -> m
data SNatural :: Natural -> Type
[SNat] :: KnownNat (ToNat n) => SNatural n
withKnownNatural :: forall n r. KnownNat n => (KnownNat (ToNat (FromNat n)) => r) -> r
type family ToSym (t :: Text) = (s :: Symbol) | s -> t
type family FromSym (s :: Symbol) = (t :: Text) | t -> s
data SText :: Text -> Type
[SText] :: KnownSymbol (ToSym t) => SText t
withKnownText :: forall n r. KnownSymbol n => (KnownSymbol (ToSym (FromSym n)) => r) -> r
instance GHC.TypeLits.KnownSymbol (Dhall.Typed.Type.Singletons.ToSym t) => Dhall.Typed.Type.Singletons.Internal.PolySingI t
instance Dhall.Typed.Type.Singletons.Internal.PolySingKind Data.Text.Internal.Text
instance Dhall.Typed.Type.Singletons.Internal.SingEq Data.Text.Internal.Text Data.Text.Internal.Text
instance GHC.TypeNats.KnownNat (Dhall.Typed.Type.Singletons.ToNat n) => Dhall.Typed.Type.Singletons.Internal.PolySingI n
instance Dhall.Typed.Type.Singletons.Internal.PolySingKind GHC.Natural.Natural
instance Dhall.Typed.Type.Singletons.Internal.SingEq GHC.Natural.Natural GHC.Natural.Natural
instance forall k (t :: k). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Data.Proxy.Proxy
instance forall k (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Proxy.Proxy a)
instance forall k (a :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Proxy.Proxy a) (Data.Proxy.Proxy a)
instance Dhall.Typed.Type.Singletons.Internal.PolySingI 'GHC.Maybe.Nothing
instance forall a (x :: a). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('GHC.Maybe.Just x)
instance Dhall.Typed.Type.Singletons.Internal.PolySingKind a => Dhall.Typed.Type.Singletons.Internal.PolySingKind (GHC.Maybe.Maybe a)
instance Dhall.Typed.Type.Singletons.Internal.SingEq a a => Dhall.Typed.Type.Singletons.Internal.SingEq (GHC.Maybe.Maybe a) (GHC.Maybe.Maybe a)
instance forall k (b :: k) a (x :: a). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Data.Functor.Const.Const x)
instance forall k a (b :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind a => Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Functor.Const.Const a b)
instance forall k a b (c :: k). Dhall.Typed.Type.Singletons.Internal.SingEq a b => Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Functor.Const.Const a c) (Data.Functor.Const.Const b c)

module Dhall.Typed.Type.Index

-- | Witness an item in a type-level list by providing its index.
data Index (a :: [k]) (b :: k) :: forall k. () => [k] -> k -> Type
[IZ] :: forall k (a :: [k]) (b :: k) (as :: [k]). () => Index (b : as) b
[IS] :: forall k (a :: [k]) (b :: k) (bs :: [k]) (b1 :: k). () => Index bs b -> Index (b1 : bs) b
data SIndex (a_a1v1n :: [k_a1v1m]) (b_a1v1o :: k_a1v1m) (x_a1v1C :: Index (a_a1v1n :: [k_a1v1m]) (b_a1v1o :: k_a1v1m))
[SIZ] :: forall (k_a1v1m :: Type) (b_a1v1o :: k_a1v1m) (as_a1v1p :: [k_a1v1m]). () => SIndex ( '(:) b_a1v1o as_a1v1p) b_a1v1o  'IZ
[SIS] :: forall (k_a1v1m :: Type) (bs_a1v1s :: [k_a1v1m]) (b_a1v1o :: k_a1v1m) (b1_a1v1t :: k_a1v1m) x_a1v1D. () => SIndex bs_a1v1s b_a1v1o x_a1v1D -> SIndex ( '(:) b1_a1v1t bs_a1v1s) b_a1v1o ( 'IS x_a1v1D)
sSameIx :: SIndex as a i -> SIndex as a j -> Maybe (i :~: j)
fromSIndex :: SIndex as a i -> Index as a
data SSIndex (a_a1v1n :: [k_a1v1m]) (b_a1v1o :: k_a1v1m) (x_a1v1C :: Index a_a1v1n b_a1v1o) (x_a1v8v :: SIndex (a_a1v1n :: [k_a1v1m]) (b_a1v1o :: k_a1v1m) (x_a1v1C :: Index a_a1v1n b_a1v1o))
[SSIZ] :: forall (k_a1v1m :: Type) (b_a1v1o :: k_a1v1m) (as_X1v1q :: [k_a1v1m]). () => SSIndex ( '(:) b_a1v1o as_X1v1q) b_a1v1o ( 'IZ :: Index ( '(:) b_a1v1o as_X1v1q) b_a1v1o)  'SIZ
[SSIS] :: forall (k_a1v1m :: Type) (bs_X1v1t :: [k_a1v1m]) (b_a1v1o :: k_a1v1m) (b1_X1v1v :: k_a1v1m) (x_X1v1G :: Index bs_X1v1t b_a1v1o) x_a1v8w. () => SingSing (Index bs_X1v1t b_a1v1o) x_X1v1G ( 'WS x_a1v8w) -> SSIndex ( '(:) b1_X1v1v bs_X1v1t) b_a1v1o ( 'IS x_X1v1G :: Index ( '(:) b1_X1v1v bs_X1v1t) b_a1v1o) ( 'SIS x_a1v8w)
data Delete :: [k] -> [k] -> k -> Type
[DelZ] :: Delete (a : as) as a
[DelS] :: Delete as bs c -> Delete (a : as) (a : bs) c
del :: Delete as bs a -> Index as b -> Maybe (Index bs b)
type family ISMaybe (i :: Maybe (Index as a)) :: Maybe (Index (b : as) a)
type family Del as bs a b (d :: Delete as bs a) (i :: Index as b) :: Maybe (Index bs b)
data SDelete (a_a1vgJ :: [k_a1v9g]) (b_a1vgK :: [k_a1v9g]) (c_a1vgL :: k_a1v9g) (x_a1vms :: Delete (a_a1vgJ :: [k_a1v9g]) (b_a1vgK :: [k_a1v9g]) (c_a1vgL :: k_a1v9g))
[SDelZ] :: forall (k_a1vgj :: Type) (a_a1v9h :: k_a1vgj) (as_a1v9i :: [k_a1vgj]). () => SDelete ( '(:) a_a1v9h as_a1v9i) as_a1v9i a_a1v9h  'DelZ
[SDelS] :: forall (a_a1vgA :: Type) (as_X1v9k :: [a_a1vgA]) (bs_X1v9m :: [a_a1vgA]) (c_a1v9l :: a_a1vgA) (a_X1v9p :: a_a1vgA) x_a1vmt. () => SDelete as_X1v9k bs_X1v9m c_a1v9l x_a1vmt -> SDelete ( '(:) a_X1v9p as_X1v9k) ( '(:) a_X1v9p bs_X1v9m) c_a1v9l ( 'DelS x_a1vmt)
sDel :: SDelete as bs a del -> SIndex as b i -> GetDeleted as bs a b del i
data GetDeleted as bs a b :: Delete as bs a -> Index as b -> Type
[GotDeleted] :: Del as bs a b del i ~  'Nothing => (a :~: b) -> GetDeleted as bs a b del i
[ThatsToxic] :: Del as bs a b del i ~  'Just j => SIndex bs b j -> GetDeleted as bs a b del i

-- | This is just flipped delete, heh.
data Insert :: [k] -> [k] -> k -> Type
[InsZ] :: Insert as (a : as) a
[InsS] :: Insert as bs c -> Insert (a : as) (a : bs) c
insert :: Insert as bs a -> Index as b -> Index bs b
type family Ins as bs a b (ins :: Insert as bs a) (i :: Index as b) :: Index bs b
sIns :: forall as bs a b ins i. () => SInsert as bs a ins -> SIndex as b i -> SIndex bs b (Ins as bs a b ins i)
data SInsert (a_a1vzX :: [k_a1vn6]) (b_a1vzY :: [k_a1vn6]) (c_a1vzZ :: k_a1vn6) (x_a1vFv :: Insert (a_a1vzX :: [k_a1vn6]) (b_a1vzY :: [k_a1vn6]) (c_a1vzZ :: k_a1vn6))
[SInsZ] :: forall (a_a1vzy :: Type) (as_a1vn7 :: [a_a1vzy]) (a_a1vn8 :: a_a1vzy). () => SInsert as_a1vn7 ( '(:) a_a1vn8 as_a1vn7) a_a1vn8  'InsZ
[SInsS] :: forall (a_a1vzO :: Type) (as_X1vna :: [a_a1vzO]) (bs_X1vnc :: [a_a1vzO]) (c_a1vnb :: a_a1vzO) (a_X1vnf :: a_a1vzO) x_a1vFw. () => SInsert as_X1vna bs_X1vnc c_a1vnb x_a1vFw -> SInsert ( '(:) a_X1vnf as_X1vna) ( '(:) a_X1vnf bs_X1vnc) c_a1vnb ( 'InsS x_a1vFw)

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
instance forall a1 (as :: [a1]) (a2 :: a1). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Index.InsZ
instance forall a1 (a2 :: a1) (as :: [a1]) (bs :: [a1]) (c :: a1) (x :: Dhall.Typed.Type.Index.Insert as bs c). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Index.InsS x)
instance forall k (a :: [k]) (b :: [k]) (c :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Index.Insert a b c)
instance forall k (a1 :: [k]) (a2 :: [k]) (a3 :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Index.Insert a1 a2 a3) (Dhall.Typed.Type.Index.Insert a1 a2 b)
instance forall k (a :: k) (as :: [k]). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Index.DelZ
instance forall a1 (a2 :: a1) (as :: [a1]) (bs :: [a1]) (c :: a1) (x :: Dhall.Typed.Type.Index.Delete as bs c). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Index.DelS x)
instance forall k (a :: [k]) (b :: [k]) (c :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Index.Delete a b c)
instance forall k (a1 :: [k]) (a2 :: [k]) (a3 :: k) (b1 :: [k]) (b2 :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Index.Delete a1 a2 a3) (Dhall.Typed.Type.Index.Delete a1 b1 b2)
instance forall k (as :: [k]) (a :: k) (i :: Data.Type.Universe.Index as a). GHC.Show.Show (Dhall.Typed.Type.Index.SIndex as a i)
instance forall k (b :: k) (as :: [k]). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Index.SIZ
instance forall k (b1 :: k) (bs :: [k]) (b :: k) (y :: Data.Type.Universe.Index bs b) (x :: Dhall.Typed.Type.Index.SIndex bs b y). Dhall.Typed.Type.Singletons.Internal.PolySingOfI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Index.SIS x)
instance forall k (as :: [k]) (a :: k) (x :: Data.Type.Universe.Index as a). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Index.SIndex as a x)
instance forall k (as :: [k]) (a :: k) (x :: Data.Type.Universe.Index as a) (b :: k) (y :: Data.Type.Universe.Index as b). Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Index.SIndex as a x) (Dhall.Typed.Type.Index.SIndex as b y)
instance forall k (as :: [k]) (a :: k). Data.Singletons.Internal.SingKind (Data.Type.Universe.Index as a)
instance forall k (b :: k) (as :: [k]). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Data.Type.Universe.IZ
instance forall k (b1 :: k) (bs :: [k]) (b :: k) (x :: Data.Type.Universe.Index bs b). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Data.Type.Universe.IS x)
instance forall k (as :: [k]) (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Type.Universe.Index as a)
instance forall k (as :: [k]) (a :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Type.Universe.Index as a) (Data.Type.Universe.Index as b)

module Dhall.Typed.Type.Prod
data Prod :: (k -> Type) -> [k] -> Type
[Ø] :: Prod f '[]
[:<] :: f a -> Prod f as -> Prod f (a : as)
infixr 5 :<
traverseProd :: forall f g h as. Applicative h => (forall x. f x -> h (g x)) -> Prod f as -> h (Prod g as)
mapProd :: forall f g as. () => (forall x. f x -> g x) -> Prod f as -> Prod g as
zipProd :: Prod f as -> Prod g as -> Prod (f :*: g) as
singProd :: SList k as -> Prod (PolySing k) as
prodSing :: Prod (PolySing k) as -> SList k as
ixProd :: Prod f as -> Index as a -> f a
data SeqListEq :: Seq a -> [a] -> Type
[SeqListEq] :: SeqListEq xs ys
type family IxProd f as b (p :: Prod f as) (i :: Index as b) :: f b
data SProd (a_a1x2U :: k_a1x22 -> Type) (b_a1x2V :: [k_a1x22]) (x_a1x5L :: Prod (a_a1x2U :: k_a1x22 -> Type) (b_a1x2V :: [k_a1x22]))
[SØ] :: forall (k_a1x2t :: Type) (f_a1x23 :: k_a1x2t -> Type). () => SProd f_a1x23 ('[] :: [k_a1x2t])  'Ø
[:%<] :: forall (a_a1x2L :: Type) (f_a1x24 :: a_a1x2L -> Type) (a_X1x26 :: a_a1x2L) (as_X1x28 :: [a_a1x2L]) x_a1x5M x_a1x5N. () => PolySing (f_a1x24 a_X1x26) x_a1x5M -> SProd f_a1x24 as_X1x28 x_a1x5N -> SProd f_a1x24 ( '(:) a_X1x26 as_X1x28) ( '(:<) x_a1x5M x_a1x5N)
sIxProd :: SProd f as xs -> SIndex as a i -> PolySing (f a) (IxProd f as a xs i)
type family ProdList (xs :: Prod (Const k) ys) :: [k]
data BiProd :: (k -> Type) -> (j -> Type) -> [k] -> [j] -> Type
[BZ] :: BiProd f g '[] '[]
[BS] :: f a -> g b -> BiProd f g as bs -> BiProd f g (a : as) (b : bs)
data SBiProd (a_a1xcn :: k_a1x6C -> Type) (b_a1xco :: j_a1x6D -> Type) (c_a1xcp :: [k_a1x6C]) (d_a1xcq :: [j_a1x6D]) (x_a1xhS :: BiProd (a_a1xcn :: k_a1x6C -> Type) (b_a1xco :: j_a1x6D -> Type) (c_a1xcp :: [k_a1x6C]) (d_a1xcq :: [j_a1x6D]))
[SBZ] :: forall (k_a1xbL :: Type) (j_a1xbM :: Type) (f_a1x6E :: k_a1xbL -> Type) (g_a1x6F :: j_a1xbM -> Type). () => SBiProd f_a1x6E g_a1x6F ('[] :: [k_a1xbL]) ('[] :: [j_a1xbM])  'BZ
[SBS] :: forall (a_a1xcd :: Type) (a_a1xce :: Type) (f_a1x6G :: a_a1xcd -> Type) (a_X1x6I :: a_a1xcd) (g_a1x6I :: a_a1xce -> Type) (b_X1x6L :: a_a1xce) (as_X1x6N :: [a_a1xcd]) (bs_X1x6P :: [a_a1xce]) x_a1xhT x_a1xhU x_a1xhV. () => PolySing (f_a1x6G a_X1x6I) x_a1xhT -> PolySing (g_a1x6I b_X1x6L) x_a1xhU -> SBiProd f_a1x6G g_a1x6I as_X1x6N bs_X1x6P x_a1xhV -> SBiProd f_a1x6G g_a1x6I ( '(:) a_X1x6I as_X1x6N) ( '(:) b_X1x6L bs_X1x6P) ( 'BS x_a1xhT x_a1xhU x_a1xhV)
instance forall k (f :: k -> *) j (g :: j -> *). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Prod.BZ
instance forall a1 (as :: [a1]) a2 (bs :: [a2]) (g :: a2 -> *) (b :: a2) (f :: a1 -> *) (a3 :: a1) (x1 :: f a3) (x2 :: g b) (x3 :: Dhall.Typed.Type.Prod.BiProd f g as bs). (Dhall.Typed.Type.Singletons.Internal.PolySingI x1, Dhall.Typed.Type.Singletons.Internal.PolySingI x2, Dhall.Typed.Type.Singletons.Internal.PolySingI x3) => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Prod.BS x1 x2 x3)
instance forall j k (f :: k -> *) (g :: j -> *) (as :: [k]) (bs :: [j]). (forall (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (f a), forall (a :: j). Dhall.Typed.Type.Singletons.Internal.PolySingKind (g a)) => Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Prod.BiProd f g as bs)
instance forall j k (f :: k -> *) (g :: j -> *) (as :: [k]) (bs :: [j]) (cs :: [k]) (ds :: [j]). (forall (a :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (f a) (f b), forall (a :: j) (b :: j). Dhall.Typed.Type.Singletons.Internal.SingEq (g a) (g b)) => Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Prod.BiProd f g as bs) (Dhall.Typed.Type.Prod.BiProd f g cs ds)
instance forall k (f :: k -> *). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Prod.Ø
instance forall a1 (as :: [a1]) (f :: a1 -> *) (a2 :: a1) (x1 :: f a2) (x2 :: Dhall.Typed.Type.Prod.Prod f as). (Dhall.Typed.Type.Singletons.Internal.PolySingI x1, Dhall.Typed.Type.Singletons.Internal.PolySingI x2) => Dhall.Typed.Type.Singletons.Internal.PolySingI (x1 'Dhall.Typed.Type.Prod.:< x2)
instance forall k (f :: k -> *) (as :: [k]). (forall (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (f a)) => Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Prod.Prod f as)
instance forall k (f :: k -> *) (as :: [k]) (bs :: [k]). (forall (a :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (f a) (f b)) => Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Prod.Prod f as) (Dhall.Typed.Type.Prod.Prod f bs)


-- | Implementing a typed lambda calculus. Uses De Bruijn indices in
--   separate namespaces (that is, kind, type, term variables all have
--   their own separate De Bruijn indexing)
--   
--   We have a hierarchy: Term -&gt; Type -&gt; Kind -&gt; Sort. We can
--   stop at Sort because we don't allow any Sort variables, so there is no
--   need to talk about the "type" of any Sorts. Disallowing variables
--   effectively stops the chain.
--   
--   It looks like each level has some sets of constructors just from its
--   position on the chain.
--   
--   <ul>
--   <li>At all levels, we have <i>primitives</i>. Term-level primitives
--   are built-in functions and values and literals. Type-level primitives
--   are built-in types and type functions. Dhall has no kind- or
--   sort-level primitives.</li>
--   <li>If a level has variables (Terms, Types, Kinds), we gain some
--   constructors:<ul><li>Var, the variable constructor j Lam, the function
--   abstraction</li><li>App, the function application</li></ul></li>
--   <li>If a level has variables and its "type" also has variables (Terms,
--   Types), we gain some constructors:<ul><li>Poly, the type
--   abstraction</li><li>Inst (instantiation), the type
--   application</li></ul></li>
--   <li>If a level is the "type" of something (n &gt;= 1), we gain a
--   function type constructor, the type of function abstractions in the
--   immediately lower level.</li>
--   <li>If a level is the "type" of a "type" of something (n &gt;= 2), we
--   gain an "constant" constructor that links the two layers below it
--   together. Examples are the Kind sort that links Kinds to Types (all
--   types have kinds of sort Kind), and the Type kind that links types to
--   values (all terms have types of kind Type)</li>
--   <li>If a type is the "type" of something (n &gt;= 1), <i>and</i> it
--   has variables, we have a Pi type constructor, the type of type
--   abstractions (type-polymorphic values) in the lower level.</li>
--   </ul>
--   
--   We actually gain a Pi type for our current level, and each level above
--   our current level (that has variables). So for the Type level, we have
--   Type-Pi and Kind-Pi, and for the Kind level, we have Kind-Pi.
--   
--   So to summarize:
--   
--   <ul>
--   <li>n = 3: Sort has a constant (it is n &gt;= 2) and a function type
--   constructor (it is n &gt;= 1). It could also potentially have
--   primitives, but Dhall has no sort primitives.</li>
--   <li>n = 2: Kind has variables, so it has Var, Lam, and App. It has a
--   constant (they are n &gt;= 2) and a function type constructor and a Pi
--   constructor (it is n &gt;= 1 and has variables). It could also
--   potentially have primitives; Dhall has only record and union kinds as
--   primitives.</li>
--   <li>n = 1: Type has variables, so it has Var, Lam, and App. It has a
--   function type constructor and a Pi constructor (it is n &gt;= 1 and
--   has variables). Because its "type" has variables (Kind), it also has
--   Poly and Inst. It has primitives, and in Dhall ther are several.</li>
--   <li>n = 0: Term has variables, so it has Var, Lam, and App. Because
--   its "type" has variables, it has Poly and Inst. In Dhall, it has
--   multitudes of primitives.</li>
--   </ul>
module Dhall.Typed.LC
instance forall (ts :: [Dhall.Typed.LC.DSort]) (vs :: [Dhall.Typed.LC.DKind ts 'Dhall.Typed.LC.Kind]) (a :: Dhall.Typed.LC.DKind ts 'Dhall.Typed.LC.Kind). Data.Singletons.Internal.SingKind (Dhall.Typed.LC.DType ts vs a)
instance Data.Singletons.Internal.SingKind (Dhall.Typed.LC.DKind ts a)
instance Data.Singletons.Internal.SingKind Dhall.Typed.LC.DSort

module Dhall.Typed.Core

-- | Represents the possible sorts encountered in Dhall.
--   
--   Note that this implementation allows records of kinds with sorts other
--   than <a>Kind</a>, so <tt>{ foo : Kind -&gt; Kind }</tt> would
--   typecheck, even though normal Dhall forbids this.
data DSort :: Type
[Kind] :: DSort
[:*>] :: DSort -> DSort -> DSort
[KRecord] :: AggType () ls as -> DSort
[KUnion] :: AggType () ls as -> DSort

-- | Represents the possible types encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DKind</a> '[r, s] t
--   </pre>
--   
--   Describes a kind of sort <tt>t</tt> with possible kind variables of
--   sorts <tt>r</tt> and <tt>s</tt>.
--   
--   Something of type <tt><a>DKind</a> '[] t</tt> is a kind of sort
--   <tt>t</tt> with no free variables.
data DKind :: [DSort] -> DSort -> Type
[KVar] :: Index ts a -> DKind ts a
[KLam] :: SDSort t -> DKind (t : ts) a -> DKind ts (t :*> a)
[KApp] :: DKind ts (a :*> b) -> DKind ts a -> DKind ts b
[:~>] :: DKind ts  'Kind -> DKind ts  'Kind -> DKind ts  'Kind
[KPi] :: SDSort t -> DKind (t : ts) a -> DKind ts a
[Type] :: DKind ts  'Kind
infixr 1 :~>
data SomeKind :: [DSort] -> Type
[SomeKind] :: SDSort a -> DKind ts a -> SomeKind ts
type a :~> b = a :~> b
infixr 1 :~>

-- | Shift all kind variables in a kind expression of sort <tt>b</tt> to
--   account for a new bound variable of sort <tt>a</tt>, to be inserted at
--   the position indicated by the <a>Insert</a>.
type family KShift ts ps a b (ins :: Insert ts ps a) (x :: DKind ts b) :: DKind ps b
toSomeKind :: PolySingI a => DKind ts a -> SomeKind ts

-- | Represents the possible types encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DTerm</a> '[r, s] '[k, j] a
--   </pre>
--   
--   Describes a type of kind <tt>a</tt> with possible:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   </ul>
--   
--   Something of type <tt><a>DType</a> '[] '[] a</tt> is a type of kind
--   <tt>a</tt> with no free variables.
--   
--   Note that the type of "kind-polymorphic values" (functions from kinds
--   to terms) is not yet supported.
data DType ts :: [DKind ts 'Kind] -> DKind ts 'Kind -> Type
[TVar] :: Index us a -> DType ts us a
[TLam] :: SDKind ts  'Kind u -> DType ts (u : us) a -> DType ts us (u :~> a)
[TApp] :: DType ts us (a :~> b) -> DType ts us a -> DType ts us b
[TPoly] :: SingSing DSort t ( 'WS tt) -> DType (t : ts) (Map (KShiftSym ts (t : ts) t  'Kind  'InsZ) us) a -> DType ts us ( 'KPi tt a)
[TInst] :: DType ts us ( 'KPi tt b) -> SDKind ts t a -> DType ts us (KSub (t : ts) ts t  'Kind  'DelZ a b)
[:->] :: DType ts us  'Type -> DType ts us  'Type -> DType ts us  'Type
[Pi] :: SDKind ts  'Kind u -> DType ts (u : us) a -> DType ts us a
[Bool] :: DType ts us  'Type
[Natural] :: DType ts us  'Type
[List] :: DType ts us ( 'Type :~>  'Type)
[Optional] :: DType ts us ( 'Type :~>  'Type)
infixr 0 :->
infixl 9 `TApp`
data SomeType ts :: [DKind ts 'Kind] -> Type
[SomeType] :: SDKind ts  'Kind a -> DType ts us a -> SomeType ts us
type (:$) =  'TApp
infixl 9 :$
type a :-> b = a :-> b
infixr 0 :->

-- | Shift all type variables in a type expression of kind <tt>b</tt> to
--   account for a new bound variable of kind <tt>a</tt>, to be inserted at
--   the position indicated by the <a>Insert</a>.
type family Shift ts us qs a b (ins :: Insert us qs a) (x :: DType ts us b) :: DType ts qs b
toSomeType :: PolySingI a => DType ts vs a -> SomeType ts vs

-- | Primitives of Dhall terms, built into the language.
data Prim ts us :: [DType ts us 'Type] -> DType ts us 'Type -> Type
[BoolLit] :: Bool -> Prim ts us '[]  'Bool
[NaturalLit] :: Natural -> Prim ts us '[]  'Natural
[NaturalFold] :: Prim ts us '[] ( 'Natural :->  'Pi  'SType (( 'TVar  'IZ :->  'TVar  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)))
[NaturalBuild] :: Prim ts us '[] ( 'Pi  'SType (( 'TVar  'IZ :->  'TVar  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :->  'Natural)
[NaturalPlus] :: Prim ts us '[ 'Natural,  'Natural]  'Natural
[NaturalTimes] :: Prim ts us '[ 'Natural,  'Natural]  'Natural
[NaturalIsZero] :: Prim ts us '[] ( 'Natural :->  'Bool)
[ListFold] :: Prim ts us '[] ( 'Pi  'SType (( 'List :$  'TVar  'IZ) :->  'Pi  'SType (( 'TVar ( 'IS  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'TVar  'IZ :->  'TVar  'IZ))))
[ListBuild] :: Prim ts us '[] ( 'Pi  'SType ( 'Pi  'SType (( 'TVar ( 'IS  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'List :$  'TVar  'IZ)))
[ListAppend] :: SDType ts us  'Type a -> Prim ts us '[ 'List :$ a,  'List :$ a] ( 'List :$ a)
[ListHead] :: Prim ts us '[] ( 'Pi  'SType (( 'List :$  'TVar  'IZ) :-> ( 'Optional :$  'TVar  'IZ)))
[ListLast] :: Prim ts us '[] ( 'Pi  'SType (( 'List :$  'TVar  'IZ) :-> ( 'Optional :$  'TVar  'IZ)))
[ListReverse] :: Prim ts us '[] ( 'Pi  'SType (( 'List :$  'TVar  'IZ) :-> ( 'List :$  'TVar  'IZ)))
[Some] :: SDType ts us  'Type a -> Prim ts us '[a] ( 'Optional :$ a)
[None] :: Prim ts us '[] ( 'Pi  'SType ( 'Optional :$  'TVar  'IZ))

-- | Represents the possible terms encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DTerm</a> '[r, s] '[k, j] '[a, b, c] d
--   </pre>
--   
--   Describes a term of type <tt>d</tt> with possible:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   <li>Variables of type <tt>a</tt>, <tt>b</tt>, <tt>c</tt></li>
--   </ul>
--   
--   Something of type <tt><a>DTerm</a> '[] '[] '[] a</tt> is a term of
--   type <tt>a</tt> with no free variables.
--   
--   Note that "kind-polymorphic values" (functions from kinds to terms)
--   are not yet supported.
data DTerm ts (us :: [DKind ts 'Kind]) :: [DType ts us 'Type] -> DType ts us 'Type -> Type
[Var] :: Index vs a -> DTerm ts us vs a
[Lam] :: SDType ts us  'Type v -> DTerm ts us (v : vs) a -> DTerm ts us vs (v :-> a)
[App] :: DTerm ts us vs (a :-> b) -> DTerm ts us vs a -> DTerm ts us vs b
[Poly] :: SingSing (DKind ts  'Kind) u ( 'WS uu) -> DTerm ts (u : us) (Map (ShiftSym ts us (u : us) u  'Type  'InsZ) vs) a -> DTerm ts us vs ( 'Pi uu a)
[Inst] :: SingSing (DKind ts  'Kind) u ( 'WS uu) -> DTerm ts us vs ( 'Pi uu b) -> SDType ts us u a -> DTerm ts us vs (Sub ts (u : us) us u  'Type  'DelZ a b)
[P] :: Prim ts us as a -> Prod (DTerm ts us vs) as -> DTerm ts us vs a
[ListLit] :: SDType ts us  'Type a -> [DTerm ts us vs a] -> DTerm ts us vs ( 'List :$ a)
[OptionalLit] :: SDType ts us  'Type a -> Maybe (DTerm ts us vs a) -> DTerm ts us vs ( 'Optional :$ a)
data SomeTerm ts us :: [DType ts us 'Type] -> Type
[SomeTerm] :: SDType ts us  'Type a -> DTerm ts us vs a -> SomeTerm ts us vs
toSomeTerm :: PolySingI a => DTerm ts us vs a -> SomeTerm ts us vs

-- | A <a>DExpr</a> fully covers all legal type-checking dhall terms. A
--   value of type
--   
--   <pre>
--   <a>DExpr</a> '[ r, s ] '[ k, j ] '[ a, b ] n
--   </pre>
--   
--   Represents a dhall expression on level <tt>n</tt> (<tt>'FZ</tt> =
--   term, <tt>'FS 'FZ</tt> = type, etc.) with potential:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   <li>Term variables of type <tt>a</tt>, <tt>b</tt></li>
--   </ul>
--   
--   A value of type <tt><a>DExpr</a> '[] '[] '[] n</tt> represents a typed
--   dhall expression with no free variables.
--   
--   You can pattern match on it to get a value of one of the "levels" of
--   the dhall type hierarchy, and also to get the "type" and
--   representation of it.
--   
--   The number of level goes up to 4 :
--   
--   <ul>
--   <li><tt>F0</tt>: term</li>
--   <li><tt>F1</tt>: type</li>
--   <li><tt>F2</tt>: kind</li>
--   <li><tt>F3</tt>: sort</li>
--   <li><tt>F4</tt>: "meta" level, outside of the hierarchy. This is
--   necessary because the original untyped Dhall AST itself contains this
--   level.</li>
--   </ul>
--   
--   Note that you can restrict this to only <a>DExpr</a> past a given
--   "level" by asking for or returning a <tt><a>DExpr</a> ts us vs ('FS
--   n)</tt>, for instance. Such a value will only contain types, kinds,
--   sorts, or meta. A <tt><a>DExpr</a> ts us vs ('FS ('FS n))</tt> will
--   only contain kinds, sorts, or meta, etc.
data DExpr ts us :: [DType ts us 'Type] -> Fin N5 -> Type
[DEMeta] :: DExpr ts us vs F4
[DESort] :: DSort -> DExpr ts us vs F3
[DEKind] :: SomeKind ts -> DExpr ts us vs F2
[DEType] :: SomeType ts us -> DExpr ts us vs F1
[DETerm] :: SomeTerm ts us vs -> DExpr ts us vs F0

-- | Hides the "level" of a <a>DExpr</a>. Pattern match to find it. Can be
--   useful when returning a <a>DExpr</a> of level unknown until runtime,
--   or storing <a>DExpr</a> of multiple levels in a container.
data SomeDExpr ts us :: [DType ts us 'Type] -> Type
[SomeDExpr] :: DExpr ts us vs l -> SomeDExpr ts us vs

-- | Get the meta-level "type" of a <a>DExpr</a>. If it's a term, this will
--   return its type. If it's a type, this returns its type, etc. It
--   essentially goes up one "level" of the Dhall type hierarchy.
--   
--   This will not typecheck if given a "Level 4" fin, so you cannot pass
--   in <a>DEMeta</a>.
dExprType :: DExpr ts us vs n -> DExpr ts us vs (ShiftFin N5 n)
deKind :: PolySingI a => DKind ts a -> DExpr ts us vs F2
deType :: PolySingI a => DType ts us a -> DExpr ts us vs F1
deTerm :: PolySingI a => DTerm ts us vs a -> DExpr ts us vs F0

-- | Meta-level type describing a collection or aggregation of types. Used
--   for specifying records and unions. data AggType k :: [Text] -&gt; [k]
--   -&gt; Type where
data AggType k (ls :: [Text]) (as :: [k])
[ATZ] :: AggType k '[] '[]
[ATS] :: SText l -> WrappedSing k (a :: k) -> AggType k ls as -> AggType k (l : ls) (a : as)
sortOf :: DKind '[] a -> SDSort a
kindOf :: DType ts '[] a -> SDKind ts  'Kind a
typeOf :: DTerm ts us '[] a -> SDType ts us  'Type a
sortOfWith :: Prod SDSort ts -> DKind ts a -> SDSort a
kindOfWith :: Prod (SDKind ts  'Kind) us -> DType ts us a -> SDKind ts  'Kind a
typeOfWith :: Prod (SDType ts us  'Type) vs -> DTerm ts us vs a -> SDType ts us  'Type a
data SDSort (x_a1ANG :: DSort)
[SKind] :: SDSort  'Kind
[:%*>] :: forall x_a1ANH x_a1ANI. () => SDSort x_a1ANH -> SDSort x_a1ANI -> SDSort ( '(:*>) x_a1ANH x_a1ANI)
[SKRecord] :: forall (ls_X1AGp :: [Text]) (as_X1AGr :: [()]) x_a1ANJ. () => PolySing (AggType () ls_X1AGp as_X1AGr) x_a1ANJ -> SDSort ( 'KRecord x_a1ANJ)
[SKUnion] :: forall (ls_X1AGr :: [Text]) (as_X1AGt :: [()]) x_a1ANM. () => PolySing (AggType () ls_X1AGr as_X1AGt) x_a1ANM -> SDSort ( 'KUnion x_a1ANM)
data SDKind (a_a1ATF :: [DSort]) (b_a1ATG :: DSort) (x_a1AXP :: DKind (a_a1ATF :: [DSort]) (b_a1ATG :: DSort))
[SKVar] :: forall (ts_a1APc :: [DSort]) (a_a1APd :: DSort) x_a1AXQ. () => PolySing (Index ts_a1APc a_a1APd) x_a1AXQ -> SDKind ts_a1APc a_a1APd ( 'KVar x_a1AXQ)
[SKLam] :: forall (t_X1APf :: DSort) (ts_a1APf :: [DSort]) (a_X1APi :: DSort) x_a1AXV x_a1AXW. () => SingSing DSort t_X1APf ( 'WS x_a1AXV) -> SDKind ( '(:) t_X1APf ts_a1APf) a_X1APi x_a1AXW -> SDKind ts_a1APf ( '(:*>) t_X1APf a_X1APi) ( 'KLam x_a1AXV x_a1AXW)
[SKApp] :: forall (ts_a1APh :: [DSort]) (a_X1APj :: DSort) (b_a1APj :: DSort) x_a1AY6 x_a1AYg. () => SDKind ts_a1APh ( '(:*>) a_X1APj b_a1APj) x_a1AY6 -> SDKind ts_a1APh a_X1APj x_a1AYg -> SDKind ts_a1APh b_a1APj ( 'KApp x_a1AY6 x_a1AYg)
[:%~>] :: forall (ts_a1APk :: [DSort]) x_a1AYq x_a1AYA. () => SDKind ts_a1APk  'Kind x_a1AYq -> SDKind ts_a1APk  'Kind x_a1AYA -> SDKind ts_a1APk  'Kind ( '(:~>) x_a1AYq x_a1AYA)
[SKPi] :: forall (t_X1APm :: DSort) (ts_a1APm :: [DSort]) (a_a1APn :: DSort) x_a1AYK x_a1AYL. () => SingSing DSort t_X1APm ( 'WS x_a1AYK) -> SDKind ( '(:) t_X1APm ts_a1APm) a_a1APn x_a1AYL -> SDKind ts_a1APm a_a1APn ( 'KPi x_a1AYK x_a1AYL)
[SType] :: forall (ts_a1APo :: [DSort]). () => SDKind ts_a1APo  'Kind  'Type
data SDType (ts_a1B2c :: [DSort]) (a_a1Bfu :: [DKind ts_a1B2c 'Kind]) (b_a1Bfv :: DKind ts_a1B2c 'Kind) (x_a1Bmn :: DType (ts_a1B2c :: [DSort]) (a_a1Bfu :: [DKind ts_a1B2c 'Kind]) (b_a1Bfv :: DKind ts_a1B2c 'Kind))
[STVar] :: forall (ts_a1B2f :: [DSort]) (us_a1B2d :: [DKind ts_a1B2f  'Kind]) (a_a1B2e :: DKind ts_a1B2f  'Kind) x_a1Bmo. () => PolySing (Index us_a1B2d a_a1B2e) x_a1Bmo -> SDType ts_a1B2f us_a1B2d a_a1B2e ( 'TVar x_a1Bmo)
[STLam] :: forall (ts_a1B2g :: [DSort]) (u_X1B2i :: DKind ts_a1B2g  'Kind) (us_a1B2i :: [DKind ts_a1B2g  'Kind]) (a_X1B2l :: DKind ts_a1B2g  'Kind) x_a1Bmt x_a1BmD. () => SingSing (DKind ts_a1B2g  'Kind) u_X1B2i ( 'WS x_a1Bmt) -> SDType ts_a1B2g ( '(:) u_X1B2i us_a1B2i) a_X1B2l x_a1BmD -> SDType ts_a1B2g us_a1B2i ( '(:~>) u_X1B2i a_X1B2l) ( 'TLam x_a1Bmt x_a1BmD)
[STApp] :: forall (ts_a1B2k :: [DSort]) (us_a1B2l :: [DKind ts_a1B2k  'Kind]) (a_X1B2n :: DKind ts_a1B2k  'Kind) (b_a1B2n :: DKind ts_a1B2k  'Kind) x_a1Bn3 x_a1Bnt. () => SDType ts_a1B2k us_a1B2l ( '(:~>) a_X1B2n b_a1B2n) x_a1Bn3 -> SDType ts_a1B2k us_a1B2l a_X1B2n x_a1Bnt -> SDType ts_a1B2k us_a1B2l b_a1B2n ( 'TApp x_a1Bn3 x_a1Bnt)
[STPoly] :: forall (t_X1B2p :: DSort) (tt_X1B2r :: SDSort t_X1B2p) (ts_a1B2q :: [DSort]) (us_a1B2r :: [DKind ts_a1B2q  'Kind]) (a_X1B2v :: DKind ( '(:) t_X1B2p ts_a1B2q)  'Kind) x_a1BnT x_a1BnX. () => SingSing (WrappedSing DSort t_X1B2p) ( 'WS tt_X1B2r) ( 'WS x_a1BnT) -> SDType ( '(:) t_X1B2p ts_a1B2q) (Map (KShiftSym ts_a1B2q ( '(:) t_X1B2p ts_a1B2q) t_X1B2p  'Kind ( 'InsZ :: Insert ts_a1B2q ( '(:) t_X1B2p ts_a1B2q) t_X1B2p)) us_a1B2r) a_X1B2v x_a1BnX -> SDType ts_a1B2q us_a1B2r ( 'KPi tt_X1B2r a_X1B2v) ( 'TPoly x_a1BnT x_a1BnX)
[STInst] :: forall (ts_a1B2t :: [DSort]) (us_a1B2u :: [DKind ts_a1B2t  'Kind]) (t_X1B2y :: DSort) (tt_X1B2x :: SDSort t_X1B2y) (b_X1B2z :: DKind ( '(:) t_X1B2y ts_a1B2t)  'Kind) (a_X1B2C :: DKind ts_a1B2t t_X1B2y) x_a1BCE x_a1BD4. () => SDType ts_a1B2t us_a1B2u ( 'KPi tt_X1B2x b_X1B2z) x_a1BCE -> SingSing (DKind ts_a1B2t t_X1B2y) a_X1B2C ( 'WS x_a1BD4) -> SDType ts_a1B2t us_a1B2u (KSub ( '(:) t_X1B2y ts_a1B2t) ts_a1B2t t_X1B2y  'Kind ( 'DelZ :: Delete ( '(:) t_X1B2y ts_a1B2t) ts_a1B2t t_X1B2y) a_X1B2C b_X1B2z) ( 'TInst x_a1BCE x_a1BD4)
[:%->] :: forall (ts_a1B2z :: [DSort]) (us_a1B2A :: [DKind ts_a1B2z  'Kind]) x_a1BDe x_a1BEX. () => SDType ts_a1B2z us_a1B2A ( 'Type :: DKind ts_a1B2z  'Kind) x_a1BDe -> SDType ts_a1B2z us_a1B2A ( 'Type :: DKind ts_a1B2z  'Kind) x_a1BEX -> SDType ts_a1B2z us_a1B2A ( 'Type :: DKind ts_a1B2z  'Kind) ( '(:->) x_a1BDe x_a1BEX)
[SPi] :: forall (ts_a1B2B :: [DSort]) (u_X1B2D :: DKind ts_a1B2B  'Kind) (us_a1B2D :: [DKind ts_a1B2B  'Kind]) (a_a1B2E :: DKind ts_a1B2B  'Kind) x_a1BGG x_a1BGQ. () => SingSing (DKind ts_a1B2B  'Kind) u_X1B2D ( 'WS x_a1BGG) -> SDType ts_a1B2B ( '(:) u_X1B2D us_a1B2D) a_a1B2E x_a1BGQ -> SDType ts_a1B2B us_a1B2D a_a1B2E ( 'Pi x_a1BGG x_a1BGQ)
[SBool] :: forall (ts_a1B2F :: [DSort]) (us_a1B2G :: [DKind ts_a1B2F  'Kind]). () => SDType ts_a1B2F us_a1B2G ( 'Type :: DKind ts_a1B2F  'Kind)  'Bool
[SNatural] :: forall (ts_a1B2H :: [DSort]) (us_a1B2I :: [DKind ts_a1B2H  'Kind]). () => SDType ts_a1B2H us_a1B2I ( 'Type :: DKind ts_a1B2H  'Kind)  'Natural
[SList] :: forall (ts_a1B2J :: [DSort]) (us_a1B2K :: [DKind ts_a1B2J  'Kind]). () => SDType ts_a1B2J us_a1B2K ((:~>) ( 'Type :: DKind ts_a1B2J  'Kind) ( 'Type :: DKind ts_a1B2J  'Kind))  'List
[SOptional] :: forall (ts_a1B2L :: [DSort]) (us_a1B2M :: [DKind ts_a1B2L  'Kind]). () => SDType ts_a1B2L us_a1B2M ((:~>) ( 'Type :: DKind ts_a1B2L  'Kind) ( 'Type :: DKind ts_a1B2L  'Kind))  'Optional
data SPrim (ts_a1BOq :: [DSort]) (us_a1BOr :: [DKind ts_a1BOq 'Kind]) (a_a1Cll :: [DType ts_a1BOq us_a1BOr ( 'Type :: DKind ts_a1BOq 'Kind)]) (b_a1Clm :: DType ts_a1BOq us_a1BOr ( 'Type :: DKind ts_a1BOq 'Kind)) (x_a1CtP :: Prim (ts_a1BOq :: [DSort]) (us_a1BOr :: [DKind ts_a1BOq 'Kind]) (a_a1Cll :: [DType ts_a1BOq us_a1BOr ( 'Type :: DKind ts_a1BOq 'Kind)]) (b_a1Clm :: DType ts_a1BOq us_a1BOr ( 'Type :: DKind ts_a1BOq 'Kind)))
[SBoolLit] :: forall (ts_a1BOs :: [DSort]) (us_a1BOt :: [DKind ts_a1BOs  'Kind]) x_a1CtQ. () => PolySing Bool x_a1CtQ -> SPrim ts_a1BOs us_a1BOt ('[] :: [DType ts_a1BOs us_a1BOt ( 'Type :: DKind ts_a1BOs  'Kind)]) ( 'Bool :: DType ts_a1BOs us_a1BOt ( 'Type :: DKind ts_a1BOs  'Kind)) ( 'BoolLit x_a1CtQ)
[SNaturalLit] :: forall (ts_a1BOu :: [DSort]) (us_a1BOv :: [DKind ts_a1BOu  'Kind]) x_a1CtR. () => PolySing Natural x_a1CtR -> SPrim ts_a1BOu us_a1BOv ('[] :: [DType ts_a1BOu us_a1BOv ( 'Type :: DKind ts_a1BOu  'Kind)]) ( 'Natural :: DType ts_a1BOu us_a1BOv ( 'Type :: DKind ts_a1BOu  'Kind)) ( 'NaturalLit x_a1CtR)
[SNaturalFold] :: forall (ts_a1BOw :: [DSort]) (us_a1BOx :: [DKind ts_a1BOw  'Kind]). () => SPrim ts_a1BOw us_a1BOx ('[] :: [DType ts_a1BOw us_a1BOx ( 'Type :: DKind ts_a1BOw  'Kind)]) ((:->) ( 'Natural :: DType ts_a1BOw us_a1BOx ( 'Type :: DKind ts_a1BOw  'Kind)) ( 'Pi ( 'SType :: SDKind ts_a1BOw  'Kind ( 'Type :: DKind ts_a1BOw  'Kind)) ((:->) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOw  'Kind) us_a1BOx) ( 'Type :: DKind ts_a1BOw  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOw  'Kind) us_a1BOx) ( 'Type :: DKind ts_a1BOw  'Kind)))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOw  'Kind) us_a1BOx) ( 'Type :: DKind ts_a1BOw  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOw  'Kind) us_a1BOx) ( 'Type :: DKind ts_a1BOw  'Kind)))))))  'NaturalFold
[SNaturalBuild] :: forall (ts_a1BOy :: [DSort]) (us_a1BOz :: [DKind ts_a1BOy  'Kind]). () => SPrim ts_a1BOy us_a1BOz ('[] :: [DType ts_a1BOy us_a1BOz ( 'Type :: DKind ts_a1BOy  'Kind)]) ((:->) ( 'Pi ( 'SType :: SDKind ts_a1BOy  'Kind ( 'Type :: DKind ts_a1BOy  'Kind)) ((:->) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOy  'Kind) us_a1BOz) ( 'Type :: DKind ts_a1BOy  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOy  'Kind) us_a1BOz) ( 'Type :: DKind ts_a1BOy  'Kind)))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOy  'Kind) us_a1BOz) ( 'Type :: DKind ts_a1BOy  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOy  'Kind) us_a1BOz) ( 'Type :: DKind ts_a1BOy  'Kind)))))) ( 'Natural :: DType ts_a1BOy us_a1BOz ( 'Type :: DKind ts_a1BOy  'Kind)))  'NaturalBuild
[SNaturalPlus] :: forall (ts_a1BOA :: [DSort]) (us_a1BOB :: [DKind ts_a1BOA  'Kind]). () => SPrim ts_a1BOA us_a1BOB ( '(:) ( 'Natural :: DType ts_a1BOA us_a1BOB ( 'Type :: DKind ts_a1BOA  'Kind)) ( '(:) ( 'Natural :: DType ts_a1BOA us_a1BOB ( 'Type :: DKind ts_a1BOA  'Kind)) ('[] :: [DType ts_a1BOA us_a1BOB ( 'Type :: DKind ts_a1BOA  'Kind)]))) ( 'Natural :: DType ts_a1BOA us_a1BOB ( 'Type :: DKind ts_a1BOA  'Kind))  'NaturalPlus
[SNaturalTimes] :: forall (ts_a1BOC :: [DSort]) (us_a1BOD :: [DKind ts_a1BOC  'Kind]). () => SPrim ts_a1BOC us_a1BOD ( '(:) ( 'Natural :: DType ts_a1BOC us_a1BOD ( 'Type :: DKind ts_a1BOC  'Kind)) ( '(:) ( 'Natural :: DType ts_a1BOC us_a1BOD ( 'Type :: DKind ts_a1BOC  'Kind)) ('[] :: [DType ts_a1BOC us_a1BOD ( 'Type :: DKind ts_a1BOC  'Kind)]))) ( 'Natural :: DType ts_a1BOC us_a1BOD ( 'Type :: DKind ts_a1BOC  'Kind))  'NaturalTimes
[SNaturalIsZero] :: forall (ts_a1BOE :: [DSort]) (us_a1BOF :: [DKind ts_a1BOE  'Kind]). () => SPrim ts_a1BOE us_a1BOF ('[] :: [DType ts_a1BOE us_a1BOF ( 'Type :: DKind ts_a1BOE  'Kind)]) ((:->) ( 'Natural :: DType ts_a1BOE us_a1BOF ( 'Type :: DKind ts_a1BOE  'Kind)) ( 'Bool :: DType ts_a1BOE us_a1BOF ( 'Type :: DKind ts_a1BOE  'Kind)))  'NaturalIsZero
[SListFold] :: forall (ts_a1BOG :: [DSort]) (us_a1BOH :: [DKind ts_a1BOG  'Kind]). () => SPrim ts_a1BOG us_a1BOH ('[] :: [DType ts_a1BOG us_a1BOH ( 'Type :: DKind ts_a1BOG  'Kind)]) ( 'Pi ( 'SType :: SDKind ts_a1BOG  'Kind ( 'Type :: DKind ts_a1BOG  'Kind)) ((:->) ((:$) ( 'List :: DType ts_a1BOG ( '(:) ( 'Type :: DKind ts_a1BOG  'Kind) us_a1BOH) ((:~>) ( 'Type :: DKind ts_a1BOG  'Kind) ( 'Type :: DKind ts_a1BOG  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOG  'Kind) us_a1BOH) ( 'Type :: DKind ts_a1BOG  'Kind)))) ( 'Pi ( 'SType :: SDKind ts_a1BOG  'Kind ( 'Type :: DKind ts_a1BOG  'Kind)) ((:->) ((:->) ( 'TVar ( 'IS ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOG  'Kind) us_a1BOH) ( 'Type :: DKind ts_a1BOG  'Kind)) :: Index ( '(:) ( 'Type :: DKind ts_a1BOG  'Kind) ( '(:) ( 'Type :: DKind ts_a1BOG  'Kind) us_a1BOH)) ( 'Type :: DKind ts_a1BOG  'Kind))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOG  'Kind) ( '(:) ( 'Type :: DKind ts_a1BOG  'Kind) us_a1BOH)) ( 'Type :: DKind ts_a1BOG  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOG  'Kind) ( '(:) ( 'Type :: DKind ts_a1BOG  'Kind) us_a1BOH)) ( 'Type :: DKind ts_a1BOG  'Kind))))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOG  'Kind) ( '(:) ( 'Type :: DKind ts_a1BOG  'Kind) us_a1BOH)) ( 'Type :: DKind ts_a1BOG  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOG  'Kind) ( '(:) ( 'Type :: DKind ts_a1BOG  'Kind) us_a1BOH)) ( 'Type :: DKind ts_a1BOG  'Kind))))))))  'ListFold
[SListBuild] :: forall (ts_a1BOI :: [DSort]) (us_a1BOJ :: [DKind ts_a1BOI  'Kind]). () => SPrim ts_a1BOI us_a1BOJ ('[] :: [DType ts_a1BOI us_a1BOJ ( 'Type :: DKind ts_a1BOI  'Kind)]) ( 'Pi ( 'SType :: SDKind ts_a1BOI  'Kind ( 'Type :: DKind ts_a1BOI  'Kind)) ((:->) ( 'Pi ( 'SType :: SDKind ts_a1BOI  'Kind ( 'Type :: DKind ts_a1BOI  'Kind)) ((:->) ((:->) ( 'TVar ( 'IS ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOI  'Kind) us_a1BOJ) ( 'Type :: DKind ts_a1BOI  'Kind)) :: Index ( '(:) ( 'Type :: DKind ts_a1BOI  'Kind) ( '(:) ( 'Type :: DKind ts_a1BOI  'Kind) us_a1BOJ)) ( 'Type :: DKind ts_a1BOI  'Kind))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOI  'Kind) ( '(:) ( 'Type :: DKind ts_a1BOI  'Kind) us_a1BOJ)) ( 'Type :: DKind ts_a1BOI  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOI  'Kind) ( '(:) ( 'Type :: DKind ts_a1BOI  'Kind) us_a1BOJ)) ( 'Type :: DKind ts_a1BOI  'Kind))))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOI  'Kind) ( '(:) ( 'Type :: DKind ts_a1BOI  'Kind) us_a1BOJ)) ( 'Type :: DKind ts_a1BOI  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOI  'Kind) ( '(:) ( 'Type :: DKind ts_a1BOI  'Kind) us_a1BOJ)) ( 'Type :: DKind ts_a1BOI  'Kind)))))) ((:$) ( 'List :: DType ts_a1BOI ( '(:) ( 'Type :: DKind ts_a1BOI  'Kind) us_a1BOJ) ((:~>) ( 'Type :: DKind ts_a1BOI  'Kind) ( 'Type :: DKind ts_a1BOI  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOI  'Kind) us_a1BOJ) ( 'Type :: DKind ts_a1BOI  'Kind))))))  'ListBuild
[SListAppend] :: forall (ts_a1BOK :: [DSort]) (us_a1BOL :: [DKind ts_a1BOK  'Kind]) (a_X1BON :: DType ts_a1BOK us_a1BOL ( 'Type :: DKind ts_a1BOK  'Kind)) x_a1CtT. () => SingSing (DType ts_a1BOK us_a1BOL ( 'Type :: DKind ts_a1BOK  'Kind)) a_X1BON ( 'WS x_a1CtT) -> SPrim ts_a1BOK us_a1BOL ( '(:) ((:$) ( 'List :: DType ts_a1BOK us_a1BOL ((:~>) ( 'Type :: DKind ts_a1BOK  'Kind) ( 'Type :: DKind ts_a1BOK  'Kind))) a_X1BON) ( '(:) ((:$) ( 'List :: DType ts_a1BOK us_a1BOL ((:~>) ( 'Type :: DKind ts_a1BOK  'Kind) ( 'Type :: DKind ts_a1BOK  'Kind))) a_X1BON) ('[] :: [DType ts_a1BOK us_a1BOL ( 'Type :: DKind ts_a1BOK  'Kind)]))) ((:$) ( 'List :: DType ts_a1BOK us_a1BOL ((:~>) ( 'Type :: DKind ts_a1BOK  'Kind) ( 'Type :: DKind ts_a1BOK  'Kind))) a_X1BON) ( 'ListAppend x_a1CtT)
[SListHead] :: forall (ts_a1BON :: [DSort]) (us_a1BOO :: [DKind ts_a1BON  'Kind]). () => SPrim ts_a1BON us_a1BOO ('[] :: [DType ts_a1BON us_a1BOO ( 'Type :: DKind ts_a1BON  'Kind)]) ( 'Pi ( 'SType :: SDKind ts_a1BON  'Kind ( 'Type :: DKind ts_a1BON  'Kind)) ((:->) ((:$) ( 'List :: DType ts_a1BON ( '(:) ( 'Type :: DKind ts_a1BON  'Kind) us_a1BOO) ((:~>) ( 'Type :: DKind ts_a1BON  'Kind) ( 'Type :: DKind ts_a1BON  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BON  'Kind) us_a1BOO) ( 'Type :: DKind ts_a1BON  'Kind)))) ((:$) ( 'Optional :: DType ts_a1BON ( '(:) ( 'Type :: DKind ts_a1BON  'Kind) us_a1BOO) ((:~>) ( 'Type :: DKind ts_a1BON  'Kind) ( 'Type :: DKind ts_a1BON  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BON  'Kind) us_a1BOO) ( 'Type :: DKind ts_a1BON  'Kind))))))  'ListHead
[SListLast] :: forall (ts_a1BOP :: [DSort]) (us_a1BOQ :: [DKind ts_a1BOP  'Kind]). () => SPrim ts_a1BOP us_a1BOQ ('[] :: [DType ts_a1BOP us_a1BOQ ( 'Type :: DKind ts_a1BOP  'Kind)]) ( 'Pi ( 'SType :: SDKind ts_a1BOP  'Kind ( 'Type :: DKind ts_a1BOP  'Kind)) ((:->) ((:$) ( 'List :: DType ts_a1BOP ( '(:) ( 'Type :: DKind ts_a1BOP  'Kind) us_a1BOQ) ((:~>) ( 'Type :: DKind ts_a1BOP  'Kind) ( 'Type :: DKind ts_a1BOP  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOP  'Kind) us_a1BOQ) ( 'Type :: DKind ts_a1BOP  'Kind)))) ((:$) ( 'Optional :: DType ts_a1BOP ( '(:) ( 'Type :: DKind ts_a1BOP  'Kind) us_a1BOQ) ((:~>) ( 'Type :: DKind ts_a1BOP  'Kind) ( 'Type :: DKind ts_a1BOP  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOP  'Kind) us_a1BOQ) ( 'Type :: DKind ts_a1BOP  'Kind))))))  'ListLast
[SListReverse] :: forall (ts_a1BOR :: [DSort]) (us_a1BOS :: [DKind ts_a1BOR  'Kind]). () => SPrim ts_a1BOR us_a1BOS ('[] :: [DType ts_a1BOR us_a1BOS ( 'Type :: DKind ts_a1BOR  'Kind)]) ( 'Pi ( 'SType :: SDKind ts_a1BOR  'Kind ( 'Type :: DKind ts_a1BOR  'Kind)) ((:->) ((:$) ( 'List :: DType ts_a1BOR ( '(:) ( 'Type :: DKind ts_a1BOR  'Kind) us_a1BOS) ((:~>) ( 'Type :: DKind ts_a1BOR  'Kind) ( 'Type :: DKind ts_a1BOR  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOR  'Kind) us_a1BOS) ( 'Type :: DKind ts_a1BOR  'Kind)))) ((:$) ( 'List :: DType ts_a1BOR ( '(:) ( 'Type :: DKind ts_a1BOR  'Kind) us_a1BOS) ((:~>) ( 'Type :: DKind ts_a1BOR  'Kind) ( 'Type :: DKind ts_a1BOR  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOR  'Kind) us_a1BOS) ( 'Type :: DKind ts_a1BOR  'Kind))))))  'ListReverse
[SSome] :: forall (ts_a1BOT :: [DSort]) (us_a1BOU :: [DKind ts_a1BOT  'Kind]) (a_X1BOW :: DType ts_a1BOT us_a1BOU ( 'Type :: DKind ts_a1BOT  'Kind)) x_a1CvC. () => SingSing (DType ts_a1BOT us_a1BOU ( 'Type :: DKind ts_a1BOT  'Kind)) a_X1BOW ( 'WS x_a1CvC) -> SPrim ts_a1BOT us_a1BOU ( '(:) a_X1BOW ('[] :: [DType ts_a1BOT us_a1BOU ( 'Type :: DKind ts_a1BOT  'Kind)])) ((:$) ( 'Optional :: DType ts_a1BOT us_a1BOU ((:~>) ( 'Type :: DKind ts_a1BOT  'Kind) ( 'Type :: DKind ts_a1BOT  'Kind))) a_X1BOW) ( 'Some x_a1CvC)
[SNone] :: forall (ts_a1BOW :: [DSort]) (us_a1BOX :: [DKind ts_a1BOW  'Kind]). () => SPrim ts_a1BOW us_a1BOX ('[] :: [DType ts_a1BOW us_a1BOX ( 'Type :: DKind ts_a1BOW  'Kind)]) ( 'Pi ( 'SType :: SDKind ts_a1BOW  'Kind ( 'Type :: DKind ts_a1BOW  'Kind)) ((:$) ( 'Optional :: DType ts_a1BOW ( '(:) ( 'Type :: DKind ts_a1BOW  'Kind) us_a1BOX) ((:~>) ( 'Type :: DKind ts_a1BOW  'Kind) ( 'Type :: DKind ts_a1BOW  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1BOW  'Kind) us_a1BOX) ( 'Type :: DKind ts_a1BOW  'Kind)))))  'None
data SDTerm (ts_a1CDY :: [DSort]) (us_a1CDZ :: [DKind ts_a1CDY 'Kind]) (a_a1Ddx :: [DType ts_a1CDY us_a1CDZ ( 'Type :: DKind ts_a1CDY 'Kind)]) (b_a1Ddy :: DType ts_a1CDY us_a1CDZ ( 'Type :: DKind ts_a1CDY 'Kind)) (x_a1DlA :: DTerm (ts_a1CDY :: [DSort]) (us_a1CDZ :: [DKind ts_a1CDY 'Kind]) (a_a1Ddx :: [DType ts_a1CDY us_a1CDZ ( 'Type :: DKind ts_a1CDY 'Kind)]) (b_a1Ddy :: DType ts_a1CDY us_a1CDZ ( 'Type :: DKind ts_a1CDY 'Kind)))
[SVar] :: forall (ts_a1CE2 :: [DSort]) (us_a1CE3 :: [DKind ts_a1CE2  'Kind]) (vs_a1CE0 :: [DType ts_a1CE2 us_a1CE3 ( 'Type :: DKind ts_a1CE2  'Kind)]) (a_a1CE1 :: DType ts_a1CE2 us_a1CE3 ( 'Type :: DKind ts_a1CE2  'Kind)) x_a1DlB. () => PolySing (Index vs_a1CE0 a_a1CE1) x_a1DlB -> SDTerm ts_a1CE2 us_a1CE3 vs_a1CE0 a_a1CE1 ( 'Var x_a1DlB)
[SLam] :: forall (ts_a1CE4 :: [DSort]) (us_a1CE5 :: [DKind ts_a1CE4  'Kind]) (v_X1CE7 :: DType ts_a1CE4 us_a1CE5 ( 'Type :: DKind ts_a1CE4  'Kind)) (vs_a1CE7 :: [DType ts_a1CE4 us_a1CE5 ( 'Type :: DKind ts_a1CE4  'Kind)]) (a_X1CEa :: DType ts_a1CE4 us_a1CE5 ( 'Type :: DKind ts_a1CE4  'Kind)) x_a1DlG x_a1Dnp. () => SingSing (DType ts_a1CE4 us_a1CE5 ( 'Type :: DKind ts_a1CE4  'Kind)) v_X1CE7 ( 'WS x_a1DlG) -> SDTerm ts_a1CE4 us_a1CE5 ( '(:) v_X1CE7 vs_a1CE7) a_X1CEa x_a1Dnp -> SDTerm ts_a1CE4 us_a1CE5 vs_a1CE7 ( '(:->) v_X1CE7 a_X1CEa) ( 'Lam x_a1DlG x_a1Dnp)
[SApp] :: forall (ts_a1CE9 :: [DSort]) (us_a1CEa :: [DKind ts_a1CE9  'Kind]) (vs_a1CEb :: [DType ts_a1CE9 us_a1CEa ( 'Type :: DKind ts_a1CE9  'Kind)]) (a_X1CEd :: DType ts_a1CE9 us_a1CEa ( 'Type :: DKind ts_a1CE9  'Kind)) (b_a1CEd :: DType ts_a1CE9 us_a1CEa ( 'Type :: DKind ts_a1CE9  'Kind)) x_a1DnR x_a1Doj. () => SDTerm ts_a1CE9 us_a1CEa vs_a1CEb ( '(:->) a_X1CEd b_a1CEd) x_a1DnR -> SDTerm ts_a1CE9 us_a1CEa vs_a1CEb a_X1CEd x_a1Doj -> SDTerm ts_a1CE9 us_a1CEa vs_a1CEb b_a1CEd ( 'App x_a1DnR x_a1Doj)
[SPoly] :: forall (ts_a1CEe :: [DSort]) (u_X1CEg :: DKind ts_a1CEe  'Kind) (uu_X1CEi :: SDKind ts_a1CEe  'Kind u_X1CEg) (us_a1CEh :: [DKind ts_a1CEe  'Kind]) (vs_a1CEi :: [DType ts_a1CEe us_a1CEh ( 'Type :: DKind ts_a1CEe  'Kind)]) (a_X1CEm :: DType ts_a1CEe ( '(:) u_X1CEg us_a1CEh) ( 'Type :: DKind ts_a1CEe  'Kind)) x_a1DoL x_a1Dpy. () => SingSing (WrappedSing (DKind ts_a1CEe  'Kind) u_X1CEg) ( 'WS uu_X1CEi) ( 'WS x_a1DoL) -> SDTerm ts_a1CEe ( '(:) u_X1CEg us_a1CEh) (Map (ShiftSym ts_a1CEe us_a1CEh ( '(:) u_X1CEg us_a1CEh) u_X1CEg ( 'Type :: DKind ts_a1CEe  'Kind) ( 'InsZ :: Insert us_a1CEh ( '(:) u_X1CEg us_a1CEh) u_X1CEg)) vs_a1CEi) a_X1CEm x_a1Dpy -> SDTerm ts_a1CEe us_a1CEh vs_a1CEi ( 'Pi uu_X1CEi a_X1CEm) ( 'Poly x_a1DoL x_a1Dpy)
[SInst] :: forall (ts_a1CEk :: [DSort]) (u_X1CEm :: DKind ts_a1CEk  'Kind) (uu_X1CEo :: SDKind ts_a1CEk  'Kind u_X1CEm) (us_a1CEn :: [DKind ts_a1CEk  'Kind]) (vs_a1CEo :: [DType ts_a1CEk us_a1CEn ( 'Type :: DKind ts_a1CEk  'Kind)]) (b_X1CEs :: DType ts_a1CEk ( '(:) u_X1CEm us_a1CEn) ( 'Type :: DKind ts_a1CEk  'Kind)) (a_X1CEu :: DType ts_a1CEk us_a1CEn u_X1CEm) x_a1E2O x_a1E3B x_a1E43. () => SingSing (WrappedSing (DKind ts_a1CEk  'Kind) u_X1CEm) ( 'WS uu_X1CEo) ( 'WS x_a1E2O) -> SDTerm ts_a1CEk us_a1CEn vs_a1CEo ( 'Pi uu_X1CEo b_X1CEs) x_a1E3B -> SingSing (DType ts_a1CEk us_a1CEn u_X1CEm) a_X1CEu ( 'WS x_a1E43) -> SDTerm ts_a1CEk us_a1CEn vs_a1CEo (Sub ts_a1CEk ( '(:) u_X1CEm us_a1CEn) us_a1CEn u_X1CEm ( 'Type :: DKind ts_a1CEk  'Kind) ( 'DelZ :: Delete ( '(:) u_X1CEm us_a1CEn) us_a1CEn u_X1CEm) a_X1CEu b_X1CEs) ( 'Inst x_a1E2O x_a1E3B x_a1E43)
[SP] :: forall (ts_a1CEr :: [DSort]) (us_a1CEs :: [DKind ts_a1CEr  'Kind]) (as_X1CEu :: [DType ts_a1CEr us_a1CEs ( 'Type :: DKind ts_a1CEr  'Kind)]) (a_a1CEu :: DType ts_a1CEr us_a1CEs ( 'Type :: DKind ts_a1CEr  'Kind)) (vs_a1CEv :: [DType ts_a1CEr us_a1CEs ( 'Type :: DKind ts_a1CEr  'Kind)]) x_a1E4t x_a1E4Y. () => PolySing (Prim ts_a1CEr us_a1CEs as_X1CEu a_a1CEu) x_a1E4t -> PolySing (Prod (DTerm ts_a1CEr us_a1CEs vs_a1CEv) as_X1CEu) x_a1E4Y -> SDTerm ts_a1CEr us_a1CEs vs_a1CEv a_a1CEu ( 'P x_a1E4t x_a1E4Y)
[SListLit] :: forall (ts_a1CEw :: [DSort]) (us_a1CEx :: [DKind ts_a1CEw  'Kind]) (a_X1CEz :: DType ts_a1CEw us_a1CEx ( 'Type :: DKind ts_a1CEw  'Kind)) (vs_a1CEz :: [DType ts_a1CEw us_a1CEx ( 'Type :: DKind ts_a1CEw  'Kind)]) x_a1E8Y x_a1EaH. () => SingSing (DType ts_a1CEw us_a1CEx ( 'Type :: DKind ts_a1CEw  'Kind)) a_X1CEz ( 'WS x_a1E8Y) -> PolySing [DTerm ts_a1CEw us_a1CEx vs_a1CEz a_X1CEz] x_a1EaH -> SDTerm ts_a1CEw us_a1CEx vs_a1CEz ((:$) ( 'List :: DType ts_a1CEw us_a1CEx ((:~>) ( 'Type :: DKind ts_a1CEw  'Kind) ( 'Type :: DKind ts_a1CEw  'Kind))) a_X1CEz) ( 'ListLit x_a1E8Y x_a1EaH)
[SOptionalLit] :: forall (ts_a1CEA :: [DSort]) (us_a1CEB :: [DKind ts_a1CEA  'Kind]) (a_X1CED :: DType ts_a1CEA us_a1CEB ( 'Type :: DKind ts_a1CEA  'Kind)) (vs_a1CED :: [DType ts_a1CEA us_a1CEB ( 'Type :: DKind ts_a1CEA  'Kind)]) x_a1Ei9 x_a1EjS. () => SingSing (DType ts_a1CEA us_a1CEB ( 'Type :: DKind ts_a1CEA  'Kind)) a_X1CED ( 'WS x_a1Ei9) -> PolySing (Maybe (DTerm ts_a1CEA us_a1CEB vs_a1CED a_X1CED)) x_a1EjS -> SDTerm ts_a1CEA us_a1CEB vs_a1CED ((:$) ( 'Optional :: DType ts_a1CEA us_a1CEB ((:~>) ( 'Type :: DKind ts_a1CEA  'Kind) ( 'Type :: DKind ts_a1CEA  'Kind))) a_X1CED) ( 'OptionalLit x_a1Ei9 x_a1EjS)
data SAggType (k_a1AAj :: Type) (ls_a1AAk :: [Text]) (as_a1AAl :: [k_a1AAj]) (x_a1AFo :: AggType (k_a1AAj :: Type) (ls_a1AAk :: [Text]) (as_a1AAl :: [k_a1AAj]))
[SATZ] :: forall (k_a1AAm :: Type). () => SAggType k_a1AAm ('[] :: [Text]) ('[] :: [k_a1AAm])  'ATZ
[SATS] :: forall (k_a1AAn :: Type) (l_X1AAp :: Text) (a_X1AAr :: k_a1AAn) (ls_X1AAt :: [Text]) (as_X1AAv :: [k_a1AAn]) x_a1AFp x_a1AFr x_a1AFu. () => SingSing Text l_X1AAp ( 'WS x_a1AFp) -> PolySing (WrappedSing k_a1AAn a_X1AAr) x_a1AFr -> SAggType k_a1AAn ls_X1AAt as_X1AAv x_a1AFu -> SAggType k_a1AAn ( '(:) l_X1AAp ls_X1AAt) ( '(:) a_X1AAr as_X1AAv) ( 'ATS x_a1AFp x_a1AFr x_a1AFu)
data KShiftSym ts ps a b :: Insert ts ps a -> DKind ts b ~> DKind ps b
data ShiftSym ts us qs a b :: Insert us qs a -> DType ts us b ~> DType ts qs b
type family Map (f :: a ~> b) (xs :: [a]) :: [b]
data MapSym (f :: a ~> b) :: [a] ~> [b]

module Dhall.Typed
