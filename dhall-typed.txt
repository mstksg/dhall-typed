-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/dhall-typed#readme</a>
@package dhall-typed
@version 0.1.0.0

module Dhall.Typed.Type.N
data N
Z :: N
S :: N -> N

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
type SN = (Sing :: N -> Type)
fromNatural :: Natural -> N
toNatural :: N -> Natural
type ZSym0 = Z
data SSym0 :: (~>) N N
type SSym1 (t6989586621679134417 :: N) = S t6989586621679134417
data IsLength :: [k] -> N -> Type
[ILZ] :: IsLength '[]  'Z
[ILS] :: IsLength as n -> IsLength (a : as) ( 'S n)
data Fin :: N -> Type
[FZ] :: Fin ( 'S n)
[FS] :: Fin n -> Fin ( 'S n)
data SFin n :: Fin n -> Type
[SFZ] :: SFin ( 'S n)  'FZ
[SFS] :: SFin n x -> SFin ( 'S n) ( 'FS x)
type family ShiftFin n (i :: Fin n) :: Fin n
data LTE :: N -> N -> Type
[LTEZ] :: LTE  'Z m
[LTES] :: LTE n m -> LTE ( 'S n) ( 'S m)
type N0 =  'Z
type N1 =  'S N0
type N2 =  'S N1
type N3 =  'S N2
type N4 =  'S N3
type N5 =  'S N4
type F0 =  'FZ
type F1 =  'FS F0
type F2 =  'FS F1
type F3 =  'FS F2
type F4 =  'FS F3
type F5 =  'FS F4
sf0 :: SFin ( 'S n) F0
sf1 :: SFin ( 'S ( 'S n)) F1
sf2 :: SFin ( 'S ( 'S ( 'S n))) F2
sf3 :: SFin ( 'S ( 'S ( 'S ( 'S n)))) F3
sf4 :: SFin ( 'S ( 'S ( 'S ( 'S ( 'S n))))) F4
sf5 :: SFin ( 'S ( 'S ( 'S ( 'S ( 'S ( 'S n)))))) F5
instance GHC.Show.Show Dhall.Typed.Type.N.N
instance GHC.Classes.Ord Dhall.Typed.Type.N.N
instance GHC.Classes.Eq Dhall.Typed.Type.N.N
instance Data.Singletons.ShowSing.ShowSing Dhall.Typed.Type.N.N => GHC.Show.Show (Data.Singletons.Internal.Sing z)
instance Data.Singletons.Prelude.Eq.PEq Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.ShowsPrec_6989586621679139938Sym0
instance Data.Singletons.Prelude.Show.PShow Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.ShowsPrec_6989586621679139938Sym1 a6989586621679139935)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.ShowsPrec_6989586621679139938Sym2 a6989586621679139936 a6989586621679139935)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.Compare_6989586621679136394Sym0
instance Data.Singletons.Prelude.Ord.POrd Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.Compare_6989586621679136394Sym1 a6989586621679136392)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.SSym0
instance Data.Singletons.Internal.SingI Dhall.Typed.Type.N.SSym0
instance Data.Singletons.Internal.SingKind Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Ord.SOrd Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Ord.SOrd Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Show.SShow Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Show.SShow Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Eq.SEq Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Eq.SEq Dhall.Typed.Type.N.N
instance Data.Singletons.Decide.SDecide Dhall.Typed.Type.N.N => Data.Singletons.Decide.SDecide Dhall.Typed.Type.N.N
instance Data.Singletons.Internal.SingI 'Dhall.Typed.Type.N.Z
instance Data.Singletons.Internal.SingI n => Data.Singletons.Internal.SingI ('Dhall.Typed.Type.N.S n)
instance Data.Singletons.Internal.SingI (Data.Singletons.Internal.TyCon1 'Dhall.Typed.Type.N.S)

module Dhall.Typed.Plugin
plugin :: Plugin

module Dhall.Typed.Type.Option
data Option :: (k -> Type) -> Maybe k -> Type
[Noot] :: Option f  'Nothing
[Juus] :: f a -> Option f ( 'Just a)

module Dhall.Typed.Type.Singletons.TH
genPolySing :: DsMonad q => Name -> q [Dec]
genPolySingWith :: DsMonad q => GenPolySingOpts -> Name -> q [Dec]
data GenPolySingOpts
GPSO :: !Bool -> !Bool -> !GenOpts -> !GenOpts -> GenPolySingOpts
[gpsoSing] :: GenPolySingOpts -> !Bool
[gpsoSingI] :: GenPolySingOpts -> !Bool
[gpsoPSK] :: GenPolySingOpts -> !GenOpts
[gpsoSingEq] :: GenPolySingOpts -> !GenOpts
defaultGPSO :: GenPolySingOpts
data GenOpts
GOInfer :: GenOpts
GOSkip :: GenOpts
GOHead :: Q [Dec] -> GenOpts
genPolySingKind :: forall q. DsMonad q => q [Dec] -> q [Dec]
genSingEq :: forall q. DsMonad q => q [Dec] -> q [Dec]
instance GHC.Base.Functor Dhall.Typed.Type.Singletons.TH.V2
instance GHC.Base.Applicative Dhall.Typed.Type.Singletons.TH.V2
instance GHC.Base.Monad Dhall.Typed.Type.Singletons.TH.V2
instance Data.Default.Class.Default Dhall.Typed.Type.Singletons.TH.GenPolySingOpts

module Dhall.Typed.Type.Singletons
type family PolySing k = (s :: k -> Type) | s -> k
class PolySingI (x :: k)
polySing :: PolySingI x => PolySing k x
class PolySingKind k
fromPolySing :: PolySingKind k => PolySing k x -> k
toPolySing :: PolySingKind k => k -> SomePolySing k
data SomePolySing k
[SomePS] :: PolySing k x -> SomePolySing k
newtype WrappedSing k (x :: k)
WS :: PolySing k x -> WrappedSing k
[getWS] :: WrappedSing k -> PolySing k x
newtype SingSing k x :: WrappedSing k x -> Type
[SiSi] :: forall k x (ws :: WrappedSing k x). () => {getSiSi :: PolySing k x} -> SingSing k x ws
type PolySingOfI (x :: PolySing k y) = PolySingI y
class SingEq f g
singEq :: forall x y. SingEq f g => PolySing f x -> PolySing g y -> Decision (x :~~: y)
data SConst (a_awxB :: Type) (b_awxC :: k_awxA) (x_a1rN7 :: Const (a_awxB :: Type) (b_awxC :: k_awxA))
[SConst] :: forall (a_awxB :: Type) (b_awxC :: k_awxA) x_a1rN8. () => {sGetConst :: PolySing a_awxB x_a1rN8} -> SConst (a_awxB :: Type) (b_awxC :: k_awxA) ( 'Const x_a1rN8)
data SMaybe (a_11 :: Type) (x_a1rUt :: Maybe (a_11 :: Type))
[SNothing] :: forall (a_11 :: Type). () => SMaybe (a_11 :: Type)  'Nothing
[SJust] :: forall (a_11 :: Type) x_a1rUu. () => PolySing a_11 x_a1rUu -> SMaybe (a_11 :: Type) ( 'Just x_a1rUu)
data SList k :: [k] -> Type
[:%] :: PolySing k x -> SList k xs -> SList k (x : xs)
[SNil] :: SList k '[]
infixr 5 :%
data STup2 a b :: (a, b) -> Type
[STup2] :: PolySing a x -> PolySing b y -> STup2 a b '(x, y)
data SBool :: Bool -> Type
[SFalse] :: SBool  'False
[STrue] :: SBool  'True
data SProxy (t_a1i4G :: k_a1i4F) (x_a1s0W :: Proxy (t_a1i4G :: k_a1i4F))
[SProxy] :: forall (t_a1i4G :: k_a1i4F). () => SProxy (t_a1i4G :: k_a1i4F)  'Proxy
data STup0 :: () -> Type
[STup0] :: STup0  '()
type family ToNat (n :: Natural) = (m :: Nat) | m -> n
type family FromNat (m :: Nat) = (n :: Natural) | n -> m
data SNatural :: Natural -> Type
[SNat] :: KnownNat (ToNat n) => SNatural n
withKnownNatural :: forall n r. KnownNat n => (KnownNat (ToNat (FromNat n)) => r) -> r
type family ToSym (t :: Text) = (s :: Symbol) | s -> t
type family FromSym (s :: Symbol) = (t :: Text) | t -> s
data SText :: Text -> Type
[SText] :: KnownSymbol (ToSym t) => SText t
withKnownText :: forall n r. KnownSymbol n => (KnownSymbol (ToSym (FromSym n)) => r) -> r
instance GHC.TypeLits.KnownSymbol (Dhall.Typed.Type.Singletons.ToSym t) => Dhall.Typed.Type.Singletons.Internal.PolySingI t
instance Dhall.Typed.Type.Singletons.Internal.PolySingKind Data.Text.Internal.Text
instance Dhall.Typed.Type.Singletons.Internal.SingEq Data.Text.Internal.Text Data.Text.Internal.Text
instance GHC.TypeNats.KnownNat (Dhall.Typed.Type.Singletons.ToNat n) => Dhall.Typed.Type.Singletons.Internal.PolySingI n
instance Dhall.Typed.Type.Singletons.Internal.PolySingKind GHC.Natural.Natural
instance Dhall.Typed.Type.Singletons.Internal.SingEq GHC.Natural.Natural GHC.Natural.Natural
instance forall k (t :: k). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Data.Proxy.Proxy
instance forall k (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Proxy.Proxy a)
instance forall k (a :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Proxy.Proxy a) (Data.Proxy.Proxy a)
instance Dhall.Typed.Type.Singletons.Internal.PolySingI 'GHC.Maybe.Nothing
instance forall a (x :: a). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('GHC.Maybe.Just x)
instance Dhall.Typed.Type.Singletons.Internal.PolySingKind a => Dhall.Typed.Type.Singletons.Internal.PolySingKind (GHC.Maybe.Maybe a)
instance Dhall.Typed.Type.Singletons.Internal.SingEq a a => Dhall.Typed.Type.Singletons.Internal.SingEq (GHC.Maybe.Maybe a) (GHC.Maybe.Maybe a)
instance forall k (b :: k) a (x :: a). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Data.Functor.Const.Const x)
instance forall k a (b :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind a => Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Functor.Const.Const a b)
instance forall k a b (c :: k). Dhall.Typed.Type.Singletons.Internal.SingEq a b => Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Functor.Const.Const a c) (Data.Functor.Const.Const b c)

module Dhall.Typed.Type.Index

-- | Witness an item in a type-level list by providing its index.
data Index (a :: [k]) (b :: k) :: forall k. () => [k] -> k -> Type
[IZ] :: forall k (a :: [k]) (b :: k) (as :: [k]). () => Index (b : as) b
[IS] :: forall k (a :: [k]) (b :: k) (bs :: [k]) (b1 :: k). () => Index bs b -> Index (b1 : bs) b
data SIndex (a_a1vxt :: [k_a1vxs]) (b_a1vxu :: k_a1vxs) (x_a1vxI :: Index (a_a1vxt :: [k_a1vxs]) (b_a1vxu :: k_a1vxs))
[SIZ] :: forall (k_a1vxs :: Type) (b_a1vxu :: k_a1vxs) (as_a1vxv :: [k_a1vxs]). () => SIndex ( '(:) b_a1vxu as_a1vxv) b_a1vxu  'IZ
[SIS] :: forall (k_a1vxs :: Type) (bs_a1vxy :: [k_a1vxs]) (b_a1vxu :: k_a1vxs) (b1_a1vxz :: k_a1vxs) x_a1vxJ. () => SIndex bs_a1vxy b_a1vxu x_a1vxJ -> SIndex ( '(:) b1_a1vxz bs_a1vxy) b_a1vxu ( 'IS x_a1vxJ)
sSameIx :: SIndex as a i -> SIndex as a j -> Maybe (i :~: j)
fromSIndex :: SIndex as a i -> Index as a
data SSIndex (a_a1vxt :: [k_a1vxs]) (b_a1vxu :: k_a1vxs) (x_a1vxI :: Index a_a1vxt b_a1vxu) (x_a1vHx :: SIndex (a_a1vxt :: [k_a1vxs]) (b_a1vxu :: k_a1vxs) (x_a1vxI :: Index a_a1vxt b_a1vxu))
[SSIZ] :: forall (k_a1vxs :: Type) (b_a1vxu :: k_a1vxs) (as_X1vxw :: [k_a1vxs]). () => SSIndex ( '(:) b_a1vxu as_X1vxw) b_a1vxu ( 'IZ :: Index ( '(:) b_a1vxu as_X1vxw) b_a1vxu)  'SIZ
[SSIS] :: forall (k_a1vxs :: Type) (bs_X1vxz :: [k_a1vxs]) (b_a1vxu :: k_a1vxs) (b1_X1vxB :: k_a1vxs) (x_X1vxM :: Index bs_X1vxz b_a1vxu) x_a1vHy. () => SingSing (Index bs_X1vxz b_a1vxu) x_X1vxM ( 'WS x_a1vHy) -> SSIndex ( '(:) b1_X1vxB bs_X1vxz) b_a1vxu ( 'IS x_X1vxM :: Index ( '(:) b1_X1vxB bs_X1vxz) b_a1vxu) ( 'SIS x_a1vHy)
data Delete :: [k] -> [k] -> k -> Type
[DelZ] :: Delete (a : as) as a
[DelS] :: Delete as bs c -> Delete (a : as) (a : bs) c
del :: Delete as bs a -> Index as b -> Maybe (Index bs b)
type family ISMaybe (i :: Maybe (Index as a)) :: Maybe (Index (b : as) a)
type family Del as bs a b (d :: Delete as bs a) (i :: Index as b) :: Maybe (Index bs b)
data SDelete (a_a1vPL :: [k_a1vIi]) (b_a1vPM :: [k_a1vIi]) (c_a1vPN :: k_a1vIi) (x_a1vZ8 :: Delete (a_a1vPL :: [k_a1vIi]) (b_a1vPM :: [k_a1vIi]) (c_a1vPN :: k_a1vIi))
[SDelZ] :: forall (k_a1vPl :: Type) (a_a1vIj :: k_a1vPl) (as_a1vIk :: [k_a1vPl]). () => SDelete ( '(:) a_a1vIj as_a1vIk) as_a1vIk a_a1vIj  'DelZ
[SDelS] :: forall (a_a1vPC :: Type) (as_X1vIm :: [a_a1vPC]) (bs_X1vIo :: [a_a1vPC]) (c_a1vIn :: a_a1vPC) (a_X1vIr :: a_a1vPC) x_a1vZ9. () => SDelete as_X1vIm bs_X1vIo c_a1vIn x_a1vZ9 -> SDelete ( '(:) a_X1vIr as_X1vIm) ( '(:) a_X1vIr bs_X1vIo) c_a1vIn ( 'DelS x_a1vZ9)
sDel :: SDelete as bs a del -> SIndex as b i -> GetDeleted as bs a b del i
data GetDeleted as bs a b :: Delete as bs a -> Index as b -> Type
[GotDeleted] :: Del as bs a b del i ~  'Nothing => (a :~: b) -> GetDeleted as bs a b del i
[ThatsToxic] :: Del as bs a b del i ~  'Just j => SIndex bs b j -> GetDeleted as bs a b del i

-- | This is just flipped delete, heh.
data Insert :: [k] -> [k] -> k -> Type
[InsZ] :: Insert as (a : as) a
[InsS] :: Insert as bs c -> Insert (a : as) (a : bs) c
insert :: Insert as bs a -> Index as b -> Index bs b
type family Ins as bs a b (ins :: Insert as bs a) (i :: Index as b) :: Index bs b
sIns :: forall as bs a b ins i. () => SInsert as bs a ins -> SIndex as b i -> SIndex bs b (Ins as bs a b ins i)
data SInsert (a_a1wcB :: [k_a1vZM]) (b_a1wcC :: [k_a1vZM]) (c_a1wcD :: k_a1vZM) (x_a1wlp :: Insert (a_a1wcB :: [k_a1vZM]) (b_a1wcC :: [k_a1vZM]) (c_a1wcD :: k_a1vZM))
[SInsZ] :: forall (a_a1wcc :: Type) (as_a1vZN :: [a_a1wcc]) (a_a1vZO :: a_a1wcc). () => SInsert as_a1vZN ( '(:) a_a1vZO as_a1vZN) a_a1vZO  'InsZ
[SInsS] :: forall (a_a1wcs :: Type) (as_X1vZQ :: [a_a1wcs]) (bs_X1vZS :: [a_a1wcs]) (c_a1vZR :: a_a1wcs) (a_X1vZV :: a_a1wcs) x_a1wlq. () => SInsert as_X1vZQ bs_X1vZS c_a1vZR x_a1wlq -> SInsert ( '(:) a_X1vZV as_X1vZQ) ( '(:) a_X1vZV bs_X1vZS) c_a1vZR ( 'InsS x_a1wlq)

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
instance forall a1 (as :: [a1]) (a2 :: a1). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Index.InsZ
instance forall a1 (a2 :: a1) (as :: [a1]) (bs :: [a1]) (c :: a1) (x :: Dhall.Typed.Type.Index.Insert as bs c). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Index.InsS x)
instance forall k (a :: [k]) (b :: [k]) (c :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Index.Insert a b c)
instance forall k (a1 :: [k]) (a2 :: [k]) (a3 :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Index.Insert a1 a2 a3) (Dhall.Typed.Type.Index.Insert a1 a2 b)
instance forall k (a :: k) (as :: [k]). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Index.DelZ
instance forall a1 (a2 :: a1) (as :: [a1]) (bs :: [a1]) (c :: a1) (x :: Dhall.Typed.Type.Index.Delete as bs c). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Index.DelS x)
instance forall k (a :: [k]) (b :: [k]) (c :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Index.Delete a b c)
instance forall k (a1 :: [k]) (a2 :: [k]) (a3 :: k) (b1 :: [k]) (b2 :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Index.Delete a1 a2 a3) (Dhall.Typed.Type.Index.Delete a1 b1 b2)
instance forall k (as :: [k]) (a :: k) (i :: Data.Type.Universe.Index as a). GHC.Show.Show (Dhall.Typed.Type.Index.SIndex as a i)
instance forall k (b :: k) (as :: [k]). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Index.SIZ
instance forall k (b1 :: k) (bs :: [k]) (b :: k) (y :: Data.Type.Universe.Index bs b) (x :: Dhall.Typed.Type.Index.SIndex bs b y). Dhall.Typed.Type.Singletons.Internal.PolySingOfI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Index.SIS x)
instance forall k (as :: [k]) (a :: k) (x :: Data.Type.Universe.Index as a). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Index.SIndex as a x)
instance forall k (as :: [k]) (a :: k) (x :: Data.Type.Universe.Index as a) (b :: k) (y :: Data.Type.Universe.Index as b). Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Index.SIndex as a x) (Dhall.Typed.Type.Index.SIndex as b y)
instance forall k (as :: [k]) (a :: k). Data.Singletons.Internal.SingKind (Data.Type.Universe.Index as a)
instance forall k (b :: k) (as :: [k]). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Data.Type.Universe.IZ
instance forall k (b1 :: k) (bs :: [k]) (b :: k) (x :: Data.Type.Universe.Index bs b). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Data.Type.Universe.IS x)
instance forall k (as :: [k]) (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Type.Universe.Index as a)
instance forall k (as :: [k]) (a :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Type.Universe.Index as a) (Data.Type.Universe.Index as b)

module Dhall.Typed.Type.Prod
data Prod :: (k -> Type) -> [k] -> Type
[Ø] :: Prod f '[]
[:<] :: f a -> Prod f as -> Prod f (a : as)
infixr 5 :<
traverseProd :: forall f g h as. Applicative h => (forall x. f x -> h (g x)) -> Prod f as -> h (Prod g as)
mapProd :: forall f g as. () => (forall x. f x -> g x) -> Prod f as -> Prod g as
zipProd :: Prod f as -> Prod g as -> Prod (f :*: g) as
singProd :: SList k as -> Prod (PolySing k) as
prodSing :: Prod (PolySing k) as -> SList k as
ixProd :: Prod f as -> Index as a -> f a
data SeqListEq :: Seq a -> [a] -> Type
[SeqListEq] :: SeqListEq xs ys
type family IxProd f as b (p :: Prod f as) (i :: Index as b) :: f b
data SProd (a_a1yAY :: k_a1yA6 -> Type) (b_a1yAZ :: [k_a1yA6]) (x_a1yDP :: Prod (a_a1yAY :: k_a1yA6 -> Type) (b_a1yAZ :: [k_a1yA6]))
[SØ] :: forall (k_a1yAx :: Type) (f_a1yA7 :: k_a1yAx -> Type). () => SProd f_a1yA7 ('[] :: [k_a1yAx])  'Ø
[:%<] :: forall (a_a1yAP :: Type) (f_a1yA8 :: a_a1yAP -> Type) (a_X1yAa :: a_a1yAP) (as_X1yAc :: [a_a1yAP]) x_a1yDQ x_a1yDR. () => PolySing (f_a1yA8 a_X1yAa) x_a1yDQ -> SProd f_a1yA8 as_X1yAc x_a1yDR -> SProd f_a1yA8 ( '(:) a_X1yAa as_X1yAc) ( '(:<) x_a1yDQ x_a1yDR)
sIxProd :: SProd f as xs -> SIndex as a i -> PolySing (f a) (IxProd f as a xs i)
type family ProdList (xs :: Prod (Const k) ys) :: [k]
data BiProd :: (k -> Type) -> (j -> Type) -> [k] -> [j] -> Type
[BZ] :: BiProd f g '[] '[]
[BS] :: f a -> g b -> BiProd f g as bs -> BiProd f g (a : as) (b : bs)
data SBiProd (a_a1yKp :: k_a1yEG -> Type) (b_a1yKq :: j_a1yEH -> Type) (c_a1yKr :: [k_a1yEG]) (d_a1yKs :: [j_a1yEH]) (x_a1yTr :: BiProd (a_a1yKp :: k_a1yEG -> Type) (b_a1yKq :: j_a1yEH -> Type) (c_a1yKr :: [k_a1yEG]) (d_a1yKs :: [j_a1yEH]))
[SBZ] :: forall (k_a1yJN :: Type) (j_a1yJO :: Type) (f_a1yEI :: k_a1yJN -> Type) (g_a1yEJ :: j_a1yJO -> Type). () => SBiProd f_a1yEI g_a1yEJ ('[] :: [k_a1yJN]) ('[] :: [j_a1yJO])  'BZ
[SBS] :: forall (a_a1yKf :: Type) (a_a1yKg :: Type) (f_a1yEK :: a_a1yKf -> Type) (a_X1yEM :: a_a1yKf) (g_a1yEM :: a_a1yKg -> Type) (b_X1yEP :: a_a1yKg) (as_X1yER :: [a_a1yKf]) (bs_X1yET :: [a_a1yKg]) x_a1yTs x_a1yTt x_a1yTu. () => PolySing (f_a1yEK a_X1yEM) x_a1yTs -> PolySing (g_a1yEM b_X1yEP) x_a1yTt -> SBiProd f_a1yEK g_a1yEM as_X1yER bs_X1yET x_a1yTu -> SBiProd f_a1yEK g_a1yEM ( '(:) a_X1yEM as_X1yER) ( '(:) b_X1yEP bs_X1yET) ( 'BS x_a1yTs x_a1yTt x_a1yTu)
instance forall k (f :: k -> *) j (g :: j -> *). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Prod.BZ
instance forall a1 (as :: [a1]) a2 (bs :: [a2]) (g :: a2 -> *) (b :: a2) (f :: a1 -> *) (a3 :: a1) (x1 :: f a3) (x2 :: g b) (x3 :: Dhall.Typed.Type.Prod.BiProd f g as bs). (Dhall.Typed.Type.Singletons.Internal.PolySingI x1, Dhall.Typed.Type.Singletons.Internal.PolySingI x2, Dhall.Typed.Type.Singletons.Internal.PolySingI x3) => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Prod.BS x1 x2 x3)
instance forall j k (f :: k -> *) (g :: j -> *) (as :: [k]) (bs :: [j]). (forall (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (f a), forall (a :: j). Dhall.Typed.Type.Singletons.Internal.PolySingKind (g a)) => Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Prod.BiProd f g as bs)
instance forall j k (f :: k -> *) (g :: j -> *) (as :: [k]) (bs :: [j]) (cs :: [k]) (ds :: [j]). (forall (a :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (f a) (f b), forall (a :: j) (b :: j). Dhall.Typed.Type.Singletons.Internal.SingEq (g a) (g b)) => Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Prod.BiProd f g as bs) (Dhall.Typed.Type.Prod.BiProd f g cs ds)
instance forall k (f :: k -> *). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Prod.Ø
instance forall a1 (as :: [a1]) (f :: a1 -> *) (a2 :: a1) (x1 :: f a2) (x2 :: Dhall.Typed.Type.Prod.Prod f as). (Dhall.Typed.Type.Singletons.Internal.PolySingI x1, Dhall.Typed.Type.Singletons.Internal.PolySingI x2) => Dhall.Typed.Type.Singletons.Internal.PolySingI (x1 'Dhall.Typed.Type.Prod.:< x2)
instance forall k (f :: k -> *) (as :: [k]). (forall (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (f a)) => Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Prod.Prod f as)
instance forall k (f :: k -> *) (as :: [k]) (bs :: [k]). (forall (a :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (f a) (f b)) => Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Prod.Prod f as) (Dhall.Typed.Type.Prod.Prod f bs)


-- | Implementing a typed lambda calculus. Uses De Bruijn indices in
--   separate namespaces (that is, kind, type, term variables all have
--   their own separate De Bruijn indexing)
--   
--   We have a hierarchy: Term -&gt; Type -&gt; Kind -&gt; Sort. We can
--   stop at Sort because we don't allow any Sort variables, so there is no
--   need to talk about the "type" of any Sorts. Disallowing variables
--   effectively stops the chain.
--   
--   It looks like each level has some sets of constructors just from its
--   position on the chain.
--   
--   <ul>
--   <li>At all levels, we have <i>primitives</i>. Term-level primitives
--   are built-in functions and values and literals. Type-level primitives
--   are built-in types and type functions. Dhall has no kind- or
--   sort-level primitives.</li>
--   <li>If a level has variables (Terms, Types, Kinds), we gain some
--   constructors:<ul><li>Var, the variable constructor j Lam, the function
--   abstraction</li><li>App, the function application</li></ul></li>
--   <li>If a level has variables and its "type" also has variables (Terms,
--   Types), we gain some constructors:<ul><li>Poly, the type
--   abstraction</li><li>Inst (instantiation), the type
--   application</li></ul></li>
--   <li>If a level is the "type" of something (n &gt;= 1), we gain a
--   function type constructor, the type of function abstractions in the
--   immediately lower level.</li>
--   <li>If a level is the "type" of a "type" of something (n &gt;= 2), we
--   gain an "constant" constructor that links the two layers below it
--   together. Examples are the Kind sort that links Kinds to Types (all
--   types have kinds of sort Kind), and the Type kind that links types to
--   values (all terms have types of kind Type)</li>
--   <li>If a type is the "type" of something (n &gt;= 1), <i>and</i> it
--   has variables, we have a Pi type constructor, the type of type
--   abstractions (type-polymorphic values) in the lower level.</li>
--   </ul>
--   
--   We actually gain a Pi type for our current level, and each level above
--   our current level (that has variables). So for the Type level, we have
--   Type-Pi and Kind-Pi, and for the Kind level, we have Kind-Pi.
--   
--   So to summarize:
--   
--   <ul>
--   <li>n = 3: Sort has a constant (it is n &gt;= 2) and a function type
--   constructor (it is n &gt;= 1). It could also potentially have
--   primitives, but Dhall has no sort primitives.</li>
--   <li>n = 2: Kind has variables, so it has Var, Lam, and App. It has a
--   constant (they are n &gt;= 2) and a function type constructor and a Pi
--   constructor (it is n &gt;= 1 and has variables). It could also
--   potentially have primitives; Dhall has only record and union kinds as
--   primitives.</li>
--   <li>n = 1: Type has variables, so it has Var, Lam, and App. It has a
--   function type constructor and a Pi constructor (it is n &gt;= 1 and
--   has variables). Because its "type" has variables (Kind), it also has
--   Poly and Inst. It has primitives, and in Dhall ther are several.</li>
--   <li>n = 0: Term has variables, so it has Var, Lam, and App. Because
--   its "type" has variables, it has Poly and Inst. In Dhall, it has
--   multitudes of primitives.</li>
--   </ul>
module Dhall.Typed.LC
instance forall (ts :: [Dhall.Typed.LC.DSort]) (vs :: [Dhall.Typed.LC.DKind ts 'Dhall.Typed.LC.Kind]) (a :: Dhall.Typed.LC.DKind ts 'Dhall.Typed.LC.Kind). Data.Singletons.Internal.SingKind (Dhall.Typed.LC.DType ts vs a)
instance Data.Singletons.Internal.SingKind (Dhall.Typed.LC.DKind ts a)
instance Data.Singletons.Internal.SingKind Dhall.Typed.LC.DSort

module Dhall.Typed.Core

-- | Represents the possible sorts encountered in Dhall.
--   
--   Note that this implementation allows records of kinds with sorts other
--   than <a>Kind</a>, so <tt>{ foo : Kind -&gt; Kind }</tt> would
--   typecheck, even though normal Dhall forbids this.
data DSort :: Type
[Kind] :: DSort
[:*>] :: DSort -> DSort -> DSort
[KRecord] :: AggType () ls as -> DSort
[KUnion] :: AggType () ls as -> DSort

-- | Represents the possible types encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DKind</a> '[r, s] t
--   </pre>
--   
--   Describes a kind of sort <tt>t</tt> with possible kind variables of
--   sorts <tt>r</tt> and <tt>s</tt>.
--   
--   Something of type <tt><a>DKind</a> '[] t</tt> is a kind of sort
--   <tt>t</tt> with no free variables.
data DKind :: [DSort] -> DSort -> Type
[KVar] :: Index ts a -> DKind ts a
[KLam] :: SDSort t -> DKind (t : ts) a -> DKind ts (t :*> a)
[KApp] :: DKind ts (a :*> b) -> DKind ts a -> DKind ts b
[:~>] :: DKind ts  'Kind -> DKind ts  'Kind -> DKind ts  'Kind
[KPi] :: SDSort t -> DKind (t : ts) a -> DKind ts a
[Type] :: DKind ts  'Kind
infixr 1 :~>
data SomeKind :: [DSort] -> Type
[SomeKind] :: SDSort a -> DKind ts a -> SomeKind ts
type a :~> b = a :~> b
infixr 1 :~>

-- | Shift all kind variables in a kind expression of sort <tt>b</tt> to
--   account for a new bound variable of sort <tt>a</tt>, to be inserted at
--   the position indicated by the <a>Insert</a>.
type family KShift ts ps a b (ins :: Insert ts ps a) (x :: DKind ts b) :: DKind ps b
toSomeKind :: PolySingI a => DKind ts a -> SomeKind ts

-- | Represents the possible types encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DTerm</a> '[r, s] '[k, j] a
--   </pre>
--   
--   Describes a type of kind <tt>a</tt> with possible:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   </ul>
--   
--   Something of type <tt><a>DType</a> '[] '[] a</tt> is a type of kind
--   <tt>a</tt> with no free variables.
--   
--   Note that the type of "kind-polymorphic values" (functions from kinds
--   to terms) is not yet supported.
data DType ts :: [DKind ts 'Kind] -> DKind ts 'Kind -> Type
[TVar] :: Index us a -> DType ts us a
[TLam] :: SDKind ts  'Kind u -> DType ts (u : us) a -> DType ts us (u :~> a)
[TApp] :: DType ts us (a :~> b) -> DType ts us a -> DType ts us b
[TPoly] :: SingSing DSort t ( 'WS tt) -> DType (t : ts) (Map (KShiftSym ts (t : ts) t  'Kind  'InsZ) us) a -> DType ts us ( 'KPi tt a)
[TInst] :: DType ts us ( 'KPi tt b) -> SDKind ts t a -> DType ts us (KSub (t : ts) ts t  'Kind  'DelZ a b)
[:->] :: DType ts us  'Type -> DType ts us  'Type -> DType ts us  'Type
[Pi] :: SDKind ts  'Kind u -> DType ts (u : us) a -> DType ts us a
[Bool] :: DType ts us  'Type
[Natural] :: DType ts us  'Type
[List] :: DType ts us ( 'Type :~>  'Type)
[Optional] :: DType ts us ( 'Type :~>  'Type)
infixr 0 :->
infixl 9 `TApp`
data SomeType ts :: [DKind ts 'Kind] -> Type
[SomeType] :: SDKind ts  'Kind a -> DType ts us a -> SomeType ts us
type (:$) =  'TApp
infixl 9 :$
type a :-> b = a :-> b
infixr 0 :->

-- | Shift all type variables in a type expression of kind <tt>b</tt> to
--   account for a new bound variable of kind <tt>a</tt>, to be inserted at
--   the position indicated by the <a>Insert</a>.
type family Shift ts us qs a b (ins :: Insert us qs a) (x :: DType ts us b) :: DType ts qs b
toSomeType :: PolySingI a => DType ts vs a -> SomeType ts vs

-- | Primitives of Dhall terms, built into the language.
data Prim ts us :: [DType ts us 'Type] -> DType ts us 'Type -> Type
[BoolLit] :: Bool -> Prim ts us '[]  'Bool
[NaturalLit] :: Natural -> Prim ts us '[]  'Natural
[NaturalFold] :: Prim ts us '[] ( 'Natural :->  'Pi  'SType (( 'TVar  'IZ :->  'TVar  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)))
[NaturalBuild] :: Prim ts us '[] ( 'Pi  'SType (( 'TVar  'IZ :->  'TVar  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :->  'Natural)
[NaturalPlus] :: Prim ts us '[ 'Natural,  'Natural]  'Natural
[NaturalTimes] :: Prim ts us '[ 'Natural,  'Natural]  'Natural
[NaturalIsZero] :: Prim ts us '[] ( 'Natural :->  'Bool)
[ListFold] :: Prim ts us '[] ( 'Pi  'SType (( 'List :$  'TVar  'IZ) :->  'Pi  'SType (( 'TVar ( 'IS  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'TVar  'IZ :->  'TVar  'IZ))))
[ListBuild] :: Prim ts us '[] ( 'Pi  'SType ( 'Pi  'SType (( 'TVar ( 'IS  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'List :$  'TVar  'IZ)))
[ListAppend] :: SDType ts us  'Type a -> Prim ts us '[ 'List :$ a,  'List :$ a] ( 'List :$ a)
[ListHead] :: Prim ts us '[] ( 'Pi  'SType (( 'List :$  'TVar  'IZ) :-> ( 'Optional :$  'TVar  'IZ)))
[ListLast] :: Prim ts us '[] ( 'Pi  'SType (( 'List :$  'TVar  'IZ) :-> ( 'Optional :$  'TVar  'IZ)))
[ListReverse] :: Prim ts us '[] ( 'Pi  'SType (( 'List :$  'TVar  'IZ) :-> ( 'List :$  'TVar  'IZ)))
[Some] :: SDType ts us  'Type a -> Prim ts us '[a] ( 'Optional :$ a)
[None] :: Prim ts us '[] ( 'Pi  'SType ( 'Optional :$  'TVar  'IZ))

-- | Represents the possible terms encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DTerm</a> '[r, s] '[k, j] '[a, b, c] d
--   </pre>
--   
--   Describes a term of type <tt>d</tt> with possible:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   <li>Variables of type <tt>a</tt>, <tt>b</tt>, <tt>c</tt></li>
--   </ul>
--   
--   Something of type <tt><a>DTerm</a> '[] '[] '[] a</tt> is a term of
--   type <tt>a</tt> with no free variables.
--   
--   Note that "kind-polymorphic values" (functions from kinds to terms)
--   are not yet supported.
data DTerm ts (us :: [DKind ts 'Kind]) :: [DType ts us 'Type] -> DType ts us 'Type -> Type
[Var] :: Index vs a -> DTerm ts us vs a
[Lam] :: SDType ts us  'Type v -> DTerm ts us (v : vs) a -> DTerm ts us vs (v :-> a)
[App] :: DTerm ts us vs (a :-> b) -> DTerm ts us vs a -> DTerm ts us vs b
[Poly] :: SingSing (DKind ts  'Kind) u ( 'WS uu) -> DTerm ts (u : us) (Map (ShiftSym ts us (u : us) u  'Type  'InsZ) vs) a -> DTerm ts us vs ( 'Pi uu a)
[Inst] :: SingSing (DKind ts  'Kind) u ( 'WS uu) -> DTerm ts us vs ( 'Pi uu b) -> SDType ts us u a -> DTerm ts us vs (Sub ts (u : us) us u  'Type  'DelZ a b)
[P] :: Prim ts us as a -> Prod (DTerm ts us vs) as -> DTerm ts us vs a
[ListLit] :: SDType ts us  'Type a -> [DTerm ts us vs a] -> DTerm ts us vs ( 'List :$ a)
[OptionalLit] :: SDType ts us  'Type a -> Maybe (DTerm ts us vs a) -> DTerm ts us vs ( 'Optional :$ a)
data SomeTerm ts us :: [DType ts us 'Type] -> Type
[SomeTerm] :: SDType ts us  'Type a -> DTerm ts us vs a -> SomeTerm ts us vs
toSomeTerm :: PolySingI a => DTerm ts us vs a -> SomeTerm ts us vs

-- | A <a>DExpr</a> fully covers all legal type-checking dhall terms. A
--   value of type
--   
--   <pre>
--   <a>DExpr</a> '[ r, s ] '[ k, j ] '[ a, b ] n
--   </pre>
--   
--   Represents a dhall expression on level <tt>n</tt> (<tt>'FZ</tt> =
--   term, <tt>'FS 'FZ</tt> = type, etc.) with potential:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   <li>Term variables of type <tt>a</tt>, <tt>b</tt></li>
--   </ul>
--   
--   A value of type <tt><a>DExpr</a> '[] '[] '[] n</tt> represents a typed
--   dhall expression with no free variables.
--   
--   You can pattern match on it to get a value of one of the "levels" of
--   the dhall type hierarchy, and also to get the "type" and
--   representation of it.
--   
--   The number of level goes up to 4 :
--   
--   <ul>
--   <li><tt>F0</tt>: term</li>
--   <li><tt>F1</tt>: type</li>
--   <li><tt>F2</tt>: kind</li>
--   <li><tt>F3</tt>: sort</li>
--   <li><tt>F4</tt>: "meta" level, outside of the hierarchy. This is
--   necessary because the original untyped Dhall AST itself contains this
--   level.</li>
--   </ul>
--   
--   Note that you can restrict this to only <a>DExpr</a> past a given
--   "level" by asking for or returning a <tt><a>DExpr</a> ts us vs ('FS
--   n)</tt>, for instance. Such a value will only contain types, kinds,
--   sorts, or meta. A <tt><a>DExpr</a> ts us vs ('FS ('FS n))</tt> will
--   only contain kinds, sorts, or meta, etc.
data DExpr ts us :: [DType ts us 'Type] -> Fin N5 -> Type
[DEMeta] :: DExpr ts us vs F4
[DESort] :: DSort -> DExpr ts us vs F3
[DEKind] :: SomeKind ts -> DExpr ts us vs F2
[DEType] :: SomeType ts us -> DExpr ts us vs F1
[DETerm] :: SomeTerm ts us vs -> DExpr ts us vs F0

-- | Hides the "level" of a <a>DExpr</a>. Pattern match to find it. Can be
--   useful when returning a <a>DExpr</a> of level unknown until runtime,
--   or storing <a>DExpr</a> of multiple levels in a container.
data SomeDExpr ts us :: [DType ts us 'Type] -> Type
[SomeDExpr] :: DExpr ts us vs l -> SomeDExpr ts us vs

-- | Get the meta-level "type" of a <a>DExpr</a>. If it's a term, this will
--   return its type. If it's a type, this returns its type, etc. It
--   essentially goes up one "level" of the Dhall type hierarchy.
--   
--   This will not typecheck if given a "Level 4" fin, so you cannot pass
--   in <a>DEMeta</a>.
dExprType :: DExpr ts us vs n -> DExpr ts us vs (ShiftFin N5 n)
deKind :: PolySingI a => DKind ts a -> DExpr ts us vs F2
deType :: PolySingI a => DType ts us a -> DExpr ts us vs F1
deTerm :: PolySingI a => DTerm ts us vs a -> DExpr ts us vs F0

-- | Meta-level type describing a collection or aggregation of types. Used
--   for specifying records and unions. data AggType k :: [Text] -&gt; [k]
--   -&gt; Type where
data AggType k (ls :: [Text]) (as :: [k])
[ATZ] :: AggType k '[] '[]
[ATS] :: SText l -> WrappedSing k (a :: k) -> AggType k ls as -> AggType k (l : ls) (a : as)
sortOf :: DKind '[] a -> SDSort a
kindOf :: DType ts '[] a -> SDKind ts  'Kind a
typeOf :: DTerm ts us '[] a -> SDType ts us  'Type a
sortOfWith :: Prod SDSort ts -> DKind ts a -> SDSort a
kindOfWith :: Prod (SDKind ts  'Kind) us -> DType ts us a -> SDKind ts  'Kind a
typeOfWith :: Prod (SDType ts us  'Type) vs -> DTerm ts us vs a -> SDType ts us  'Type a
data SDSort (x_a1D7a :: DSort)
[SKind] :: SDSort  'Kind
[:%*>] :: forall x_a1D7b x_a1D7c. () => SDSort x_a1D7b -> SDSort x_a1D7c -> SDSort ( '(:*>) x_a1D7b x_a1D7c)
[SKRecord] :: forall (ls_X1CV7 :: [Text]) (as_X1CV9 :: [()]) x_a1D7d. () => PolySing (AggType () ls_X1CV7 as_X1CV9) x_a1D7d -> SDSort ( 'KRecord x_a1D7d)
[SKUnion] :: forall (ls_X1CV9 :: [Text]) (as_X1CVb :: [()]) x_a1D7g. () => PolySing (AggType () ls_X1CV9 as_X1CVb) x_a1D7g -> SDSort ( 'KUnion x_a1D7g)
data SDKind (a_a1Dd7 :: [DSort]) (b_a1Dd8 :: DSort) (x_a1DnI :: DKind (a_a1Dd7 :: [DSort]) (b_a1Dd8 :: DSort))
[SKVar] :: forall (ts_a1D8G :: [DSort]) (a_a1D8H :: DSort) x_a1DnJ. () => PolySing (Index ts_a1D8G a_a1D8H) x_a1DnJ -> SDKind ts_a1D8G a_a1D8H ( 'KVar x_a1DnJ)
[SKLam] :: forall (t_X1D8J :: DSort) (ts_a1D8J :: [DSort]) (a_X1D8M :: DSort) x_a1DnO x_a1DnP. () => SingSing DSort t_X1D8J ( 'WS x_a1DnO) -> SDKind ( '(:) t_X1D8J ts_a1D8J) a_X1D8M x_a1DnP -> SDKind ts_a1D8J ( '(:*>) t_X1D8J a_X1D8M) ( 'KLam x_a1DnO x_a1DnP)
[SKApp] :: forall (ts_a1D8L :: [DSort]) (a_X1D8N :: DSort) (b_a1D8N :: DSort) x_a1DnZ x_a1Do9. () => SDKind ts_a1D8L ( '(:*>) a_X1D8N b_a1D8N) x_a1DnZ -> SDKind ts_a1D8L a_X1D8N x_a1Do9 -> SDKind ts_a1D8L b_a1D8N ( 'KApp x_a1DnZ x_a1Do9)
[:%~>] :: forall (ts_a1D8O :: [DSort]) x_a1Doj x_a1Dot. () => SDKind ts_a1D8O  'Kind x_a1Doj -> SDKind ts_a1D8O  'Kind x_a1Dot -> SDKind ts_a1D8O  'Kind ( '(:~>) x_a1Doj x_a1Dot)
[SKPi] :: forall (t_X1D8Q :: DSort) (ts_a1D8Q :: [DSort]) (a_a1D8R :: DSort) x_a1DoD x_a1DoE. () => SingSing DSort t_X1D8Q ( 'WS x_a1DoD) -> SDKind ( '(:) t_X1D8Q ts_a1D8Q) a_a1D8R x_a1DoE -> SDKind ts_a1D8Q a_a1D8R ( 'KPi x_a1DoD x_a1DoE)
[SType] :: forall (ts_a1D8S :: [DSort]). () => SDKind ts_a1D8S  'Kind  'Type
data SDType (ts_a1Ds5 :: [DSort]) (a_a1DFl :: [DKind ts_a1Ds5 'Kind]) (b_a1DFm :: DKind ts_a1Ds5 'Kind) (x_a1E2e :: DType (ts_a1Ds5 :: [DSort]) (a_a1DFl :: [DKind ts_a1Ds5 'Kind]) (b_a1DFm :: DKind ts_a1Ds5 'Kind))
[STVar] :: forall (ts_a1Ds8 :: [DSort]) (us_a1Ds6 :: [DKind ts_a1Ds8  'Kind]) (a_a1Ds7 :: DKind ts_a1Ds8  'Kind) x_a1E2f. () => PolySing (Index us_a1Ds6 a_a1Ds7) x_a1E2f -> SDType ts_a1Ds8 us_a1Ds6 a_a1Ds7 ( 'TVar x_a1E2f)
[STLam] :: forall (ts_a1Ds9 :: [DSort]) (u_X1Dsb :: DKind ts_a1Ds9  'Kind) (us_a1Dsb :: [DKind ts_a1Ds9  'Kind]) (a_X1Dse :: DKind ts_a1Ds9  'Kind) x_a1E2k x_a1E2u. () => SingSing (DKind ts_a1Ds9  'Kind) u_X1Dsb ( 'WS x_a1E2k) -> SDType ts_a1Ds9 ( '(:) u_X1Dsb us_a1Dsb) a_X1Dse x_a1E2u -> SDType ts_a1Ds9 us_a1Dsb ( '(:~>) u_X1Dsb a_X1Dse) ( 'TLam x_a1E2k x_a1E2u)
[STApp] :: forall (ts_a1Dsd :: [DSort]) (us_a1Dse :: [DKind ts_a1Dsd  'Kind]) (a_X1Dsg :: DKind ts_a1Dsd  'Kind) (b_a1Dsg :: DKind ts_a1Dsd  'Kind) x_a1E2U x_a1E3k. () => SDType ts_a1Dsd us_a1Dse ( '(:~>) a_X1Dsg b_a1Dsg) x_a1E2U -> SDType ts_a1Dsd us_a1Dse a_X1Dsg x_a1E3k -> SDType ts_a1Dsd us_a1Dse b_a1Dsg ( 'TApp x_a1E2U x_a1E3k)
[STPoly] :: forall (t_X1Dsi :: DSort) (tt_X1Dsk :: SDSort t_X1Dsi) (ts_a1Dsj :: [DSort]) (us_a1Dsk :: [DKind ts_a1Dsj  'Kind]) (a_X1Dso :: DKind ( '(:) t_X1Dsi ts_a1Dsj)  'Kind) x_a1E3K x_a1E3O. () => SingSing (WrappedSing DSort t_X1Dsi) ( 'WS tt_X1Dsk) ( 'WS x_a1E3K) -> SDType ( '(:) t_X1Dsi ts_a1Dsj) (Map (KShiftSym ts_a1Dsj ( '(:) t_X1Dsi ts_a1Dsj) t_X1Dsi  'Kind ( 'InsZ :: Insert ts_a1Dsj ( '(:) t_X1Dsi ts_a1Dsj) t_X1Dsi)) us_a1Dsk) a_X1Dso x_a1E3O -> SDType ts_a1Dsj us_a1Dsk ( 'KPi tt_X1Dsk a_X1Dso) ( 'TPoly x_a1E3K x_a1E3O)
[STInst] :: forall (ts_a1Dsm :: [DSort]) (us_a1Dsn :: [DKind ts_a1Dsm  'Kind]) (t_X1Dsr :: DSort) (tt_X1Dsq :: SDSort t_X1Dsr) (b_X1Dss :: DKind ( '(:) t_X1Dsr ts_a1Dsm)  'Kind) (a_X1Dsv :: DKind ts_a1Dsm t_X1Dsr) x_a1Eiv x_a1EiV. () => SDType ts_a1Dsm us_a1Dsn ( 'KPi tt_X1Dsq b_X1Dss) x_a1Eiv -> SingSing (DKind ts_a1Dsm t_X1Dsr) a_X1Dsv ( 'WS x_a1EiV) -> SDType ts_a1Dsm us_a1Dsn (KSub ( '(:) t_X1Dsr ts_a1Dsm) ts_a1Dsm t_X1Dsr  'Kind ( 'DelZ :: Delete ( '(:) t_X1Dsr ts_a1Dsm) ts_a1Dsm t_X1Dsr) a_X1Dsv b_X1Dss) ( 'TInst x_a1Eiv x_a1EiV)
[:%->] :: forall (ts_a1Dss :: [DSort]) (us_a1Dst :: [DKind ts_a1Dss  'Kind]) x_a1Ej5 x_a1EkO. () => SDType ts_a1Dss us_a1Dst ( 'Type :: DKind ts_a1Dss  'Kind) x_a1Ej5 -> SDType ts_a1Dss us_a1Dst ( 'Type :: DKind ts_a1Dss  'Kind) x_a1EkO -> SDType ts_a1Dss us_a1Dst ( 'Type :: DKind ts_a1Dss  'Kind) ( '(:->) x_a1Ej5 x_a1EkO)
[SPi] :: forall (ts_a1Dsu :: [DSort]) (u_X1Dsw :: DKind ts_a1Dsu  'Kind) (us_a1Dsw :: [DKind ts_a1Dsu  'Kind]) (a_a1Dsx :: DKind ts_a1Dsu  'Kind) x_a1Emx x_a1EmH. () => SingSing (DKind ts_a1Dsu  'Kind) u_X1Dsw ( 'WS x_a1Emx) -> SDType ts_a1Dsu ( '(:) u_X1Dsw us_a1Dsw) a_a1Dsx x_a1EmH -> SDType ts_a1Dsu us_a1Dsw a_a1Dsx ( 'Pi x_a1Emx x_a1EmH)
[SBool] :: forall (ts_a1Dsy :: [DSort]) (us_a1Dsz :: [DKind ts_a1Dsy  'Kind]). () => SDType ts_a1Dsy us_a1Dsz ( 'Type :: DKind ts_a1Dsy  'Kind)  'Bool
[SNatural] :: forall (ts_a1DsA :: [DSort]) (us_a1DsB :: [DKind ts_a1DsA  'Kind]). () => SDType ts_a1DsA us_a1DsB ( 'Type :: DKind ts_a1DsA  'Kind)  'Natural
[SList] :: forall (ts_a1DsC :: [DSort]) (us_a1DsD :: [DKind ts_a1DsC  'Kind]). () => SDType ts_a1DsC us_a1DsD ((:~>) ( 'Type :: DKind ts_a1DsC  'Kind) ( 'Type :: DKind ts_a1DsC  'Kind))  'List
[SOptional] :: forall (ts_a1DsE :: [DSort]) (us_a1DsF :: [DKind ts_a1DsE  'Kind]). () => SDType ts_a1DsE us_a1DsF ((:~>) ( 'Type :: DKind ts_a1DsE  'Kind) ( 'Type :: DKind ts_a1DsE  'Kind))  'Optional
data SPrim (ts_a1Euh :: [DSort]) (us_a1Eui :: [DKind ts_a1Euh 'Kind]) (a_a1F1a :: [DType ts_a1Euh us_a1Eui ( 'Type :: DKind ts_a1Euh 'Kind)]) (b_a1F1b :: DType ts_a1Euh us_a1Eui ( 'Type :: DKind ts_a1Euh 'Kind)) (x_a1FOv :: Prim (ts_a1Euh :: [DSort]) (us_a1Eui :: [DKind ts_a1Euh 'Kind]) (a_a1F1a :: [DType ts_a1Euh us_a1Eui ( 'Type :: DKind ts_a1Euh 'Kind)]) (b_a1F1b :: DType ts_a1Euh us_a1Eui ( 'Type :: DKind ts_a1Euh 'Kind)))
[SBoolLit] :: forall (ts_a1Euj :: [DSort]) (us_a1Euk :: [DKind ts_a1Euj  'Kind]) x_a1FOw. () => PolySing Bool x_a1FOw -> SPrim ts_a1Euj us_a1Euk ('[] :: [DType ts_a1Euj us_a1Euk ( 'Type :: DKind ts_a1Euj  'Kind)]) ( 'Bool :: DType ts_a1Euj us_a1Euk ( 'Type :: DKind ts_a1Euj  'Kind)) ( 'BoolLit x_a1FOw)
[SNaturalLit] :: forall (ts_a1Eul :: [DSort]) (us_a1Eum :: [DKind ts_a1Eul  'Kind]) x_a1FOx. () => PolySing Natural x_a1FOx -> SPrim ts_a1Eul us_a1Eum ('[] :: [DType ts_a1Eul us_a1Eum ( 'Type :: DKind ts_a1Eul  'Kind)]) ( 'Natural :: DType ts_a1Eul us_a1Eum ( 'Type :: DKind ts_a1Eul  'Kind)) ( 'NaturalLit x_a1FOx)
[SNaturalFold] :: forall (ts_a1Eun :: [DSort]) (us_a1Euo :: [DKind ts_a1Eun  'Kind]). () => SPrim ts_a1Eun us_a1Euo ('[] :: [DType ts_a1Eun us_a1Euo ( 'Type :: DKind ts_a1Eun  'Kind)]) ((:->) ( 'Natural :: DType ts_a1Eun us_a1Euo ( 'Type :: DKind ts_a1Eun  'Kind)) ( 'Pi ( 'SType :: SDKind ts_a1Eun  'Kind ( 'Type :: DKind ts_a1Eun  'Kind)) ((:->) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eun  'Kind) us_a1Euo) ( 'Type :: DKind ts_a1Eun  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eun  'Kind) us_a1Euo) ( 'Type :: DKind ts_a1Eun  'Kind)))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eun  'Kind) us_a1Euo) ( 'Type :: DKind ts_a1Eun  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eun  'Kind) us_a1Euo) ( 'Type :: DKind ts_a1Eun  'Kind)))))))  'NaturalFold
[SNaturalBuild] :: forall (ts_a1Eup :: [DSort]) (us_a1Euq :: [DKind ts_a1Eup  'Kind]). () => SPrim ts_a1Eup us_a1Euq ('[] :: [DType ts_a1Eup us_a1Euq ( 'Type :: DKind ts_a1Eup  'Kind)]) ((:->) ( 'Pi ( 'SType :: SDKind ts_a1Eup  'Kind ( 'Type :: DKind ts_a1Eup  'Kind)) ((:->) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eup  'Kind) us_a1Euq) ( 'Type :: DKind ts_a1Eup  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eup  'Kind) us_a1Euq) ( 'Type :: DKind ts_a1Eup  'Kind)))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eup  'Kind) us_a1Euq) ( 'Type :: DKind ts_a1Eup  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eup  'Kind) us_a1Euq) ( 'Type :: DKind ts_a1Eup  'Kind)))))) ( 'Natural :: DType ts_a1Eup us_a1Euq ( 'Type :: DKind ts_a1Eup  'Kind)))  'NaturalBuild
[SNaturalPlus] :: forall (ts_a1Eur :: [DSort]) (us_a1Eus :: [DKind ts_a1Eur  'Kind]). () => SPrim ts_a1Eur us_a1Eus ( '(:) ( 'Natural :: DType ts_a1Eur us_a1Eus ( 'Type :: DKind ts_a1Eur  'Kind)) ( '(:) ( 'Natural :: DType ts_a1Eur us_a1Eus ( 'Type :: DKind ts_a1Eur  'Kind)) ('[] :: [DType ts_a1Eur us_a1Eus ( 'Type :: DKind ts_a1Eur  'Kind)]))) ( 'Natural :: DType ts_a1Eur us_a1Eus ( 'Type :: DKind ts_a1Eur  'Kind))  'NaturalPlus
[SNaturalTimes] :: forall (ts_a1Eut :: [DSort]) (us_a1Euu :: [DKind ts_a1Eut  'Kind]). () => SPrim ts_a1Eut us_a1Euu ( '(:) ( 'Natural :: DType ts_a1Eut us_a1Euu ( 'Type :: DKind ts_a1Eut  'Kind)) ( '(:) ( 'Natural :: DType ts_a1Eut us_a1Euu ( 'Type :: DKind ts_a1Eut  'Kind)) ('[] :: [DType ts_a1Eut us_a1Euu ( 'Type :: DKind ts_a1Eut  'Kind)]))) ( 'Natural :: DType ts_a1Eut us_a1Euu ( 'Type :: DKind ts_a1Eut  'Kind))  'NaturalTimes
[SNaturalIsZero] :: forall (ts_a1Euv :: [DSort]) (us_a1Euw :: [DKind ts_a1Euv  'Kind]). () => SPrim ts_a1Euv us_a1Euw ('[] :: [DType ts_a1Euv us_a1Euw ( 'Type :: DKind ts_a1Euv  'Kind)]) ((:->) ( 'Natural :: DType ts_a1Euv us_a1Euw ( 'Type :: DKind ts_a1Euv  'Kind)) ( 'Bool :: DType ts_a1Euv us_a1Euw ( 'Type :: DKind ts_a1Euv  'Kind)))  'NaturalIsZero
[SListFold] :: forall (ts_a1Eux :: [DSort]) (us_a1Euy :: [DKind ts_a1Eux  'Kind]). () => SPrim ts_a1Eux us_a1Euy ('[] :: [DType ts_a1Eux us_a1Euy ( 'Type :: DKind ts_a1Eux  'Kind)]) ( 'Pi ( 'SType :: SDKind ts_a1Eux  'Kind ( 'Type :: DKind ts_a1Eux  'Kind)) ((:->) ((:$) ( 'List :: DType ts_a1Eux ( '(:) ( 'Type :: DKind ts_a1Eux  'Kind) us_a1Euy) ((:~>) ( 'Type :: DKind ts_a1Eux  'Kind) ( 'Type :: DKind ts_a1Eux  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eux  'Kind) us_a1Euy) ( 'Type :: DKind ts_a1Eux  'Kind)))) ( 'Pi ( 'SType :: SDKind ts_a1Eux  'Kind ( 'Type :: DKind ts_a1Eux  'Kind)) ((:->) ((:->) ( 'TVar ( 'IS ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eux  'Kind) us_a1Euy) ( 'Type :: DKind ts_a1Eux  'Kind)) :: Index ( '(:) ( 'Type :: DKind ts_a1Eux  'Kind) ( '(:) ( 'Type :: DKind ts_a1Eux  'Kind) us_a1Euy)) ( 'Type :: DKind ts_a1Eux  'Kind))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eux  'Kind) ( '(:) ( 'Type :: DKind ts_a1Eux  'Kind) us_a1Euy)) ( 'Type :: DKind ts_a1Eux  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eux  'Kind) ( '(:) ( 'Type :: DKind ts_a1Eux  'Kind) us_a1Euy)) ( 'Type :: DKind ts_a1Eux  'Kind))))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eux  'Kind) ( '(:) ( 'Type :: DKind ts_a1Eux  'Kind) us_a1Euy)) ( 'Type :: DKind ts_a1Eux  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eux  'Kind) ( '(:) ( 'Type :: DKind ts_a1Eux  'Kind) us_a1Euy)) ( 'Type :: DKind ts_a1Eux  'Kind))))))))  'ListFold
[SListBuild] :: forall (ts_a1Euz :: [DSort]) (us_a1EuA :: [DKind ts_a1Euz  'Kind]). () => SPrim ts_a1Euz us_a1EuA ('[] :: [DType ts_a1Euz us_a1EuA ( 'Type :: DKind ts_a1Euz  'Kind)]) ( 'Pi ( 'SType :: SDKind ts_a1Euz  'Kind ( 'Type :: DKind ts_a1Euz  'Kind)) ((:->) ( 'Pi ( 'SType :: SDKind ts_a1Euz  'Kind ( 'Type :: DKind ts_a1Euz  'Kind)) ((:->) ((:->) ( 'TVar ( 'IS ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Euz  'Kind) us_a1EuA) ( 'Type :: DKind ts_a1Euz  'Kind)) :: Index ( '(:) ( 'Type :: DKind ts_a1Euz  'Kind) ( '(:) ( 'Type :: DKind ts_a1Euz  'Kind) us_a1EuA)) ( 'Type :: DKind ts_a1Euz  'Kind))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Euz  'Kind) ( '(:) ( 'Type :: DKind ts_a1Euz  'Kind) us_a1EuA)) ( 'Type :: DKind ts_a1Euz  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Euz  'Kind) ( '(:) ( 'Type :: DKind ts_a1Euz  'Kind) us_a1EuA)) ( 'Type :: DKind ts_a1Euz  'Kind))))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Euz  'Kind) ( '(:) ( 'Type :: DKind ts_a1Euz  'Kind) us_a1EuA)) ( 'Type :: DKind ts_a1Euz  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Euz  'Kind) ( '(:) ( 'Type :: DKind ts_a1Euz  'Kind) us_a1EuA)) ( 'Type :: DKind ts_a1Euz  'Kind)))))) ((:$) ( 'List :: DType ts_a1Euz ( '(:) ( 'Type :: DKind ts_a1Euz  'Kind) us_a1EuA) ((:~>) ( 'Type :: DKind ts_a1Euz  'Kind) ( 'Type :: DKind ts_a1Euz  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Euz  'Kind) us_a1EuA) ( 'Type :: DKind ts_a1Euz  'Kind))))))  'ListBuild
[SListAppend] :: forall (ts_a1EuB :: [DSort]) (us_a1EuC :: [DKind ts_a1EuB  'Kind]) (a_X1EuE :: DType ts_a1EuB us_a1EuC ( 'Type :: DKind ts_a1EuB  'Kind)) x_a1FOz. () => SingSing (DType ts_a1EuB us_a1EuC ( 'Type :: DKind ts_a1EuB  'Kind)) a_X1EuE ( 'WS x_a1FOz) -> SPrim ts_a1EuB us_a1EuC ( '(:) ((:$) ( 'List :: DType ts_a1EuB us_a1EuC ((:~>) ( 'Type :: DKind ts_a1EuB  'Kind) ( 'Type :: DKind ts_a1EuB  'Kind))) a_X1EuE) ( '(:) ((:$) ( 'List :: DType ts_a1EuB us_a1EuC ((:~>) ( 'Type :: DKind ts_a1EuB  'Kind) ( 'Type :: DKind ts_a1EuB  'Kind))) a_X1EuE) ('[] :: [DType ts_a1EuB us_a1EuC ( 'Type :: DKind ts_a1EuB  'Kind)]))) ((:$) ( 'List :: DType ts_a1EuB us_a1EuC ((:~>) ( 'Type :: DKind ts_a1EuB  'Kind) ( 'Type :: DKind ts_a1EuB  'Kind))) a_X1EuE) ( 'ListAppend x_a1FOz)
[SListHead] :: forall (ts_a1EuE :: [DSort]) (us_a1EuF :: [DKind ts_a1EuE  'Kind]). () => SPrim ts_a1EuE us_a1EuF ('[] :: [DType ts_a1EuE us_a1EuF ( 'Type :: DKind ts_a1EuE  'Kind)]) ( 'Pi ( 'SType :: SDKind ts_a1EuE  'Kind ( 'Type :: DKind ts_a1EuE  'Kind)) ((:->) ((:$) ( 'List :: DType ts_a1EuE ( '(:) ( 'Type :: DKind ts_a1EuE  'Kind) us_a1EuF) ((:~>) ( 'Type :: DKind ts_a1EuE  'Kind) ( 'Type :: DKind ts_a1EuE  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EuE  'Kind) us_a1EuF) ( 'Type :: DKind ts_a1EuE  'Kind)))) ((:$) ( 'Optional :: DType ts_a1EuE ( '(:) ( 'Type :: DKind ts_a1EuE  'Kind) us_a1EuF) ((:~>) ( 'Type :: DKind ts_a1EuE  'Kind) ( 'Type :: DKind ts_a1EuE  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EuE  'Kind) us_a1EuF) ( 'Type :: DKind ts_a1EuE  'Kind))))))  'ListHead
[SListLast] :: forall (ts_a1EuG :: [DSort]) (us_a1EuH :: [DKind ts_a1EuG  'Kind]). () => SPrim ts_a1EuG us_a1EuH ('[] :: [DType ts_a1EuG us_a1EuH ( 'Type :: DKind ts_a1EuG  'Kind)]) ( 'Pi ( 'SType :: SDKind ts_a1EuG  'Kind ( 'Type :: DKind ts_a1EuG  'Kind)) ((:->) ((:$) ( 'List :: DType ts_a1EuG ( '(:) ( 'Type :: DKind ts_a1EuG  'Kind) us_a1EuH) ((:~>) ( 'Type :: DKind ts_a1EuG  'Kind) ( 'Type :: DKind ts_a1EuG  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EuG  'Kind) us_a1EuH) ( 'Type :: DKind ts_a1EuG  'Kind)))) ((:$) ( 'Optional :: DType ts_a1EuG ( '(:) ( 'Type :: DKind ts_a1EuG  'Kind) us_a1EuH) ((:~>) ( 'Type :: DKind ts_a1EuG  'Kind) ( 'Type :: DKind ts_a1EuG  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EuG  'Kind) us_a1EuH) ( 'Type :: DKind ts_a1EuG  'Kind))))))  'ListLast
[SListReverse] :: forall (ts_a1EuI :: [DSort]) (us_a1EuJ :: [DKind ts_a1EuI  'Kind]). () => SPrim ts_a1EuI us_a1EuJ ('[] :: [DType ts_a1EuI us_a1EuJ ( 'Type :: DKind ts_a1EuI  'Kind)]) ( 'Pi ( 'SType :: SDKind ts_a1EuI  'Kind ( 'Type :: DKind ts_a1EuI  'Kind)) ((:->) ((:$) ( 'List :: DType ts_a1EuI ( '(:) ( 'Type :: DKind ts_a1EuI  'Kind) us_a1EuJ) ((:~>) ( 'Type :: DKind ts_a1EuI  'Kind) ( 'Type :: DKind ts_a1EuI  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EuI  'Kind) us_a1EuJ) ( 'Type :: DKind ts_a1EuI  'Kind)))) ((:$) ( 'List :: DType ts_a1EuI ( '(:) ( 'Type :: DKind ts_a1EuI  'Kind) us_a1EuJ) ((:~>) ( 'Type :: DKind ts_a1EuI  'Kind) ( 'Type :: DKind ts_a1EuI  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EuI  'Kind) us_a1EuJ) ( 'Type :: DKind ts_a1EuI  'Kind))))))  'ListReverse
[SSome] :: forall (ts_a1EuK :: [DSort]) (us_a1EuL :: [DKind ts_a1EuK  'Kind]) (a_X1EuN :: DType ts_a1EuK us_a1EuL ( 'Type :: DKind ts_a1EuK  'Kind)) x_a1FQi. () => SingSing (DType ts_a1EuK us_a1EuL ( 'Type :: DKind ts_a1EuK  'Kind)) a_X1EuN ( 'WS x_a1FQi) -> SPrim ts_a1EuK us_a1EuL ( '(:) a_X1EuN ('[] :: [DType ts_a1EuK us_a1EuL ( 'Type :: DKind ts_a1EuK  'Kind)])) ((:$) ( 'Optional :: DType ts_a1EuK us_a1EuL ((:~>) ( 'Type :: DKind ts_a1EuK  'Kind) ( 'Type :: DKind ts_a1EuK  'Kind))) a_X1EuN) ( 'Some x_a1FQi)
[SNone] :: forall (ts_a1EuN :: [DSort]) (us_a1EuO :: [DKind ts_a1EuN  'Kind]). () => SPrim ts_a1EuN us_a1EuO ('[] :: [DType ts_a1EuN us_a1EuO ( 'Type :: DKind ts_a1EuN  'Kind)]) ( 'Pi ( 'SType :: SDKind ts_a1EuN  'Kind ( 'Type :: DKind ts_a1EuN  'Kind)) ((:$) ( 'Optional :: DType ts_a1EuN ( '(:) ( 'Type :: DKind ts_a1EuN  'Kind) us_a1EuO) ((:~>) ( 'Type :: DKind ts_a1EuN  'Kind) ( 'Type :: DKind ts_a1EuN  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EuN  'Kind) us_a1EuO) ( 'Type :: DKind ts_a1EuN  'Kind)))))  'None
data SDTerm (ts_a1FYE :: [DSort]) (us_a1FYF :: [DKind ts_a1FYE 'Kind]) (a_a1Gyb :: [DType ts_a1FYE us_a1FYF ( 'Type :: DKind ts_a1FYE 'Kind)]) (b_a1Gyc :: DType ts_a1FYE us_a1FYF ( 'Type :: DKind ts_a1FYE 'Kind)) (x_a1HFf :: DTerm (ts_a1FYE :: [DSort]) (us_a1FYF :: [DKind ts_a1FYE 'Kind]) (a_a1Gyb :: [DType ts_a1FYE us_a1FYF ( 'Type :: DKind ts_a1FYE 'Kind)]) (b_a1Gyc :: DType ts_a1FYE us_a1FYF ( 'Type :: DKind ts_a1FYE 'Kind)))
[SVar] :: forall (ts_a1FYI :: [DSort]) (us_a1FYJ :: [DKind ts_a1FYI  'Kind]) (vs_a1FYG :: [DType ts_a1FYI us_a1FYJ ( 'Type :: DKind ts_a1FYI  'Kind)]) (a_a1FYH :: DType ts_a1FYI us_a1FYJ ( 'Type :: DKind ts_a1FYI  'Kind)) x_a1HFg. () => PolySing (Index vs_a1FYG a_a1FYH) x_a1HFg -> SDTerm ts_a1FYI us_a1FYJ vs_a1FYG a_a1FYH ( 'Var x_a1HFg)
[SLam] :: forall (ts_a1FYK :: [DSort]) (us_a1FYL :: [DKind ts_a1FYK  'Kind]) (v_X1FYN :: DType ts_a1FYK us_a1FYL ( 'Type :: DKind ts_a1FYK  'Kind)) (vs_a1FYN :: [DType ts_a1FYK us_a1FYL ( 'Type :: DKind ts_a1FYK  'Kind)]) (a_X1FYQ :: DType ts_a1FYK us_a1FYL ( 'Type :: DKind ts_a1FYK  'Kind)) x_a1HFl x_a1HH4. () => SingSing (DType ts_a1FYK us_a1FYL ( 'Type :: DKind ts_a1FYK  'Kind)) v_X1FYN ( 'WS x_a1HFl) -> SDTerm ts_a1FYK us_a1FYL ( '(:) v_X1FYN vs_a1FYN) a_X1FYQ x_a1HH4 -> SDTerm ts_a1FYK us_a1FYL vs_a1FYN ( '(:->) v_X1FYN a_X1FYQ) ( 'Lam x_a1HFl x_a1HH4)
[SApp] :: forall (ts_a1FYP :: [DSort]) (us_a1FYQ :: [DKind ts_a1FYP  'Kind]) (vs_a1FYR :: [DType ts_a1FYP us_a1FYQ ( 'Type :: DKind ts_a1FYP  'Kind)]) (a_X1FYT :: DType ts_a1FYP us_a1FYQ ( 'Type :: DKind ts_a1FYP  'Kind)) (b_a1FYT :: DType ts_a1FYP us_a1FYQ ( 'Type :: DKind ts_a1FYP  'Kind)) x_a1HHw x_a1HHY. () => SDTerm ts_a1FYP us_a1FYQ vs_a1FYR ( '(:->) a_X1FYT b_a1FYT) x_a1HHw -> SDTerm ts_a1FYP us_a1FYQ vs_a1FYR a_X1FYT x_a1HHY -> SDTerm ts_a1FYP us_a1FYQ vs_a1FYR b_a1FYT ( 'App x_a1HHw x_a1HHY)
[SPoly] :: forall (ts_a1FYU :: [DSort]) (u_X1FYW :: DKind ts_a1FYU  'Kind) (uu_X1FYY :: SDKind ts_a1FYU  'Kind u_X1FYW) (us_a1FYX :: [DKind ts_a1FYU  'Kind]) (vs_a1FYY :: [DType ts_a1FYU us_a1FYX ( 'Type :: DKind ts_a1FYU  'Kind)]) (a_X1FZ2 :: DType ts_a1FYU ( '(:) u_X1FYW us_a1FYX) ( 'Type :: DKind ts_a1FYU  'Kind)) x_a1HIq x_a1HJd. () => SingSing (WrappedSing (DKind ts_a1FYU  'Kind) u_X1FYW) ( 'WS uu_X1FYY) ( 'WS x_a1HIq) -> SDTerm ts_a1FYU ( '(:) u_X1FYW us_a1FYX) (Map (ShiftSym ts_a1FYU us_a1FYX ( '(:) u_X1FYW us_a1FYX) u_X1FYW ( 'Type :: DKind ts_a1FYU  'Kind) ( 'InsZ :: Insert us_a1FYX ( '(:) u_X1FYW us_a1FYX) u_X1FYW)) vs_a1FYY) a_X1FZ2 x_a1HJd -> SDTerm ts_a1FYU us_a1FYX vs_a1FYY ( 'Pi uu_X1FYY a_X1FZ2) ( 'Poly x_a1HIq x_a1HJd)
[SInst] :: forall (ts_a1FZ0 :: [DSort]) (u_X1FZ2 :: DKind ts_a1FZ0  'Kind) (uu_X1FZ4 :: SDKind ts_a1FZ0  'Kind u_X1FZ2) (us_a1FZ3 :: [DKind ts_a1FZ0  'Kind]) (vs_a1FZ4 :: [DType ts_a1FZ0 us_a1FZ3 ( 'Type :: DKind ts_a1FZ0  'Kind)]) (b_X1FZ8 :: DType ts_a1FZ0 ( '(:) u_X1FZ2 us_a1FZ3) ( 'Type :: DKind ts_a1FZ0  'Kind)) (a_X1FZa :: DType ts_a1FZ0 us_a1FZ3 u_X1FZ2) x_a1Imt x_a1Ing x_a1InI. () => SingSing (WrappedSing (DKind ts_a1FZ0  'Kind) u_X1FZ2) ( 'WS uu_X1FZ4) ( 'WS x_a1Imt) -> SDTerm ts_a1FZ0 us_a1FZ3 vs_a1FZ4 ( 'Pi uu_X1FZ4 b_X1FZ8) x_a1Ing -> SingSing (DType ts_a1FZ0 us_a1FZ3 u_X1FZ2) a_X1FZa ( 'WS x_a1InI) -> SDTerm ts_a1FZ0 us_a1FZ3 vs_a1FZ4 (Sub ts_a1FZ0 ( '(:) u_X1FZ2 us_a1FZ3) us_a1FZ3 u_X1FZ2 ( 'Type :: DKind ts_a1FZ0  'Kind) ( 'DelZ :: Delete ( '(:) u_X1FZ2 us_a1FZ3) us_a1FZ3 u_X1FZ2) a_X1FZa b_X1FZ8) ( 'Inst x_a1Imt x_a1Ing x_a1InI)
[SP] :: forall (ts_a1FZ7 :: [DSort]) (us_a1FZ8 :: [DKind ts_a1FZ7  'Kind]) (as_X1FZa :: [DType ts_a1FZ7 us_a1FZ8 ( 'Type :: DKind ts_a1FZ7  'Kind)]) (a_a1FZa :: DType ts_a1FZ7 us_a1FZ8 ( 'Type :: DKind ts_a1FZ7  'Kind)) (vs_a1FZb :: [DType ts_a1FZ7 us_a1FZ8 ( 'Type :: DKind ts_a1FZ7  'Kind)]) x_a1Io8 x_a1IoD. () => PolySing (Prim ts_a1FZ7 us_a1FZ8 as_X1FZa a_a1FZa) x_a1Io8 -> PolySing (Prod (DTerm ts_a1FZ7 us_a1FZ8 vs_a1FZb) as_X1FZa) x_a1IoD -> SDTerm ts_a1FZ7 us_a1FZ8 vs_a1FZb a_a1FZa ( 'P x_a1Io8 x_a1IoD)
[SListLit] :: forall (ts_a1FZc :: [DSort]) (us_a1FZd :: [DKind ts_a1FZc  'Kind]) (a_X1FZf :: DType ts_a1FZc us_a1FZd ( 'Type :: DKind ts_a1FZc  'Kind)) (vs_a1FZf :: [DType ts_a1FZc us_a1FZd ( 'Type :: DKind ts_a1FZc  'Kind)]) x_a1IsD x_a1Ium. () => SingSing (DType ts_a1FZc us_a1FZd ( 'Type :: DKind ts_a1FZc  'Kind)) a_X1FZf ( 'WS x_a1IsD) -> PolySing [DTerm ts_a1FZc us_a1FZd vs_a1FZf a_X1FZf] x_a1Ium -> SDTerm ts_a1FZc us_a1FZd vs_a1FZf ((:$) ( 'List :: DType ts_a1FZc us_a1FZd ((:~>) ( 'Type :: DKind ts_a1FZc  'Kind) ( 'Type :: DKind ts_a1FZc  'Kind))) a_X1FZf) ( 'ListLit x_a1IsD x_a1Ium)
[SOptionalLit] :: forall (ts_a1FZg :: [DSort]) (us_a1FZh :: [DKind ts_a1FZg  'Kind]) (a_X1FZj :: DType ts_a1FZg us_a1FZh ( 'Type :: DKind ts_a1FZg  'Kind)) (vs_a1FZj :: [DType ts_a1FZg us_a1FZh ( 'Type :: DKind ts_a1FZg  'Kind)]) x_a1IBO x_a1IDx. () => SingSing (DType ts_a1FZg us_a1FZh ( 'Type :: DKind ts_a1FZg  'Kind)) a_X1FZj ( 'WS x_a1IBO) -> PolySing (Maybe (DTerm ts_a1FZg us_a1FZh vs_a1FZj a_X1FZj)) x_a1IDx -> SDTerm ts_a1FZg us_a1FZh vs_a1FZj ((:$) ( 'Optional :: DType ts_a1FZg us_a1FZh ((:~>) ( 'Type :: DKind ts_a1FZg  'Kind) ( 'Type :: DKind ts_a1FZg  'Kind))) a_X1FZj) ( 'OptionalLit x_a1IBO x_a1IDx)
data SAggType (k_a1CP1 :: Type) (ls_a1CP2 :: [Text]) (as_a1CP3 :: [k_a1CP1]) (x_a1CU6 :: AggType (k_a1CP1 :: Type) (ls_a1CP2 :: [Text]) (as_a1CP3 :: [k_a1CP1]))
[SATZ] :: forall (k_a1CP4 :: Type). () => SAggType k_a1CP4 ('[] :: [Text]) ('[] :: [k_a1CP4])  'ATZ
[SATS] :: forall (k_a1CP5 :: Type) (l_X1CP7 :: Text) (a_X1CP9 :: k_a1CP5) (ls_X1CPb :: [Text]) (as_X1CPd :: [k_a1CP5]) x_a1CU7 x_a1CU9 x_a1CUc. () => SingSing Text l_X1CP7 ( 'WS x_a1CU7) -> PolySing (WrappedSing k_a1CP5 a_X1CP9) x_a1CU9 -> SAggType k_a1CP5 ls_X1CPb as_X1CPd x_a1CUc -> SAggType k_a1CP5 ( '(:) l_X1CP7 ls_X1CPb) ( '(:) a_X1CP9 as_X1CPd) ( 'ATS x_a1CU7 x_a1CU9 x_a1CUc)
data KShiftSym ts ps a b :: Insert ts ps a -> DKind ts b ~> DKind ps b
data ShiftSym ts us qs a b :: Insert us qs a -> DType ts us b ~> DType ts qs b
type family Map (f :: a ~> b) (xs :: [a]) :: [b]
data MapSym (f :: a ~> b) :: [a] ~> [b]

module Dhall.Typed
