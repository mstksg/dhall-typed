-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/dhall-typed#readme</a>
@package dhall-typed
@version 0.1.0.0

module Dhall.Typed.Type.Bool
type family (x :: Bool) && (y :: Bool) :: Bool

module Dhall.Typed.Type.N
data N
Z :: N
S :: N -> N

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
type SN = (Sing :: N -> Type)
fromNatural :: Natural -> N
toNatural :: N -> Natural
type ZSym0 = Z
data SSym0 :: (~>) N N
type SSym1 (t6989586621679142258 :: N) = S t6989586621679142258
data IsLength :: [k] -> N -> Type
[ILZ] :: IsLength '[]  'Z
[ILS] :: IsLength as n -> IsLength (a : as) ( 'S n)
data Fin :: N -> Type
[FZ] :: Fin ( 'S n)
[FS] :: Fin n -> Fin ( 'S n)
data SFin n :: Fin n -> Type
[SFZ] :: SFin ( 'S n)  'FZ
[SFS] :: SFin n x -> SFin ( 'S n) ( 'FS x)
type family ShiftFin n (i :: Fin n) :: Fin n
data LTE :: N -> N -> Type
[LTEZ] :: LTE  'Z m
[LTES] :: LTE n m -> LTE ( 'S n) ( 'S m)
type N0 =  'Z
type N1 =  'S N0
type N2 =  'S N1
type N3 =  'S N2
type N4 =  'S N3
type N5 =  'S N4
type F0 =  'FZ
type F1 =  'FS F0
type F2 =  'FS F1
type F3 =  'FS F2
type F4 =  'FS F3
type F5 =  'FS F4
sf0 :: SFin ( 'S n) F0
sf1 :: SFin ( 'S ( 'S n)) F1
sf2 :: SFin ( 'S ( 'S ( 'S n))) F2
sf3 :: SFin ( 'S ( 'S ( 'S ( 'S n)))) F3
sf4 :: SFin ( 'S ( 'S ( 'S ( 'S ( 'S n))))) F4
sf5 :: SFin ( 'S ( 'S ( 'S ( 'S ( 'S ( 'S n)))))) F5
instance GHC.Show.Show Dhall.Typed.Type.N.N
instance GHC.Classes.Ord Dhall.Typed.Type.N.N
instance GHC.Classes.Eq Dhall.Typed.Type.N.N
instance Data.Singletons.ShowSing.ShowSing Dhall.Typed.Type.N.N => GHC.Show.Show (Data.Singletons.Internal.Sing z)
instance Data.Singletons.Prelude.Eq.PEq Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.ShowsPrec_6989586621679147767Sym0
instance Data.Singletons.Prelude.Show.PShow Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.ShowsPrec_6989586621679147767Sym1 a6989586621679147764)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.ShowsPrec_6989586621679147767Sym2 a6989586621679147765 a6989586621679147764)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.Compare_6989586621679144223Sym0
instance Data.Singletons.Prelude.Ord.POrd Dhall.Typed.Type.N.N
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings (Dhall.Typed.Type.N.Compare_6989586621679144223Sym1 a6989586621679144221)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Dhall.Typed.Type.N.SSym0
instance Data.Singletons.Internal.SingI Dhall.Typed.Type.N.SSym0
instance Data.Singletons.Internal.SingKind Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Ord.SOrd Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Ord.SOrd Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Show.SShow Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Show.SShow Dhall.Typed.Type.N.N
instance Data.Singletons.Prelude.Eq.SEq Dhall.Typed.Type.N.N => Data.Singletons.Prelude.Eq.SEq Dhall.Typed.Type.N.N
instance Data.Singletons.Decide.SDecide Dhall.Typed.Type.N.N => Data.Singletons.Decide.SDecide Dhall.Typed.Type.N.N
instance Data.Singletons.Internal.SingI 'Dhall.Typed.Type.N.Z
instance Data.Singletons.Internal.SingI n => Data.Singletons.Internal.SingI ('Dhall.Typed.Type.N.S n)
instance Data.Singletons.Internal.SingI (Data.Singletons.Internal.TyCon1 'Dhall.Typed.Type.N.S)

module Dhall.Typed.Plugin
plugin :: Plugin

module Dhall.Typed.Type.Option
data Option :: (k -> Type) -> Maybe k -> Type
[Noot] :: Option f  'Nothing
[Juus] :: f a -> Option f ( 'Just a)

module Dhall.Typed.Type.Singletons.TH
genPolySing :: DsMonad q => Name -> q [Dec]
genPolySingWith :: DsMonad q => GenPolySingOpts -> Name -> q [Dec]
data GenPolySingOpts
GPSO :: !Bool -> !Bool -> !GenOpts -> !GenOpts -> GenPolySingOpts
[gpsoSing] :: GenPolySingOpts -> !Bool
[gpsoSingI] :: GenPolySingOpts -> !Bool
[gpsoPSK] :: GenPolySingOpts -> !GenOpts
[gpsoSingEq] :: GenPolySingOpts -> !GenOpts
defaultGPSO :: GenPolySingOpts
data GenOpts
GOInfer :: GenOpts
GOSkip :: GenOpts
GOHead :: Q [Dec] -> GenOpts
genPolySingKind :: forall q. DsMonad q => q [Dec] -> q [Dec]
genSingEq :: forall q. DsMonad q => q [Dec] -> q [Dec]
instance GHC.Base.Functor Dhall.Typed.Type.Singletons.TH.V2
instance GHC.Base.Applicative Dhall.Typed.Type.Singletons.TH.V2
instance GHC.Base.Monad Dhall.Typed.Type.Singletons.TH.V2
instance Data.Default.Class.Default Dhall.Typed.Type.Singletons.TH.GenPolySingOpts

module Dhall.Typed.Type.Singletons
type family PolySing k = (s :: k -> Type) | s -> k
class PolySingI (x :: k)
polySing :: PolySingI x => PolySing k x
class PolySingKind k
fromPolySing :: PolySingKind k => PolySing k x -> k
toPolySing :: PolySingKind k => k -> SomePolySing k
data SomePolySing k
[SomePS] :: PolySing k x -> SomePolySing k
newtype WrappedSing k (x :: k)
WS :: PolySing k x -> WrappedSing k
[getWS] :: WrappedSing k -> PolySing k x
newtype SingSing k x :: WrappedSing k x -> Type
[SiSi] :: forall k x (ws :: WrappedSing k x). () => {getSiSi :: PolySing k x} -> SingSing k x ws
type PolySingOfI (x :: PolySing k y) = PolySingI y
class SingEq f g
singEq :: forall x y. SingEq f g => PolySing f x -> PolySing g y -> Decision (x :~~: y)
data SConst (a_ayzS :: Type) (b_ayzT :: k_ayzR) (x_a1tkq :: Const (a_ayzS :: Type) (b_ayzT :: k_ayzR))
[SConst] :: forall (a_ayzS :: Type) (b_ayzT :: k_ayzR) x_a1tkr. () => {sGetConst :: PolySing a_ayzS x_a1tkr} -> SConst (a_ayzS :: Type) (b_ayzT :: k_ayzR) ( 'Const x_a1tkr)
data SMaybe (a_11 :: Type) (x_a1tqh :: Maybe (a_11 :: Type))
[SNothing] :: forall (a_11 :: Type). () => SMaybe (a_11 :: Type)  'Nothing
[SJust] :: forall (a_11 :: Type) x_a1tqi. () => PolySing a_11 x_a1tqi -> SMaybe (a_11 :: Type) ( 'Just x_a1tqi)
data SList k :: [k] -> Type
[:%] :: PolySing k x -> SList k xs -> SList k (x : xs)
[SNil] :: SList k '[]
infixr 5 :%
data STup2 a b :: (a, b) -> Type
[STup2] :: PolySing a x -> PolySing b y -> STup2 a b '(x, y)
data SBool :: Bool -> Type
[SFalse] :: SBool  'False
[STrue] :: SBool  'True
data SProxy (t_a1jzr :: k_a1jzq) (x_a1tuJ :: Proxy (t_a1jzr :: k_a1jzq))
[SProxy] :: forall (t_a1jzr :: k_a1jzq). () => SProxy (t_a1jzr :: k_a1jzq)  'Proxy
data STup0 :: () -> Type
[STup0] :: STup0  '()
type family ToNat (n :: Natural) = (m :: Nat) | m -> n
type family FromNat (m :: Nat) = (n :: Natural) | n -> m
data SNatural :: Natural -> Type
[SNat] :: KnownNat (ToNat n) => SNatural n
withKnownNatural :: forall n r. KnownNat n => (KnownNat (ToNat (FromNat n)) => r) -> r
type family ToSym (t :: Text) = (s :: Symbol) | s -> t
type family FromSym (s :: Symbol) = (t :: Text) | t -> s
data SText :: Text -> Type
[SText] :: KnownSymbol (ToSym t) => SText t
withKnownText :: forall n r. KnownSymbol n => (KnownSymbol (ToSym (FromSym n)) => r) -> r
instance GHC.TypeLits.KnownSymbol (Dhall.Typed.Type.Singletons.ToSym t) => Dhall.Typed.Type.Singletons.Internal.PolySingI t
instance Dhall.Typed.Type.Singletons.Internal.PolySingKind Data.Text.Internal.Text
instance Dhall.Typed.Type.Singletons.Internal.SingEq Data.Text.Internal.Text Data.Text.Internal.Text
instance GHC.TypeNats.KnownNat (Dhall.Typed.Type.Singletons.ToNat n) => Dhall.Typed.Type.Singletons.Internal.PolySingI n
instance Dhall.Typed.Type.Singletons.Internal.PolySingKind GHC.Natural.Natural
instance Dhall.Typed.Type.Singletons.Internal.SingEq GHC.Natural.Natural GHC.Natural.Natural
instance forall k (t :: k). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Data.Proxy.Proxy
instance forall k (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Proxy.Proxy a)
instance forall k (a :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Proxy.Proxy a) (Data.Proxy.Proxy a)
instance Dhall.Typed.Type.Singletons.Internal.PolySingI 'GHC.Maybe.Nothing
instance forall a (x :: a). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('GHC.Maybe.Just x)
instance Dhall.Typed.Type.Singletons.Internal.PolySingKind a => Dhall.Typed.Type.Singletons.Internal.PolySingKind (GHC.Maybe.Maybe a)
instance Dhall.Typed.Type.Singletons.Internal.SingEq a a => Dhall.Typed.Type.Singletons.Internal.SingEq (GHC.Maybe.Maybe a) (GHC.Maybe.Maybe a)
instance forall k (b :: k) a (x :: a). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Data.Functor.Const.Const x)
instance forall k a (b :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind a => Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Functor.Const.Const a b)
instance forall k a b (c :: k). Dhall.Typed.Type.Singletons.Internal.SingEq a b => Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Functor.Const.Const a c) (Data.Functor.Const.Const b c)

module Dhall.Typed.Type.Index

-- | Witness an item in a type-level list by providing its index.
data Index (a :: [k]) (b :: k) :: forall k. () => [k] -> k -> Type
[IZ] :: forall k (a :: [k]) (b :: k) (as :: [k]). () => Index (b : as) b
[IS] :: forall k (a :: [k]) (b :: k) (bs :: [k]) (b1 :: k). () => Index bs b -> Index (b1 : bs) b
data SIndex (a_a1wOF :: [k_a1wOE]) (b_a1wOG :: k_a1wOE) (x_a1wOU :: Index (a_a1wOF :: [k_a1wOE]) (b_a1wOG :: k_a1wOE))
[SIZ] :: forall (k_a1wOE :: Type) (b_a1wOG :: k_a1wOE) (as_a1wOH :: [k_a1wOE]). () => SIndex ( '(:) b_a1wOG as_a1wOH) b_a1wOG  'IZ
[SIS] :: forall (k_a1wOE :: Type) (bs_a1wOK :: [k_a1wOE]) (b_a1wOG :: k_a1wOE) (b1_a1wOL :: k_a1wOE) x_a1wOV. () => SIndex bs_a1wOK b_a1wOG x_a1wOV -> SIndex ( '(:) b1_a1wOL bs_a1wOK) b_a1wOG ( 'IS x_a1wOV)
sSameIx :: SIndex as a i -> SIndex as a j -> Maybe (i :~: j)
fromSIndex :: SIndex as a i -> Index as a
data SSIndex (a_a1wOF :: [k_a1wOE]) (b_a1wOG :: k_a1wOE) (x_a1wOU :: Index a_a1wOF b_a1wOG) (x_a1wVN :: SIndex (a_a1wOF :: [k_a1wOE]) (b_a1wOG :: k_a1wOE) (x_a1wOU :: Index a_a1wOF b_a1wOG))
[SSIZ] :: forall (k_a1wOE :: Type) (b_a1wOG :: k_a1wOE) (as_X1wOI :: [k_a1wOE]). () => SSIndex ( '(:) b_a1wOG as_X1wOI) b_a1wOG ( 'IZ :: Index ( '(:) b_a1wOG as_X1wOI) b_a1wOG)  'SIZ
[SSIS] :: forall (k_a1wOE :: Type) (bs_X1wOL :: [k_a1wOE]) (b_a1wOG :: k_a1wOE) (b1_X1wON :: k_a1wOE) (x_X1wOY :: Index bs_X1wOL b_a1wOG) x_a1wVO. () => SingSing (Index bs_X1wOL b_a1wOG) x_X1wOY ( 'WS x_a1wVO) -> SSIndex ( '(:) b1_X1wON bs_X1wOL) b_a1wOG ( 'IS x_X1wOY :: Index ( '(:) b1_X1wON bs_X1wOL) b_a1wOG) ( 'SIS x_a1wVO)
indexN :: Index as a -> N
data Delete :: [k] -> [k] -> k -> Type
[DelZ] :: Delete (a : as) as a
[DelS] :: Delete as bs c -> Delete (a : as) (a : bs) c
del :: Delete as bs a -> Index as b -> Maybe (Index bs b)
type family ISMaybe (i :: Maybe (Index as a)) :: Maybe (Index (b : as) a)
type family Del as bs a b (d :: Delete as bs a) (i :: Index as b) :: Maybe (Index bs b)
data SDelete (a_a1x3Q :: [k_a1wWy]) (b_a1x3R :: [k_a1wWy]) (c_a1x3S :: k_a1wWy) (x_a1x9z :: Delete (a_a1x3Q :: [k_a1wWy]) (b_a1x3R :: [k_a1wWy]) (c_a1x3S :: k_a1wWy))
[SDelZ] :: forall (k_a1x3q :: Type) (a_a1wWz :: k_a1x3q) (as_a1wWA :: [k_a1x3q]). () => SDelete ( '(:) a_a1wWz as_a1wWA) as_a1wWA a_a1wWz  'DelZ
[SDelS] :: forall (a_a1x3H :: Type) (as_X1wWC :: [a_a1x3H]) (bs_X1wWE :: [a_a1x3H]) (c_a1wWD :: a_a1x3H) (a_X1wWH :: a_a1x3H) x_a1x9A. () => SDelete as_X1wWC bs_X1wWE c_a1wWD x_a1x9A -> SDelete ( '(:) a_X1wWH as_X1wWC) ( '(:) a_X1wWH bs_X1wWE) c_a1wWD ( 'DelS x_a1x9A)
sDel :: SDelete as bs a del -> SIndex as b i -> GetDeleted as bs a b del i
data GetDeleted as bs a b :: Delete as bs a -> Index as b -> Type
[GotDeleted] :: Del as bs a b del i ~  'Nothing => (a :~: b) -> GetDeleted as bs a b del i
[ThatsToxic] :: Del as bs a b del i ~  'Just j => SIndex bs b j -> GetDeleted as bs a b del i

-- | This is just flipped delete, heh.
data Insert :: [k] -> [k] -> k -> Type
[InsZ] :: Insert as (a : as) a
[InsS] :: Insert as bs c -> Insert (a : as) (a : bs) c
insert :: Insert as bs a -> Index as b -> Index bs b
type family Ins as bs a b (ins :: Insert as bs a) (i :: Index as b) :: Index bs b
sIns :: forall as bs a b ins i. () => SInsert as bs a ins -> SIndex as b i -> SIndex bs b (Ins as bs a b ins i)
data SInsert (a_a1xn4 :: [k_a1xad]) (b_a1xn5 :: [k_a1xad]) (c_a1xn6 :: k_a1xad) (x_a1xsC :: Insert (a_a1xn4 :: [k_a1xad]) (b_a1xn5 :: [k_a1xad]) (c_a1xn6 :: k_a1xad))
[SInsZ] :: forall (a_a1xmF :: Type) (as_a1xae :: [a_a1xmF]) (a_a1xaf :: a_a1xmF). () => SInsert as_a1xae ( '(:) a_a1xaf as_a1xae) a_a1xaf  'InsZ
[SInsS] :: forall (a_a1xmV :: Type) (as_X1xah :: [a_a1xmV]) (bs_X1xaj :: [a_a1xmV]) (c_a1xai :: a_a1xmV) (a_X1xam :: a_a1xmV) x_a1xsD. () => SInsert as_X1xah bs_X1xaj c_a1xai x_a1xsD -> SInsert ( '(:) a_X1xam as_X1xah) ( '(:) a_X1xam bs_X1xaj) c_a1xai ( 'InsS x_a1xsD)

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
instance forall a1 (as :: [a1]) (a2 :: a1). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Index.InsZ
instance forall a1 (a2 :: a1) (as :: [a1]) (bs :: [a1]) (c :: a1) (x :: Dhall.Typed.Type.Index.Insert as bs c). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Index.InsS x)
instance forall k (a :: [k]) (b :: [k]) (c :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Index.Insert a b c)
instance forall k (a1 :: [k]) (a2 :: [k]) (a3 :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Index.Insert a1 a2 a3) (Dhall.Typed.Type.Index.Insert a1 a2 b)
instance forall k (a :: k) (as :: [k]). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Index.DelZ
instance forall a1 (a2 :: a1) (as :: [a1]) (bs :: [a1]) (c :: a1) (x :: Dhall.Typed.Type.Index.Delete as bs c). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Index.DelS x)
instance forall k (a :: [k]) (b :: [k]) (c :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Index.Delete a b c)
instance forall k (a1 :: [k]) (a2 :: [k]) (a3 :: k) (b1 :: [k]) (b2 :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Index.Delete a1 a2 a3) (Dhall.Typed.Type.Index.Delete a1 b1 b2)
instance forall k (as :: [k]) (a :: k) (i :: Data.Type.Universe.Index as a). GHC.Show.Show (Dhall.Typed.Type.Index.SIndex as a i)
instance forall k (b :: k) (as :: [k]). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Index.SIZ
instance forall k (b1 :: k) (bs :: [k]) (b :: k) (y :: Data.Type.Universe.Index bs b) (x :: Dhall.Typed.Type.Index.SIndex bs b y). Dhall.Typed.Type.Singletons.Internal.PolySingOfI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Index.SIS x)
instance forall k (as :: [k]) (a :: k) (x :: Data.Type.Universe.Index as a). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Index.SIndex as a x)
instance forall k (as :: [k]) (a :: k) (x :: Data.Type.Universe.Index as a) (b :: k) (y :: Data.Type.Universe.Index as b). Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Index.SIndex as a x) (Dhall.Typed.Type.Index.SIndex as b y)
instance forall k (as :: [k]) (a :: k). Data.Singletons.Internal.SingKind (Data.Type.Universe.Index as a)
instance forall k (b :: k) (as :: [k]). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Data.Type.Universe.IZ
instance forall k (b1 :: k) (bs :: [k]) (b :: k) (x :: Data.Type.Universe.Index bs b). Dhall.Typed.Type.Singletons.Internal.PolySingI x => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Data.Type.Universe.IS x)
instance forall k (as :: [k]) (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (Data.Type.Universe.Index as a)
instance forall k (as :: [k]) (a :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (Data.Type.Universe.Index as a) (Data.Type.Universe.Index as b)

module Dhall.Typed.Type.Prod
data Prod :: (k -> Type) -> [k] -> Type
[Ø] :: Prod f '[]
[:<] :: f a -> Prod f as -> Prod f (a : as)
infixr 5 :<
traverseProd :: forall f g h as. Applicative h => (forall x. f x -> h (g x)) -> Prod f as -> h (Prod g as)
mapProd :: forall f g as. () => (forall x. f x -> g x) -> Prod f as -> Prod g as
zipProd :: Prod f as -> Prod g as -> Prod (f :*: g) as
singProd :: SList k as -> Prod (PolySing k) as
prodSing :: Prod (PolySing k) as -> SList k as
ixProd :: Prod f as -> Index as a -> f a
data SeqListEq :: Seq a -> [a] -> Type
[SeqListEq] :: SeqListEq xs ys
type family IxProd f as b (p :: Prod f as) (i :: Index as b) :: f b
data SProd (a_a1ySb :: k_a1yRj -> Type) (b_a1ySc :: [k_a1yRj]) (x_a1yV2 :: Prod (a_a1ySb :: k_a1yRj -> Type) (b_a1ySc :: [k_a1yRj]))
[SØ] :: forall (k_a1yRK :: Type) (f_a1yRk :: k_a1yRK -> Type). () => SProd f_a1yRk ('[] :: [k_a1yRK])  'Ø
[:%<] :: forall (a_a1yS2 :: Type) (f_a1yRl :: a_a1yS2 -> Type) (a_X1yRn :: a_a1yS2) (as_X1yRp :: [a_a1yS2]) x_a1yV3 x_a1yV4. () => PolySing (f_a1yRl a_X1yRn) x_a1yV3 -> SProd f_a1yRl as_X1yRp x_a1yV4 -> SProd f_a1yRl ( '(:) a_X1yRn as_X1yRp) ( '(:<) x_a1yV3 x_a1yV4)
sIxProd :: SProd f as xs -> SIndex as a i -> PolySing (f a) (IxProd f as a xs i)
type family ProdList (xs :: Prod (Const k) ys) :: [k]
data BiProd :: (k -> Type) -> (j -> Type) -> [k] -> [j] -> Type
[BZ] :: BiProd f g '[] '[]
[BS] :: f a -> g b -> BiProd f g as bs -> BiProd f g (a : as) (b : bs)
data SBiProd (a_a1z1E :: k_a1yVT -> Type) (b_a1z1F :: j_a1yVU -> Type) (c_a1z1G :: [k_a1yVT]) (d_a1z1H :: [j_a1yVU]) (x_a1z79 :: BiProd (a_a1z1E :: k_a1yVT -> Type) (b_a1z1F :: j_a1yVU -> Type) (c_a1z1G :: [k_a1yVT]) (d_a1z1H :: [j_a1yVU]))
[SBZ] :: forall (k_a1z12 :: Type) (j_a1z13 :: Type) (f_a1yVV :: k_a1z12 -> Type) (g_a1yVW :: j_a1z13 -> Type). () => SBiProd f_a1yVV g_a1yVW ('[] :: [k_a1z12]) ('[] :: [j_a1z13])  'BZ
[SBS] :: forall (a_a1z1u :: Type) (a_a1z1v :: Type) (f_a1yVX :: a_a1z1u -> Type) (a_X1yVZ :: a_a1z1u) (g_a1yVZ :: a_a1z1v -> Type) (b_X1yW2 :: a_a1z1v) (as_X1yW4 :: [a_a1z1u]) (bs_X1yW6 :: [a_a1z1v]) x_a1z7a x_a1z7b x_a1z7c. () => PolySing (f_a1yVX a_X1yVZ) x_a1z7a -> PolySing (g_a1yVZ b_X1yW2) x_a1z7b -> SBiProd f_a1yVX g_a1yVZ as_X1yW4 bs_X1yW6 x_a1z7c -> SBiProd f_a1yVX g_a1yVZ ( '(:) a_X1yVZ as_X1yW4) ( '(:) b_X1yW2 bs_X1yW6) ( 'BS x_a1z7a x_a1z7b x_a1z7c)
instance forall k (f :: k -> *) j (g :: j -> *). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Prod.BZ
instance forall a1 (as :: [a1]) a2 (bs :: [a2]) (g :: a2 -> *) (b :: a2) (f :: a1 -> *) (a3 :: a1) (x1 :: f a3) (x2 :: g b) (x3 :: Dhall.Typed.Type.Prod.BiProd f g as bs). (Dhall.Typed.Type.Singletons.Internal.PolySingI x1, Dhall.Typed.Type.Singletons.Internal.PolySingI x2, Dhall.Typed.Type.Singletons.Internal.PolySingI x3) => Dhall.Typed.Type.Singletons.Internal.PolySingI ('Dhall.Typed.Type.Prod.BS x1 x2 x3)
instance forall j k (f :: k -> *) (g :: j -> *) (as :: [k]) (bs :: [j]). (forall (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (f a), forall (a :: j). Dhall.Typed.Type.Singletons.Internal.PolySingKind (g a)) => Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Prod.BiProd f g as bs)
instance forall j k (f :: k -> *) (g :: j -> *) (as :: [k]) (bs :: [j]) (cs :: [k]) (ds :: [j]). (forall (a :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (f a) (f b), forall (a :: j) (b :: j). Dhall.Typed.Type.Singletons.Internal.SingEq (g a) (g b)) => Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Prod.BiProd f g as bs) (Dhall.Typed.Type.Prod.BiProd f g cs ds)
instance forall k (f :: k -> *). Dhall.Typed.Type.Singletons.Internal.PolySingI 'Dhall.Typed.Type.Prod.Ø
instance forall a1 (as :: [a1]) (f :: a1 -> *) (a2 :: a1) (x1 :: f a2) (x2 :: Dhall.Typed.Type.Prod.Prod f as). (Dhall.Typed.Type.Singletons.Internal.PolySingI x1, Dhall.Typed.Type.Singletons.Internal.PolySingI x2) => Dhall.Typed.Type.Singletons.Internal.PolySingI (x1 'Dhall.Typed.Type.Prod.:< x2)
instance forall k (f :: k -> *) (as :: [k]). (forall (a :: k). Dhall.Typed.Type.Singletons.Internal.PolySingKind (f a)) => Dhall.Typed.Type.Singletons.Internal.PolySingKind (Dhall.Typed.Type.Prod.Prod f as)
instance forall k (f :: k -> *) (as :: [k]) (bs :: [k]). (forall (a :: k) (b :: k). Dhall.Typed.Type.Singletons.Internal.SingEq (f a) (f b)) => Dhall.Typed.Type.Singletons.Internal.SingEq (Dhall.Typed.Type.Prod.Prod f as) (Dhall.Typed.Type.Prod.Prod f bs)


-- | Implementing a typed lambda calculus. Uses De Bruijn indices in
--   separate namespaces (that is, kind, type, term variables all have
--   their own separate De Bruijn indexing)
--   
--   We have a hierarchy: Term -&gt; Type -&gt; Kind -&gt; Sort. We can
--   stop at Sort because we don't allow any Sort variables, so there is no
--   need to talk about the "type" of any Sorts. Disallowing variables
--   effectively stops the chain.
--   
--   It looks like each level has some sets of constructors just from its
--   position on the chain.
--   
--   <ul>
--   <li>At all levels, we have <i>primitives</i>. Term-level primitives
--   are built-in functions and values and literals. Type-level primitives
--   are built-in types and type functions. Dhall has no kind- or
--   sort-level primitives.</li>
--   <li>If a level has variables (Terms, Types, Kinds), we gain some
--   constructors:<ul><li>Var, the variable constructor j Lam, the function
--   abstraction</li><li>App, the function application</li></ul></li>
--   <li>If a level has variables and its "type" also has variables (Terms,
--   Types), we gain some constructors:<ul><li>Poly, the type
--   abstraction</li><li>Inst (instantiation), the type
--   application</li></ul></li>
--   <li>If a level is the "type" of something (n &gt;= 1), we gain a
--   function type constructor, the type of function abstractions in the
--   immediately lower level.</li>
--   <li>If a level is the "type" of a "type" of something (n &gt;= 2), we
--   gain an "constant" constructor that links the two layers below it
--   together. Examples are the Kind sort that links Kinds to Types (all
--   types have kinds of sort Kind), and the Type kind that links types to
--   values (all terms have types of kind Type)</li>
--   <li>If a type is the "type" of something (n &gt;= 1), <i>and</i> it
--   has variables, we have a Pi type constructor, the type of type
--   abstractions (type-polymorphic values) in the lower level.</li>
--   </ul>
--   
--   We actually gain a Pi type for our current level, and each level above
--   our current level (that has variables). So for the Type level, we have
--   Type-Pi and Kind-Pi, and for the Kind level, we have Kind-Pi.
--   
--   So to summarize:
--   
--   <ul>
--   <li>n = 3: Sort has a constant (it is n &gt;= 2) and a function type
--   constructor (it is n &gt;= 1). It could also potentially have
--   primitives, but Dhall has no sort primitives.</li>
--   <li>n = 2: Kind has variables, so it has Var, Lam, and App. It has a
--   constant (they are n &gt;= 2) and a function type constructor and a Pi
--   constructor (it is n &gt;= 1 and has variables). It could also
--   potentially have primitives; Dhall has only record and union kinds as
--   primitives.</li>
--   <li>n = 1: Type has variables, so it has Var, Lam, and App. It has a
--   function type constructor and a Pi constructor (it is n &gt;= 1 and
--   has variables). Because its "type" has variables (Kind), it also has
--   Poly and Inst. It has primitives, and in Dhall ther are several.</li>
--   <li>n = 0: Term has variables, so it has Var, Lam, and App. Because
--   its "type" has variables, it has Poly and Inst. In Dhall, it has
--   multitudes of primitives.</li>
--   </ul>
module Dhall.Typed.LC
instance forall (ts :: [Dhall.Typed.LC.DSort]) (vs :: [Dhall.Typed.LC.DKind ts 'Dhall.Typed.LC.Kind]) (a :: Dhall.Typed.LC.DKind ts 'Dhall.Typed.LC.Kind). Data.Singletons.Internal.SingKind (Dhall.Typed.LC.DType ts vs a)
instance Data.Singletons.Internal.SingKind (Dhall.Typed.LC.DKind ts a)
instance Data.Singletons.Internal.SingKind Dhall.Typed.LC.DSort

module Dhall.Typed.Core

-- | Represents the possible sorts encountered in Dhall.
--   
--   Note that this implementation allows records of kinds with sorts other
--   than <a>Kind</a>, so <tt>{ foo : Kind -&gt; Kind }</tt> would
--   typecheck, even though normal Dhall forbids this.
--   
--   A <a>DSort</a> is always in normal form.
data DSort :: Type
[Kind] :: DSort
[:*>] :: DSort -> DSort -> DSort
[KRecord] :: AggType () ls as -> DSort
[KUnion] :: AggType () ls as -> DSort

-- | Represents the possible types encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DKind</a> '[r, s] t
--   </pre>
--   
--   Describes a kind of sort <tt>t</tt> with possible kind variables of
--   sorts <tt>r</tt> and <tt>s</tt>.
--   
--   Something of type <tt><a>DKind</a> '[] t</tt> is a kind of sort
--   <tt>t</tt> with no free variables.
data DKind :: [DSort] -> DSort -> Type
[KVar] :: Index ts a -> DKind ts a
[KLam] :: SDSort t -> DKind (t : ts) a -> DKind ts (t :*> a)
[KApp] :: DKind ts (a :*> b) -> DKind ts a -> DKind ts b
[:~>] :: DKind ts  'Kind -> DKind ts  'Kind -> DKind ts  'Kind
[KPi] :: SDSort t -> DKind (t : ts) a -> DKind ts a
[Type] :: DKind ts  'Kind
infixr 1 :~>
data SomeKind :: [DSort] -> Type
[SomeKind] :: SDSort a -> DKind ts a -> SomeKind ts
type a :~> b = a :~> b
infixr 1 :~>

-- | Shift all kind variables in a kind expression of sort <tt>b</tt> to
--   account for a new bound variable of sort <tt>a</tt>, to be inserted at
--   the position indicated by the <a>Insert</a>.
type family KShift ts ps a b (ins :: Insert ts ps a) (x :: DKind ts b) :: DKind ps b
toSomeKind :: PolySingI a => DKind ts a -> SomeKind ts

-- | Ideally we would want this to be encodable within the type. But the
--   main problem here is checking if the LHS of an application is a
--   variable or not. This is the next best thing?
type family KNormalize ts a (x :: DKind ts a) :: DKind ts a

-- | Version of <a>SDKind</a> that exposes itself in normal form.
data NDKind ts a :: DKind ts a -> Type
[NDK] :: SDKind ts a x -> NDKind ts a (KNormalize ts a x)

-- | Represents the possible types encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DTerm</a> '[r, s] '[k, j] a
--   </pre>
--   
--   Describes a type of kind <tt>a</tt> with possible:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   </ul>
--   
--   Something of type <tt><a>DType</a> '[] '[] a</tt> is a type of kind
--   <tt>a</tt> with no free variables.
--   
--   Note that the type of "kind-polymorphic values" (functions from kinds
--   to terms) is not yet supported.
--   
--   The kinds of the type variables should all be normalized. All
--   constructors that introduce type variables should normalize
--   automatically, but it's possible create nonsensical types with
--   <a>TVar</a>.
data DType ts :: [DKind ts 'Kind] -> DKind ts 'Kind -> Type
[TVar] :: Index us a -> DType ts us a
[TLam] :: NDKind ts  'Kind u -> DType ts (u : us) a -> DType ts us (u :~> a)
[TApp] :: DType ts us (a :~> b) -> DType ts us a -> DType ts us b
[TPoly] :: SingSing DSort t ( 'WS tt) -> DType (t : ts) (Map (KShiftSym ts (t : ts) t  'Kind  'InsZ) us) a -> DType ts us ( 'KPi tt a)
[TInst] :: DType ts us ( 'KPi tt b) -> SDKind ts t a -> DType ts us (KSub (t : ts) ts t  'Kind  'DelZ a b)
[:->] :: DType ts us  'Type -> DType ts us  'Type -> DType ts us  'Type
[Pi] :: NDKind ts  'Kind u -> DType ts (u : us) a -> DType ts us a
[Bool] :: DType ts us  'Type
[Natural] :: DType ts us  'Type
[List] :: DType ts us ( 'Type :~>  'Type)
[Optional] :: DType ts us ( 'Type :~>  'Type)
infixr 0 :->
infixl 9 `TApp`
data SomeType ts :: [DKind ts 'Kind] -> Type
[SomeType] :: NDKind ts  'Kind a -> DType ts us a -> SomeType ts us
type (:$) =  'TApp
infixl 9 :$
type a :-> b = a :-> b
infixr 0 :->

-- | Shift all type variables in a type expression of kind <tt>b</tt> to
--   account for a new bound variable of kind <tt>a</tt>, to be inserted at
--   the position indicated by the <a>Insert</a>.
type family Shift ts us qs a b (ins :: Insert us qs a) (x :: DType ts us b) :: DType ts qs b
toSomeType :: forall ts us a. (PolySingI a, KNormalize ts  'Kind a ~ a) => DType ts us a -> SomeType ts us

-- | Ideally we would want this to be encodable within the type. But the
--   main problem here is checking if the LHS of an application is a
--   variable or not. This is the next best thing?
type family TNormalize ts us a (x :: DType ts us a) :: DType ts us a

-- | Version of <a>SDType</a> that exposes itself in normal form.
data NDType ts us a :: DType ts us a -> Type
[NDT] :: SDType ts us a x -> NDType ts us a (TNormalize ts us a x)

-- | Primitives of Dhall terms, built into the language.
data Prim ts us :: [DType ts us 'Type] -> DType ts us 'Type -> Type
[BoolLit] :: Bool -> Prim ts us '[]  'Bool
[NaturalLit] :: Natural -> Prim ts us '[]  'Natural
[NaturalFold] :: Prim ts us '[] ( 'Natural :->  'Pi ( 'NDK  'SType) (( 'TVar  'IZ :->  'TVar  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)))
[NaturalBuild] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) (( 'TVar  'IZ :->  'TVar  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :->  'Natural)
[NaturalPlus] :: Prim ts us '[ 'Natural,  'Natural]  'Natural
[NaturalTimes] :: Prim ts us '[ 'Natural,  'Natural]  'Natural
[NaturalIsZero] :: Prim ts us '[] ( 'Natural :->  'Bool)
[ListFold] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) (( 'List :$  'TVar  'IZ) :->  'Pi ( 'NDK  'SType) (( 'TVar ( 'IS  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'TVar  'IZ :->  'TVar  'IZ))))
[ListBuild] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) ( 'Pi ( 'NDK  'SType) (( 'TVar ( 'IS  'IZ) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'TVar  'IZ :->  'TVar  'IZ)) :-> ( 'List :$  'TVar  'IZ)))
[ListAppend] :: SDType ts us  'Type a -> Prim ts us '[ 'List :$ a,  'List :$ a] ( 'List :$ a)
[ListHead] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) (( 'List :$  'TVar  'IZ) :-> ( 'Optional :$  'TVar  'IZ)))
[ListLast] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) (( 'List :$  'TVar  'IZ) :-> ( 'Optional :$  'TVar  'IZ)))
[ListReverse] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) (( 'List :$  'TVar  'IZ) :-> ( 'List :$  'TVar  'IZ)))
[Some] :: SDType ts us  'Type a -> Prim ts us '[a] ( 'Optional :$ a)
[None] :: Prim ts us '[] ( 'Pi ( 'NDK  'SType) ( 'Optional :$  'TVar  'IZ))

-- | Represents the possible terms encountered in Dhall. A value of type
--   
--   <pre>
--   <a>DTerm</a> '[r, s] '[k, j] '[a, b, c] d
--   </pre>
--   
--   Describes a term of type <tt>d</tt> with possible:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   <li>Variables of type <tt>a</tt>, <tt>b</tt>, <tt>c</tt></li>
--   </ul>
--   
--   Something of type <tt><a>DTerm</a> '[] '[] '[] a</tt> is a term of
--   type <tt>a</tt> with no free variables.
--   
--   Note that "kind-polymorphic values" (functions from kinds to terms)
--   are not yet supported.
data DTerm ts (us :: [DKind ts 'Kind]) :: [DType ts us 'Type] -> DType ts us 'Type -> Type
[Var] :: Index vs a -> DTerm ts us vs a
[Lam] :: NDType ts us  'Type v -> DTerm ts us (v : vs) a -> DTerm ts us vs (v :-> a)
[App] :: DTerm ts us vs (a :-> b) -> DTerm ts us vs a -> DTerm ts us vs b
[Poly] :: SNDKind ts  'Kind u uu -> DTerm ts (u : us) (Map (ShiftSym ts us (u : us) u  'Type  'InsZ) vs) a -> DTerm ts us vs ( 'Pi uu a)
[Inst] :: SNDKind ts  'Kind u uu -> DTerm ts us vs ( 'Pi uu b) -> NDType ts us u a -> DTerm ts us vs (Sub ts (u : us) us u  'Type  'DelZ a b)
[P] :: Prim ts us as a -> Prod (DTerm ts us vs) as -> DTerm ts us vs a
[ListLit] :: NDType ts us  'Type a -> [DTerm ts us vs a] -> DTerm ts us vs ( 'List :$ a)
[OptionalLit] :: NDType ts us  'Type a -> Maybe (DTerm ts us vs a) -> DTerm ts us vs ( 'Optional :$ a)
data SomeTerm ts us :: [DType ts us 'Type] -> Type
[SomeTerm] :: NDType ts us  'Type a -> DTerm ts us vs a -> SomeTerm ts us vs
toSomeTerm :: forall ts us vs a. (PolySingI a, TNormalize ts us  'Type a ~ a) => DTerm ts us vs a -> SomeTerm ts us vs

-- | A <a>DExpr</a> fully covers all legal type-checking dhall terms. A
--   value of type
--   
--   <pre>
--   <a>DExpr</a> '[ r, s ] '[ k, j ] '[ a, b ] n
--   </pre>
--   
--   Represents a dhall expression on level <tt>n</tt> (<tt>'FZ</tt> =
--   term, <tt>'FS 'FZ</tt> = type, etc.) with potential:
--   
--   <ul>
--   <li>Kind variables of sort <tt>r</tt>, <tt>s</tt></li>
--   <li>Type variables of kind <tt>k</tt>, <tt>j</tt></li>
--   <li>Term variables of type <tt>a</tt>, <tt>b</tt></li>
--   </ul>
--   
--   A value of type <tt><a>DExpr</a> '[] '[] '[] n</tt> represents a typed
--   dhall expression with no free variables.
--   
--   You can pattern match on it to get a value of one of the "levels" of
--   the dhall type hierarchy, and also to get the "type" and
--   representation of it.
--   
--   The number of level goes up to 4 :
--   
--   <ul>
--   <li><tt>F0</tt>: term</li>
--   <li><tt>F1</tt>: type</li>
--   <li><tt>F2</tt>: kind</li>
--   <li><tt>F3</tt>: sort</li>
--   <li><tt>F4</tt>: order</li>
--   </ul>
--   
--   Note that you can restrict this to only <a>DExpr</a> past a given
--   "level" by asking for or returning a <tt><a>DExpr</a> ts us vs ('FS
--   n)</tt>, for instance. Such a value will only contain types, kinds,
--   sorts, or order A <tt><a>DExpr</a> ts us vs ('FS ('FS n))</tt> will
--   only contain kinds, sorts, or order, etc.
data DExpr ts us :: [DType ts us 'Type] -> Fin N5 -> Type
[DEOrder] :: DExpr ts us vs F4
[DESort] :: DSort -> DExpr ts us vs F3
[DEKind] :: SomeKind ts -> DExpr ts us vs F2
[DEType] :: SomeType ts us -> DExpr ts us vs F1
[DETerm] :: SomeTerm ts us vs -> DExpr ts us vs F0

-- | Hides the "level" of a <a>DExpr</a>. Pattern match to find it. Can be
--   useful when returning a <a>DExpr</a> of level unknown until runtime,
--   or storing <a>DExpr</a> of multiple levels in a container.
data SomeDExpr ts us :: [DType ts us 'Type] -> Type
[SomeDExpr] :: DExpr ts us vs l -> SomeDExpr ts us vs

-- | Get the meta-level "type" of a <a>DExpr</a>. If it's a term, this will
--   return its type. If it's a type, this returns its type, etc. It
--   essentially goes up one "level" of the Dhall type hierarchy.
--   
--   This will not typecheck if given a "Level 4" fin, so you cannot pass
--   in <a>DEOrder</a>.
dExprType :: DExpr ts us vs n -> DExpr ts us vs (ShiftFin N5 n)
deKind :: PolySingI a => DKind ts a -> DExpr ts us vs F2
deType :: (PolySingI a, KNormalize ts  'Kind a ~ a) => DType ts us a -> DExpr ts us vs F1
deTerm :: (PolySingI a, TNormalize ts us  'Type a ~ a) => DTerm ts us vs a -> DExpr ts us vs F0

-- | Meta-level type describing a collection or aggregation of types. Used
--   for specifying records and unions. data AggType k :: [Text] -&gt; [k]
--   -&gt; Type where
data AggType k (ls :: [Text]) (as :: [k])
[ATZ] :: AggType k '[] '[]
[ATS] :: SText l -> WrappedSing k (a :: k) -> AggType k ls as -> AggType k (l : ls) (a : as)
sortOf :: DKind '[] a -> SDSort a
kindOf :: DType ts '[] a -> SDKind ts  'Kind a
typeOf :: DTerm ts us '[] a -> SDType ts us  'Type a
sortOfWith :: Prod SDSort ts -> DKind ts a -> SDSort a
kindOfWith :: Prod (SDKind ts  'Kind) us -> DType ts us a -> SDKind ts  'Kind a
typeOfWith :: Prod (SDType ts us  'Type) vs -> DTerm ts us vs a -> SDType ts us  'Type a
data SDSort (x_a1CyV :: DSort)
[SKind] :: SDSort  'Kind
[:%*>] :: forall x_a1CyW x_a1CyX. () => SDSort x_a1CyW -> SDSort x_a1CyX -> SDSort ( '(:*>) x_a1CyW x_a1CyX)
[SKRecord] :: forall (ls_X1CrE :: [Text]) (as_X1CrG :: [()]) x_a1CyY. () => PolySing (AggType () ls_X1CrE as_X1CrG) x_a1CyY -> SDSort ( 'KRecord x_a1CyY)
[SKUnion] :: forall (ls_X1CrG :: [Text]) (as_X1CrI :: [()]) x_a1Cz1. () => PolySing (AggType () ls_X1CrG as_X1CrI) x_a1Cz1 -> SDSort ( 'KUnion x_a1Cz1)
data SDKind (a_a1CEM :: [DSort]) (b_a1CEN :: DSort) (x_a1CIG :: DKind (a_a1CEM :: [DSort]) (b_a1CEN :: DSort))
[SKVar] :: forall (ts_a1CAj :: [DSort]) (a_a1CAk :: DSort) x_a1CIH. () => PolySing (Index ts_a1CAj a_a1CAk) x_a1CIH -> SDKind ts_a1CAj a_a1CAk ( 'KVar x_a1CIH)
[SKLam] :: forall (t_X1CAm :: DSort) (ts_a1CAm :: [DSort]) (a_X1CAp :: DSort) x_a1CIM x_a1CIN. () => SingSing DSort t_X1CAm ( 'WS x_a1CIM) -> SDKind ( '(:) t_X1CAm ts_a1CAm) a_X1CAp x_a1CIN -> SDKind ts_a1CAm ( '(:*>) t_X1CAm a_X1CAp) ( 'KLam x_a1CIM x_a1CIN)
[SKApp] :: forall (ts_a1CAo :: [DSort]) (a_X1CAq :: DSort) (b_a1CAq :: DSort) x_a1CIX x_a1CJ7. () => SDKind ts_a1CAo ( '(:*>) a_X1CAq b_a1CAq) x_a1CIX -> SDKind ts_a1CAo a_X1CAq x_a1CJ7 -> SDKind ts_a1CAo b_a1CAq ( 'KApp x_a1CIX x_a1CJ7)
[:%~>] :: forall (ts_a1CAr :: [DSort]) x_a1CJh x_a1CJr. () => SDKind ts_a1CAr  'Kind x_a1CJh -> SDKind ts_a1CAr  'Kind x_a1CJr -> SDKind ts_a1CAr  'Kind ( '(:~>) x_a1CJh x_a1CJr)
[SKPi] :: forall (t_X1CAt :: DSort) (ts_a1CAt :: [DSort]) (a_a1CAu :: DSort) x_a1CJB x_a1CJC. () => SingSing DSort t_X1CAt ( 'WS x_a1CJB) -> SDKind ( '(:) t_X1CAt ts_a1CAt) a_a1CAu x_a1CJC -> SDKind ts_a1CAt a_a1CAu ( 'KPi x_a1CJB x_a1CJC)
[SType] :: forall (ts_a1CAv :: [DSort]). () => SDKind ts_a1CAv  'Kind  'Type
data SNDKind (ts_a1CMR :: [DSort]) (a_a1CMS :: DSort) (b_a1D0b :: DKind ts_a1CMR a_a1CMS) (x_a1D4L :: NDKind (ts_a1CMR :: [DSort]) (a_a1CMS :: DSort) (b_a1D0b :: DKind ts_a1CMR a_a1CMS))
[SNDK] :: forall (ts_a1CMT :: [DSort]) (a_a1CMU :: DSort) (x_X1CMW :: DKind ts_a1CMT a_a1CMU) x_a1D4M. () => SingSing (DKind ts_a1CMT a_a1CMU) x_X1CMW ( 'WS x_a1D4M) -> SNDKind ts_a1CMT a_a1CMU (KNormalize ts_a1CMT a_a1CMU x_X1CMW) ( 'NDK x_a1D4M)
data SDType (ts_a1D5A :: [DSort]) (a_a1DdC :: [DKind ts_a1D5A 'Kind]) (b_a1DdD :: DKind ts_a1D5A 'Kind) (x_a1DiE :: DType (ts_a1D5A :: [DSort]) (a_a1DdC :: [DKind ts_a1D5A 'Kind]) (b_a1DdD :: DKind ts_a1D5A 'Kind))
[STVar] :: forall (ts_a1D5D :: [DSort]) (us_a1D5B :: [DKind ts_a1D5D  'Kind]) (a_a1D5C :: DKind ts_a1D5D  'Kind) x_a1DiF. () => PolySing (Index us_a1D5B a_a1D5C) x_a1DiF -> SDType ts_a1D5D us_a1D5B a_a1D5C ( 'TVar x_a1DiF)
[STLam] :: forall (ts_a1D5E :: [DSort]) (u_X1D5G :: DKind ts_a1D5E  'Kind) (us_a1D5G :: [DKind ts_a1D5E  'Kind]) (a_X1D5J :: DKind ts_a1D5E  'Kind) x_a1DiK x_a1DiN. () => PolySing (NDKind ts_a1D5E  'Kind u_X1D5G) x_a1DiK -> SDType ts_a1D5E ( '(:) u_X1D5G us_a1D5G) a_X1D5J x_a1DiN -> SDType ts_a1D5E us_a1D5G ( '(:~>) u_X1D5G a_X1D5J) ( 'TLam x_a1DiK x_a1DiN)
[STApp] :: forall (ts_a1D5I :: [DSort]) (us_a1D5J :: [DKind ts_a1D5I  'Kind]) (a_X1D5L :: DKind ts_a1D5I  'Kind) (b_a1D5L :: DKind ts_a1D5I  'Kind) x_a1Djd x_a1DjD. () => SDType ts_a1D5I us_a1D5J ( '(:~>) a_X1D5L b_a1D5L) x_a1Djd -> SDType ts_a1D5I us_a1D5J a_X1D5L x_a1DjD -> SDType ts_a1D5I us_a1D5J b_a1D5L ( 'TApp x_a1Djd x_a1DjD)
[STPoly] :: forall (t_X1D5N :: DSort) (tt_X1D5P :: SDSort t_X1D5N) (ts_a1D5O :: [DSort]) (us_a1D5P :: [DKind ts_a1D5O  'Kind]) (a_X1D5T :: DKind ( '(:) t_X1D5N ts_a1D5O)  'Kind) x_a1Dk3 x_a1Dk7. () => SingSing (WrappedSing DSort t_X1D5N) ( 'WS tt_X1D5P) ( 'WS x_a1Dk3) -> SDType ( '(:) t_X1D5N ts_a1D5O) (Map (KShiftSym ts_a1D5O ( '(:) t_X1D5N ts_a1D5O) t_X1D5N  'Kind ( 'InsZ :: Insert ts_a1D5O ( '(:) t_X1D5N ts_a1D5O) t_X1D5N)) us_a1D5P) a_X1D5T x_a1Dk7 -> SDType ts_a1D5O us_a1D5P ( 'KPi tt_X1D5P a_X1D5T) ( 'TPoly x_a1Dk3 x_a1Dk7)
[STInst] :: forall (ts_a1D5R :: [DSort]) (us_a1D5S :: [DKind ts_a1D5R  'Kind]) (t_X1D5W :: DSort) (tt_X1D5V :: SDSort t_X1D5W) (b_X1D5X :: DKind ( '(:) t_X1D5W ts_a1D5R)  'Kind) (a_X1D60 :: DKind ts_a1D5R t_X1D5W) x_a1DyO x_a1Dze. () => SDType ts_a1D5R us_a1D5S ( 'KPi tt_X1D5V b_X1D5X) x_a1DyO -> SingSing (DKind ts_a1D5R t_X1D5W) a_X1D60 ( 'WS x_a1Dze) -> SDType ts_a1D5R us_a1D5S (KSub ( '(:) t_X1D5W ts_a1D5R) ts_a1D5R t_X1D5W  'Kind ( 'DelZ :: Delete ( '(:) t_X1D5W ts_a1D5R) ts_a1D5R t_X1D5W) a_X1D60 b_X1D5X) ( 'TInst x_a1DyO x_a1Dze)
[:%->] :: forall (ts_a1D5X :: [DSort]) (us_a1D5Y :: [DKind ts_a1D5X  'Kind]) x_a1Dzo x_a1DB7. () => SDType ts_a1D5X us_a1D5Y ( 'Type :: DKind ts_a1D5X  'Kind) x_a1Dzo -> SDType ts_a1D5X us_a1D5Y ( 'Type :: DKind ts_a1D5X  'Kind) x_a1DB7 -> SDType ts_a1D5X us_a1D5Y ( 'Type :: DKind ts_a1D5X  'Kind) ( '(:->) x_a1Dzo x_a1DB7)
[SPi] :: forall (ts_a1D5Z :: [DSort]) (u_X1D61 :: DKind ts_a1D5Z  'Kind) (us_a1D61 :: [DKind ts_a1D5Z  'Kind]) (a_a1D62 :: DKind ts_a1D5Z  'Kind) x_a1DCQ x_a1DCT. () => PolySing (NDKind ts_a1D5Z  'Kind u_X1D61) x_a1DCQ -> SDType ts_a1D5Z ( '(:) u_X1D61 us_a1D61) a_a1D62 x_a1DCT -> SDType ts_a1D5Z us_a1D61 a_a1D62 ( 'Pi x_a1DCQ x_a1DCT)
[SBool] :: forall (ts_a1D63 :: [DSort]) (us_a1D64 :: [DKind ts_a1D63  'Kind]). () => SDType ts_a1D63 us_a1D64 ( 'Type :: DKind ts_a1D63  'Kind)  'Bool
[SNatural] :: forall (ts_a1D65 :: [DSort]) (us_a1D66 :: [DKind ts_a1D65  'Kind]). () => SDType ts_a1D65 us_a1D66 ( 'Type :: DKind ts_a1D65  'Kind)  'Natural
[SList] :: forall (ts_a1D67 :: [DSort]) (us_a1D68 :: [DKind ts_a1D67  'Kind]). () => SDType ts_a1D67 us_a1D68 ((:~>) ( 'Type :: DKind ts_a1D67  'Kind) ( 'Type :: DKind ts_a1D67  'Kind))  'List
[SOptional] :: forall (ts_a1D69 :: [DSort]) (us_a1D6a :: [DKind ts_a1D69  'Kind]). () => SDType ts_a1D69 us_a1D6a ((:~>) ( 'Type :: DKind ts_a1D69  'Kind) ( 'Type :: DKind ts_a1D69  'Kind))  'Optional
data SNDType (ts_a1DKi :: [DSort]) (us_a1DKj :: [DKind ts_a1DKi 'Kind]) (a_a1DKk :: DKind ts_a1DKi 'Kind) (b_a1E7O :: DType ts_a1DKi us_a1DKj a_a1DKk) (x_a1Eeu :: NDType (ts_a1DKi :: [DSort]) (us_a1DKj :: [DKind ts_a1DKi 'Kind]) (a_a1DKk :: DKind ts_a1DKi 'Kind) (b_a1E7O :: DType ts_a1DKi us_a1DKj a_a1DKk))
[SNDT] :: forall (ts_a1DKl :: [DSort]) (us_a1DKm :: [DKind ts_a1DKl  'Kind]) (a_a1DKn :: DKind ts_a1DKl  'Kind) (x_X1DKp :: DType ts_a1DKl us_a1DKm a_a1DKn) x_a1Eev. () => SingSing (DType ts_a1DKl us_a1DKm a_a1DKn) x_X1DKp ( 'WS x_a1Eev) -> SNDType ts_a1DKl us_a1DKm a_a1DKn (TNormalize ts_a1DKl us_a1DKm a_a1DKn x_X1DKp) ( 'NDT x_a1Eev)
data SPrim (ts_a1EfD :: [DSort]) (us_a1EfE :: [DKind ts_a1EfD 'Kind]) (a_a1EAd :: [DType ts_a1EfD us_a1EfE ( 'Type :: DKind ts_a1EfD 'Kind)]) (b_a1EAe :: DType ts_a1EfD us_a1EfE ( 'Type :: DKind ts_a1EfD 'Kind)) (x_a1EES :: Prim (ts_a1EfD :: [DSort]) (us_a1EfE :: [DKind ts_a1EfD 'Kind]) (a_a1EAd :: [DType ts_a1EfD us_a1EfE ( 'Type :: DKind ts_a1EfD 'Kind)]) (b_a1EAe :: DType ts_a1EfD us_a1EfE ( 'Type :: DKind ts_a1EfD 'Kind)))
[SBoolLit] :: forall (ts_a1EfF :: [DSort]) (us_a1EfG :: [DKind ts_a1EfF  'Kind]) x_a1EET. () => PolySing Bool x_a1EET -> SPrim ts_a1EfF us_a1EfG ('[] :: [DType ts_a1EfF us_a1EfG ( 'Type :: DKind ts_a1EfF  'Kind)]) ( 'Bool :: DType ts_a1EfF us_a1EfG ( 'Type :: DKind ts_a1EfF  'Kind)) ( 'BoolLit x_a1EET)
[SNaturalLit] :: forall (ts_a1EfH :: [DSort]) (us_a1EfI :: [DKind ts_a1EfH  'Kind]) x_a1EEU. () => PolySing Natural x_a1EEU -> SPrim ts_a1EfH us_a1EfI ('[] :: [DType ts_a1EfH us_a1EfI ( 'Type :: DKind ts_a1EfH  'Kind)]) ( 'Natural :: DType ts_a1EfH us_a1EfI ( 'Type :: DKind ts_a1EfH  'Kind)) ( 'NaturalLit x_a1EEU)
[SNaturalFold] :: forall (ts_a1EfJ :: [DSort]) (us_a1EfK :: [DKind ts_a1EfJ  'Kind]). () => SPrim ts_a1EfJ us_a1EfK ('[] :: [DType ts_a1EfJ us_a1EfK ( 'Type :: DKind ts_a1EfJ  'Kind)]) ((:->) ( 'Natural :: DType ts_a1EfJ us_a1EfK ( 'Type :: DKind ts_a1EfJ  'Kind)) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1EfJ  'Kind ( 'Type :: DKind ts_a1EfJ  'Kind))) ((:->) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfJ  'Kind) us_a1EfK) ( 'Type :: DKind ts_a1EfJ  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfJ  'Kind) us_a1EfK) ( 'Type :: DKind ts_a1EfJ  'Kind)))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfJ  'Kind) us_a1EfK) ( 'Type :: DKind ts_a1EfJ  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfJ  'Kind) us_a1EfK) ( 'Type :: DKind ts_a1EfJ  'Kind)))))))  'NaturalFold
[SNaturalBuild] :: forall (ts_a1EfL :: [DSort]) (us_a1EfM :: [DKind ts_a1EfL  'Kind]). () => SPrim ts_a1EfL us_a1EfM ('[] :: [DType ts_a1EfL us_a1EfM ( 'Type :: DKind ts_a1EfL  'Kind)]) ((:->) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1EfL  'Kind ( 'Type :: DKind ts_a1EfL  'Kind))) ((:->) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfL  'Kind) us_a1EfM) ( 'Type :: DKind ts_a1EfL  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfL  'Kind) us_a1EfM) ( 'Type :: DKind ts_a1EfL  'Kind)))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfL  'Kind) us_a1EfM) ( 'Type :: DKind ts_a1EfL  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfL  'Kind) us_a1EfM) ( 'Type :: DKind ts_a1EfL  'Kind)))))) ( 'Natural :: DType ts_a1EfL us_a1EfM ( 'Type :: DKind ts_a1EfL  'Kind)))  'NaturalBuild
[SNaturalPlus] :: forall (ts_a1EfN :: [DSort]) (us_a1EfO :: [DKind ts_a1EfN  'Kind]). () => SPrim ts_a1EfN us_a1EfO ( '(:) ( 'Natural :: DType ts_a1EfN us_a1EfO ( 'Type :: DKind ts_a1EfN  'Kind)) ( '(:) ( 'Natural :: DType ts_a1EfN us_a1EfO ( 'Type :: DKind ts_a1EfN  'Kind)) ('[] :: [DType ts_a1EfN us_a1EfO ( 'Type :: DKind ts_a1EfN  'Kind)]))) ( 'Natural :: DType ts_a1EfN us_a1EfO ( 'Type :: DKind ts_a1EfN  'Kind))  'NaturalPlus
[SNaturalTimes] :: forall (ts_a1EfP :: [DSort]) (us_a1EfQ :: [DKind ts_a1EfP  'Kind]). () => SPrim ts_a1EfP us_a1EfQ ( '(:) ( 'Natural :: DType ts_a1EfP us_a1EfQ ( 'Type :: DKind ts_a1EfP  'Kind)) ( '(:) ( 'Natural :: DType ts_a1EfP us_a1EfQ ( 'Type :: DKind ts_a1EfP  'Kind)) ('[] :: [DType ts_a1EfP us_a1EfQ ( 'Type :: DKind ts_a1EfP  'Kind)]))) ( 'Natural :: DType ts_a1EfP us_a1EfQ ( 'Type :: DKind ts_a1EfP  'Kind))  'NaturalTimes
[SNaturalIsZero] :: forall (ts_a1EfR :: [DSort]) (us_a1EfS :: [DKind ts_a1EfR  'Kind]). () => SPrim ts_a1EfR us_a1EfS ('[] :: [DType ts_a1EfR us_a1EfS ( 'Type :: DKind ts_a1EfR  'Kind)]) ((:->) ( 'Natural :: DType ts_a1EfR us_a1EfS ( 'Type :: DKind ts_a1EfR  'Kind)) ( 'Bool :: DType ts_a1EfR us_a1EfS ( 'Type :: DKind ts_a1EfR  'Kind)))  'NaturalIsZero
[SListFold] :: forall (ts_a1EfT :: [DSort]) (us_a1EfU :: [DKind ts_a1EfT  'Kind]). () => SPrim ts_a1EfT us_a1EfU ('[] :: [DType ts_a1EfT us_a1EfU ( 'Type :: DKind ts_a1EfT  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1EfT  'Kind ( 'Type :: DKind ts_a1EfT  'Kind))) ((:->) ((:$) ( 'List :: DType ts_a1EfT ( '(:) ( 'Type :: DKind ts_a1EfT  'Kind) us_a1EfU) ((:~>) ( 'Type :: DKind ts_a1EfT  'Kind) ( 'Type :: DKind ts_a1EfT  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfT  'Kind) us_a1EfU) ( 'Type :: DKind ts_a1EfT  'Kind)))) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1EfT  'Kind ( 'Type :: DKind ts_a1EfT  'Kind))) ((:->) ((:->) ( 'TVar ( 'IS ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfT  'Kind) us_a1EfU) ( 'Type :: DKind ts_a1EfT  'Kind)) :: Index ( '(:) ( 'Type :: DKind ts_a1EfT  'Kind) ( '(:) ( 'Type :: DKind ts_a1EfT  'Kind) us_a1EfU)) ( 'Type :: DKind ts_a1EfT  'Kind))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfT  'Kind) ( '(:) ( 'Type :: DKind ts_a1EfT  'Kind) us_a1EfU)) ( 'Type :: DKind ts_a1EfT  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfT  'Kind) ( '(:) ( 'Type :: DKind ts_a1EfT  'Kind) us_a1EfU)) ( 'Type :: DKind ts_a1EfT  'Kind))))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfT  'Kind) ( '(:) ( 'Type :: DKind ts_a1EfT  'Kind) us_a1EfU)) ( 'Type :: DKind ts_a1EfT  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfT  'Kind) ( '(:) ( 'Type :: DKind ts_a1EfT  'Kind) us_a1EfU)) ( 'Type :: DKind ts_a1EfT  'Kind))))))))  'ListFold
[SListBuild] :: forall (ts_a1EfV :: [DSort]) (us_a1EfW :: [DKind ts_a1EfV  'Kind]). () => SPrim ts_a1EfV us_a1EfW ('[] :: [DType ts_a1EfV us_a1EfW ( 'Type :: DKind ts_a1EfV  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1EfV  'Kind ( 'Type :: DKind ts_a1EfV  'Kind))) ((:->) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1EfV  'Kind ( 'Type :: DKind ts_a1EfV  'Kind))) ((:->) ((:->) ( 'TVar ( 'IS ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfV  'Kind) us_a1EfW) ( 'Type :: DKind ts_a1EfV  'Kind)) :: Index ( '(:) ( 'Type :: DKind ts_a1EfV  'Kind) ( '(:) ( 'Type :: DKind ts_a1EfV  'Kind) us_a1EfW)) ( 'Type :: DKind ts_a1EfV  'Kind))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfV  'Kind) ( '(:) ( 'Type :: DKind ts_a1EfV  'Kind) us_a1EfW)) ( 'Type :: DKind ts_a1EfV  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfV  'Kind) ( '(:) ( 'Type :: DKind ts_a1EfV  'Kind) us_a1EfW)) ( 'Type :: DKind ts_a1EfV  'Kind))))) ((:->) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfV  'Kind) ( '(:) ( 'Type :: DKind ts_a1EfV  'Kind) us_a1EfW)) ( 'Type :: DKind ts_a1EfV  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfV  'Kind) ( '(:) ( 'Type :: DKind ts_a1EfV  'Kind) us_a1EfW)) ( 'Type :: DKind ts_a1EfV  'Kind)))))) ((:$) ( 'List :: DType ts_a1EfV ( '(:) ( 'Type :: DKind ts_a1EfV  'Kind) us_a1EfW) ((:~>) ( 'Type :: DKind ts_a1EfV  'Kind) ( 'Type :: DKind ts_a1EfV  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1EfV  'Kind) us_a1EfW) ( 'Type :: DKind ts_a1EfV  'Kind))))))  'ListBuild
[SListAppend] :: forall (ts_a1EfX :: [DSort]) (us_a1EfY :: [DKind ts_a1EfX  'Kind]) (a_X1Eg0 :: DType ts_a1EfX us_a1EfY ( 'Type :: DKind ts_a1EfX  'Kind)) x_a1EEW. () => SingSing (DType ts_a1EfX us_a1EfY ( 'Type :: DKind ts_a1EfX  'Kind)) a_X1Eg0 ( 'WS x_a1EEW) -> SPrim ts_a1EfX us_a1EfY ( '(:) ((:$) ( 'List :: DType ts_a1EfX us_a1EfY ((:~>) ( 'Type :: DKind ts_a1EfX  'Kind) ( 'Type :: DKind ts_a1EfX  'Kind))) a_X1Eg0) ( '(:) ((:$) ( 'List :: DType ts_a1EfX us_a1EfY ((:~>) ( 'Type :: DKind ts_a1EfX  'Kind) ( 'Type :: DKind ts_a1EfX  'Kind))) a_X1Eg0) ('[] :: [DType ts_a1EfX us_a1EfY ( 'Type :: DKind ts_a1EfX  'Kind)]))) ((:$) ( 'List :: DType ts_a1EfX us_a1EfY ((:~>) ( 'Type :: DKind ts_a1EfX  'Kind) ( 'Type :: DKind ts_a1EfX  'Kind))) a_X1Eg0) ( 'ListAppend x_a1EEW)
[SListHead] :: forall (ts_a1Eg0 :: [DSort]) (us_a1Eg1 :: [DKind ts_a1Eg0  'Kind]). () => SPrim ts_a1Eg0 us_a1Eg1 ('[] :: [DType ts_a1Eg0 us_a1Eg1 ( 'Type :: DKind ts_a1Eg0  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Eg0  'Kind ( 'Type :: DKind ts_a1Eg0  'Kind))) ((:->) ((:$) ( 'List :: DType ts_a1Eg0 ( '(:) ( 'Type :: DKind ts_a1Eg0  'Kind) us_a1Eg1) ((:~>) ( 'Type :: DKind ts_a1Eg0  'Kind) ( 'Type :: DKind ts_a1Eg0  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eg0  'Kind) us_a1Eg1) ( 'Type :: DKind ts_a1Eg0  'Kind)))) ((:$) ( 'Optional :: DType ts_a1Eg0 ( '(:) ( 'Type :: DKind ts_a1Eg0  'Kind) us_a1Eg1) ((:~>) ( 'Type :: DKind ts_a1Eg0  'Kind) ( 'Type :: DKind ts_a1Eg0  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eg0  'Kind) us_a1Eg1) ( 'Type :: DKind ts_a1Eg0  'Kind))))))  'ListHead
[SListLast] :: forall (ts_a1Eg2 :: [DSort]) (us_a1Eg3 :: [DKind ts_a1Eg2  'Kind]). () => SPrim ts_a1Eg2 us_a1Eg3 ('[] :: [DType ts_a1Eg2 us_a1Eg3 ( 'Type :: DKind ts_a1Eg2  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Eg2  'Kind ( 'Type :: DKind ts_a1Eg2  'Kind))) ((:->) ((:$) ( 'List :: DType ts_a1Eg2 ( '(:) ( 'Type :: DKind ts_a1Eg2  'Kind) us_a1Eg3) ((:~>) ( 'Type :: DKind ts_a1Eg2  'Kind) ( 'Type :: DKind ts_a1Eg2  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eg2  'Kind) us_a1Eg3) ( 'Type :: DKind ts_a1Eg2  'Kind)))) ((:$) ( 'Optional :: DType ts_a1Eg2 ( '(:) ( 'Type :: DKind ts_a1Eg2  'Kind) us_a1Eg3) ((:~>) ( 'Type :: DKind ts_a1Eg2  'Kind) ( 'Type :: DKind ts_a1Eg2  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eg2  'Kind) us_a1Eg3) ( 'Type :: DKind ts_a1Eg2  'Kind))))))  'ListLast
[SListReverse] :: forall (ts_a1Eg4 :: [DSort]) (us_a1Eg5 :: [DKind ts_a1Eg4  'Kind]). () => SPrim ts_a1Eg4 us_a1Eg5 ('[] :: [DType ts_a1Eg4 us_a1Eg5 ( 'Type :: DKind ts_a1Eg4  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Eg4  'Kind ( 'Type :: DKind ts_a1Eg4  'Kind))) ((:->) ((:$) ( 'List :: DType ts_a1Eg4 ( '(:) ( 'Type :: DKind ts_a1Eg4  'Kind) us_a1Eg5) ((:~>) ( 'Type :: DKind ts_a1Eg4  'Kind) ( 'Type :: DKind ts_a1Eg4  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eg4  'Kind) us_a1Eg5) ( 'Type :: DKind ts_a1Eg4  'Kind)))) ((:$) ( 'List :: DType ts_a1Eg4 ( '(:) ( 'Type :: DKind ts_a1Eg4  'Kind) us_a1Eg5) ((:~>) ( 'Type :: DKind ts_a1Eg4  'Kind) ( 'Type :: DKind ts_a1Eg4  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eg4  'Kind) us_a1Eg5) ( 'Type :: DKind ts_a1Eg4  'Kind))))))  'ListReverse
[SSome] :: forall (ts_a1Eg6 :: [DSort]) (us_a1Eg7 :: [DKind ts_a1Eg6  'Kind]) (a_X1Eg9 :: DType ts_a1Eg6 us_a1Eg7 ( 'Type :: DKind ts_a1Eg6  'Kind)) x_a1EGF. () => SingSing (DType ts_a1Eg6 us_a1Eg7 ( 'Type :: DKind ts_a1Eg6  'Kind)) a_X1Eg9 ( 'WS x_a1EGF) -> SPrim ts_a1Eg6 us_a1Eg7 ( '(:) a_X1Eg9 ('[] :: [DType ts_a1Eg6 us_a1Eg7 ( 'Type :: DKind ts_a1Eg6  'Kind)])) ((:$) ( 'Optional :: DType ts_a1Eg6 us_a1Eg7 ((:~>) ( 'Type :: DKind ts_a1Eg6  'Kind) ( 'Type :: DKind ts_a1Eg6  'Kind))) a_X1Eg9) ( 'Some x_a1EGF)
[SNone] :: forall (ts_a1Eg9 :: [DSort]) (us_a1Ega :: [DKind ts_a1Eg9  'Kind]). () => SPrim ts_a1Eg9 us_a1Ega ('[] :: [DType ts_a1Eg9 us_a1Ega ( 'Type :: DKind ts_a1Eg9  'Kind)]) ( 'Pi ( 'NDK ( 'SType :: SDKind ts_a1Eg9  'Kind ( 'Type :: DKind ts_a1Eg9  'Kind))) ((:$) ( 'Optional :: DType ts_a1Eg9 ( '(:) ( 'Type :: DKind ts_a1Eg9  'Kind) us_a1Ega) ((:~>) ( 'Type :: DKind ts_a1Eg9  'Kind) ( 'Type :: DKind ts_a1Eg9  'Kind))) ( 'TVar ( 'IZ :: Index ( '(:) ( 'Type :: DKind ts_a1Eg9  'Kind) us_a1Ega) ( 'Type :: DKind ts_a1Eg9  'Kind)))))  'None
data SDTerm (ts_a1EP0 :: [DSort]) (us_a1EP1 :: [DKind ts_a1EP0 'Kind]) (a_a1FoO :: [DType ts_a1EP0 us_a1EP1 ( 'Type :: DKind ts_a1EP0 'Kind)]) (b_a1FoP :: DType ts_a1EP0 us_a1EP1 ( 'Type :: DKind ts_a1EP0 'Kind)) (x_a1FwN :: DTerm (ts_a1EP0 :: [DSort]) (us_a1EP1 :: [DKind ts_a1EP0 'Kind]) (a_a1FoO :: [DType ts_a1EP0 us_a1EP1 ( 'Type :: DKind ts_a1EP0 'Kind)]) (b_a1FoP :: DType ts_a1EP0 us_a1EP1 ( 'Type :: DKind ts_a1EP0 'Kind)))
[SVar] :: forall (ts_a1EP4 :: [DSort]) (us_a1EP5 :: [DKind ts_a1EP4  'Kind]) (vs_a1EP2 :: [DType ts_a1EP4 us_a1EP5 ( 'Type :: DKind ts_a1EP4  'Kind)]) (a_a1EP3 :: DType ts_a1EP4 us_a1EP5 ( 'Type :: DKind ts_a1EP4  'Kind)) x_a1FwO. () => PolySing (Index vs_a1EP2 a_a1EP3) x_a1FwO -> SDTerm ts_a1EP4 us_a1EP5 vs_a1EP2 a_a1EP3 ( 'Var x_a1FwO)
[SLam] :: forall (ts_a1EP6 :: [DSort]) (us_a1EP7 :: [DKind ts_a1EP6  'Kind]) (v_X1EP9 :: DType ts_a1EP6 us_a1EP7 ( 'Type :: DKind ts_a1EP6  'Kind)) (vs_a1EP9 :: [DType ts_a1EP6 us_a1EP7 ( 'Type :: DKind ts_a1EP6  'Kind)]) (a_X1EPc :: DType ts_a1EP6 us_a1EP7 ( 'Type :: DKind ts_a1EP6  'Kind)) x_a1FwT x_a1Fyg. () => PolySing (NDType ts_a1EP6 us_a1EP7 ( 'Type :: DKind ts_a1EP6  'Kind) v_X1EP9) x_a1FwT -> SDTerm ts_a1EP6 us_a1EP7 ( '(:) v_X1EP9 vs_a1EP9) a_X1EPc x_a1Fyg -> SDTerm ts_a1EP6 us_a1EP7 vs_a1EP9 ( '(:->) v_X1EP9 a_X1EPc) ( 'Lam x_a1FwT x_a1Fyg)
[SApp] :: forall (ts_a1EPb :: [DSort]) (us_a1EPc :: [DKind ts_a1EPb  'Kind]) (vs_a1EPd :: [DType ts_a1EPb us_a1EPc ( 'Type :: DKind ts_a1EPb  'Kind)]) (a_X1EPf :: DType ts_a1EPb us_a1EPc ( 'Type :: DKind ts_a1EPb  'Kind)) (b_a1EPf :: DType ts_a1EPb us_a1EPc ( 'Type :: DKind ts_a1EPb  'Kind)) x_a1FyI x_a1Fza. () => SDTerm ts_a1EPb us_a1EPc vs_a1EPd ( '(:->) a_X1EPf b_a1EPf) x_a1FyI -> SDTerm ts_a1EPb us_a1EPc vs_a1EPd a_X1EPf x_a1Fza -> SDTerm ts_a1EPb us_a1EPc vs_a1EPd b_a1EPf ( 'App x_a1FyI x_a1Fza)
[SPoly] :: forall (ts_a1EPg :: [DSort]) (u_X1EPi :: DKind ts_a1EPg  'Kind) (uu_X1EPk :: NDKind ts_a1EPg  'Kind u_X1EPi) (us_a1EPj :: [DKind ts_a1EPg  'Kind]) (vs_a1EPk :: [DType ts_a1EPg us_a1EPj ( 'Type :: DKind ts_a1EPg  'Kind)]) (a_X1EPo :: DType ts_a1EPg ( '(:) u_X1EPi us_a1EPj) ( 'Type :: DKind ts_a1EPg  'Kind)) x_a1FzC x_a1FzF. () => SingSing (NDKind ts_a1EPg  'Kind u_X1EPi) uu_X1EPk ( 'WS x_a1FzC) -> SDTerm ts_a1EPg ( '(:) u_X1EPi us_a1EPj) (Map (ShiftSym ts_a1EPg us_a1EPj ( '(:) u_X1EPi us_a1EPj) u_X1EPi ( 'Type :: DKind ts_a1EPg  'Kind) ( 'InsZ :: Insert us_a1EPj ( '(:) u_X1EPi us_a1EPj) u_X1EPi)) vs_a1EPk) a_X1EPo x_a1FzF -> SDTerm ts_a1EPg us_a1EPj vs_a1EPk ( 'Pi uu_X1EPk a_X1EPo) ( 'Poly x_a1FzC x_a1FzF)
[SInst] :: forall (ts_a1EPm :: [DSort]) (u_X1EPo :: DKind ts_a1EPm  'Kind) (uu_X1EPq :: NDKind ts_a1EPm  'Kind u_X1EPo) (us_a1EPp :: [DKind ts_a1EPm  'Kind]) (vs_a1EPq :: [DType ts_a1EPm us_a1EPp ( 'Type :: DKind ts_a1EPm  'Kind)]) (b_X1EPu :: DType ts_a1EPm ( '(:) u_X1EPo us_a1EPp) ( 'Type :: DKind ts_a1EPm  'Kind)) (a_X1EPw :: DType ts_a1EPm us_a1EPp u_X1EPo) x_a1GcV x_a1GcY x_a1Gdq. () => SingSing (NDKind ts_a1EPm  'Kind u_X1EPo) uu_X1EPq ( 'WS x_a1GcV) -> SDTerm ts_a1EPm us_a1EPp vs_a1EPq ( 'Pi uu_X1EPq b_X1EPu) x_a1GcY -> PolySing (NDType ts_a1EPm us_a1EPp u_X1EPo a_X1EPw) x_a1Gdq -> SDTerm ts_a1EPm us_a1EPp vs_a1EPq (Sub ts_a1EPm ( '(:) u_X1EPo us_a1EPp) us_a1EPp u_X1EPo ( 'Type :: DKind ts_a1EPm  'Kind) ( 'DelZ :: Delete ( '(:) u_X1EPo us_a1EPp) us_a1EPp u_X1EPo) a_X1EPw b_X1EPu) ( 'Inst x_a1GcV x_a1GcY x_a1Gdq)
[SP] :: forall (ts_a1EPt :: [DSort]) (us_a1EPu :: [DKind ts_a1EPt  'Kind]) (as_X1EPw :: [DType ts_a1EPt us_a1EPu ( 'Type :: DKind ts_a1EPt  'Kind)]) (a_a1EPw :: DType ts_a1EPt us_a1EPu ( 'Type :: DKind ts_a1EPt  'Kind)) (vs_a1EPx :: [DType ts_a1EPt us_a1EPu ( 'Type :: DKind ts_a1EPt  'Kind)]) x_a1Gdu x_a1GdZ. () => PolySing (Prim ts_a1EPt us_a1EPu as_X1EPw a_a1EPw) x_a1Gdu -> PolySing (Prod (DTerm ts_a1EPt us_a1EPu vs_a1EPx) as_X1EPw) x_a1GdZ -> SDTerm ts_a1EPt us_a1EPu vs_a1EPx a_a1EPw ( 'P x_a1Gdu x_a1GdZ)
[SListLit] :: forall (ts_a1EPy :: [DSort]) (us_a1EPz :: [DKind ts_a1EPy  'Kind]) (a_X1EPB :: DType ts_a1EPy us_a1EPz ( 'Type :: DKind ts_a1EPy  'Kind)) (vs_a1EPB :: [DType ts_a1EPy us_a1EPz ( 'Type :: DKind ts_a1EPy  'Kind)]) x_a1GhZ x_a1Gjm. () => PolySing (NDType ts_a1EPy us_a1EPz ( 'Type :: DKind ts_a1EPy  'Kind) a_X1EPB) x_a1GhZ -> PolySing [DTerm ts_a1EPy us_a1EPz vs_a1EPB a_X1EPB] x_a1Gjm -> SDTerm ts_a1EPy us_a1EPz vs_a1EPB ((:$) ( 'List :: DType ts_a1EPy us_a1EPz ((:~>) ( 'Type :: DKind ts_a1EPy  'Kind) ( 'Type :: DKind ts_a1EPy  'Kind))) a_X1EPB) ( 'ListLit x_a1GhZ x_a1Gjm)
[SOptionalLit] :: forall (ts_a1EPC :: [DSort]) (us_a1EPD :: [DKind ts_a1EPC  'Kind]) (a_X1EPF :: DType ts_a1EPC us_a1EPD ( 'Type :: DKind ts_a1EPC  'Kind)) (vs_a1EPF :: [DType ts_a1EPC us_a1EPD ( 'Type :: DKind ts_a1EPC  'Kind)]) x_a1GqO x_a1Gsb. () => PolySing (NDType ts_a1EPC us_a1EPD ( 'Type :: DKind ts_a1EPC  'Kind) a_X1EPF) x_a1GqO -> PolySing (Maybe (DTerm ts_a1EPC us_a1EPD vs_a1EPF a_X1EPF)) x_a1Gsb -> SDTerm ts_a1EPC us_a1EPD vs_a1EPF ((:$) ( 'Optional :: DType ts_a1EPC us_a1EPD ((:~>) ( 'Type :: DKind ts_a1EPC  'Kind) ( 'Type :: DKind ts_a1EPC  'Kind))) a_X1EPF) ( 'OptionalLit x_a1GqO x_a1Gsb)
data SAggType (k_a1Cly :: Type) (ls_a1Clz :: [Text]) (as_a1ClA :: [k_a1Cly]) (x_a1CqD :: AggType (k_a1Cly :: Type) (ls_a1Clz :: [Text]) (as_a1ClA :: [k_a1Cly]))
[SATZ] :: forall (k_a1ClB :: Type). () => SAggType k_a1ClB ('[] :: [Text]) ('[] :: [k_a1ClB])  'ATZ
[SATS] :: forall (k_a1ClC :: Type) (l_X1ClE :: Text) (a_X1ClG :: k_a1ClC) (ls_X1ClI :: [Text]) (as_X1ClK :: [k_a1ClC]) x_a1CqE x_a1CqG x_a1CqJ. () => SingSing Text l_X1ClE ( 'WS x_a1CqE) -> PolySing (WrappedSing k_a1ClC a_X1ClG) x_a1CqG -> SAggType k_a1ClC ls_X1ClI as_X1ClK x_a1CqJ -> SAggType k_a1ClC ( '(:) l_X1ClE ls_X1ClI) ( '(:) a_X1ClG as_X1ClK) ( 'ATS x_a1CqE x_a1CqG x_a1CqJ)
sShift :: SInsert us qs a ins -> SDType ts us b x -> SDType ts qs b (Shift ts us qs a b ins x)
sShift1 :: SDType ts us b x -> SDType ts (a : us) b (Shift ts us (a : us) a b  'InsZ x)
skNormalize :: SDKind ts a x -> SDKind ts a (KNormalize ts a x)
stNormalize :: SDType ts us a x -> SDType ts us a (TNormalize ts us a x)
data KShiftSym ts ps a b :: Insert ts ps a -> DKind ts b ~> DKind ps b
data ShiftSym ts us qs a b :: Insert us qs a -> DType ts us b ~> DType ts qs b
type family Map (f :: a ~> b) (xs :: [a]) :: [b]
data MapSym (f :: a ~> b) :: [a] ~> [b]

module Dhall.Typed
toTyped :: forall ts us vs. () => Context ts us vs -> Expr () X -> Either TypeMessage (SomeDExpr ts us vs)
fromTyped :: DExpr ts us vs n -> Expr () X
fromDTerm :: DTerm ts us vs a -> Expr () X
fromDType :: DType ts us a -> Expr () X
fromDKind :: DKind ts a -> Expr () X
fromDSort :: DSort -> Expr () X
