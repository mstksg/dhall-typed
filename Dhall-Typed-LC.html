<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Dhall.Typed.LC</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Dhall.Typed.LC.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">dhall-typed-0.1.0.0</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Justin Le 2019</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>justin@jle.im</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>non-portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Dhall.Typed.LC</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Implementing a typed lambda calculus.  Uses De Bruijn indices in
 separate namespaces (that is, kind, type, term variables all have
 their own separate De Bruijn indexing)</p><p>We have a hierarchy: Term -&gt; Type -&gt; Kind -&gt; Sort.  We can stop at Sort
 because we don't allow any Sort variables, so there is no need to talk
 about the &quot;type&quot; of any Sorts.  Disallowing variables effectively stops
 the chain.</p><p>It looks like each level has some sets of constructors just from its
 position on the chain.</p><ul><li>At all levels, we have <em>primitives</em>.  Term-level primitives are
    built-in functions and values and literals.  Type-level primitives
    are built-in types and type functions.  Dhall has no kind- or
    sort-level primitives.</li><li><p>If a level has variables (Terms, Types, Kinds), we gain some
    constructors:</p><ul><li>Var, the variable constructor
j  Lam, the function abstraction</li><li>App, the function application</li></ul></li><li><p>If a level has variables and its &quot;type&quot; also has variables (Terms,
    Types), we gain some constructors:</p><ul><li>Poly, the type abstraction</li><li>Inst (instantiation), the type application</li></ul></li><li>If a level is the &quot;type&quot; of something (n &gt;= 1), we gain a function
    type constructor, the type of function abstractions in the
    immediately lower level.</li><li>If a level is the &quot;type&quot; of a &quot;type&quot; of something (n &gt;= 2), we gain
    an &quot;constant&quot; constructor that links the two layers below it
    together. Examples are the Kind sort that links Kinds to Types (all
    types have kinds of sort Kind), and the Type kind that links types to
    values (all terms have types of kind Type)</li><li>If a type is the &quot;type&quot; of something (n &gt;= 1), <em>and</em> it has
    variables, we have a Pi type constructor, the type of type
    abstractions (type-polymorphic values) in the lower level.</li></ul><p>We actually gain a Pi type for our current level, and each level
    above our current level (that has variables).  So for the Type level,
    we have Type-Pi and Kind-Pi, and for the Kind level, we have Kind-Pi.</p><p>So to summarize:</p><ul><li>n = 3: Sort has a constant (it is n &gt;= 2) and a function
    type constructor (it is n &gt;= 1).  It could also potentially have
    primitives, but Dhall has no sort primitives.</li><li>n = 2: Kind has variables, so it has Var, Lam, and App.  It has
    a constant (they are n &gt;= 2) and a function type constructor and a Pi
    constructor (it is n &gt;= 1 and has variables).  It could also
    potentially have primitives; Dhall has only record and union kinds as
    primitives.</li><li>n = 1: Type has variables, so it has Var, Lam, and App.  It has
    a function type constructor and a Pi constructor (it is n &gt;= 1 and
    has variables).  Because its &quot;type&quot; has variables (Kind), it also has
    Poly and Inst.  It has primitives, and in Dhall ther are several.</li><li>n = 0: Term has variables, so it has Var, Lam, and App.  Because its
    &quot;type&quot; has variables, it has Poly and Inst.  In Dhall, it has
    multitudes of primitives.</li></ul></div></div><div id="interface"></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>