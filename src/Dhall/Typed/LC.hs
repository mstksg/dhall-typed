{-# LANGUAGE GADTs                    #-}
{-# LANGUAGE KindSignatures           #-}
{-# LANGUAGE LambdaCase               #-}
{-# LANGUAGE RankNTypes               #-}
{-# LANGUAGE TypeFamilyDependencies   #-}
{-# LANGUAGE TypeInType               #-}
{-# LANGUAGE TypeOperators            #-}
{-# LANGUAGE UndecidableInstances     #-}
{-# OPTIONS_GHC -Wno-missing-methods  #-}
{-# OPTIONS_GHC -Wno-unused-top-binds #-}

-- |
-- Module      : Dhall.Typed.LC
-- Copyright   : (c) Justin Le 2019
-- License     : BSD3
--
-- Maintainer  : justin@jle.im
-- Stability   : experimental
-- Portability : non-portable
--
-- Implementing a typed lambda calculus.  Uses De Bruijn indices in
-- separate namespaces (that is, kind, type, term variables all have
-- their own separate De Bruijn indexing)
--
-- We have a hierarchy: Term -> Type -> Kind -> Sort.  We can stop at Sort
-- because we don't allow any Sort variables, so there is no need to talk
-- about the "type" of any Sorts.  Disallowing variables effectively stops
-- the chain.
--
-- It looks like each level has some sets of constructors just from its
-- position on the chain.
--
-- *  At all levels, we have /primitives/.  Term-level primitives are
--    built-in functions and values and literals.  Type-level primitives
--    are built-in types and type functions.  Dhall has no kind- or
--    sort-level primitives.
--
-- *  If a level has variables (Terms, Types, Kinds), we gain some
--    constructors:
--
--     *  Var, the variable constructor
--     j  Lam, the function abstraction
--     *  App, the function application
--
-- *  If a level has variables and its "type" also has variables (Terms,
--    Types), we gain some constructors:
--
--     *  Poly, the type abstraction
--     *  Inst (instantiation), the type application
--
-- *  If a level is the "type" of something (n >= 1), we gain a function
--    type constructor, the type of function abstractions in the
--    immediately lower level.
--
-- *  If a level is the "type" of a "type" of something (n >= 2), we gain
--    an "constant" constructor that links the two layers below it
--    together. Examples are the Kind sort that links Kinds to Types (all
--    types have kinds of sort Kind), and the Type kind that links types to
--    values (all terms have types of kind Type)
--
-- *  If a type is the "type" of something (n >= 1), /and/ it has
--    variables, we have a Pi type constructor, the type of type
--    abstractions (type-polymorphic values) in the lower level.
--
--    We actually gain a Pi type for our current level, and each level
--    above our current level (that has variables).  So for the Type level,
--    we have Type-Pi and Kind-Pi, and for the Kind level, we have Kind-Pi.
--
--
-- So to summarize:
--
-- *  n = 3: Sort has a constant (it is n >= 2) and a function
--    type constructor (it is n >= 1).  It could also potentially have
--    primitives, but Dhall has no sort primitives.
--
-- *  n = 2: Kind has variables, so it has Var, Lam, and App.  It has
--    a constant (they are n >= 2) and a function type constructor and a Pi
--    constructor (it is n >= 1 and has variables).  It could also
--    potentially have primitives; Dhall has only record and union kinds as
--    primitives.
--
-- *  n = 1: Type has variables, so it has Var, Lam, and App.  It has
--    a function type constructor and a Pi constructor (it is n >= 1 and
--    has variables).  Because its "type" has variables (Kind), it also has
--    Poly and Inst.  It has primitives, and in Dhall ther are several.
--
-- *  n = 0: Term has variables, so it has Var, Lam, and App.  Because its
--    "type" has variables, it has Poly and Inst.  In Dhall, it has
--    multitudes of primitives.

module Dhall.Typed.LC () where

-- module Dhall.Typed.LC (
--   ) where

import           Data.Kind
import           Data.Singletons
import           Dhall.Typed.Type.Index
import           Dhall.Typed.Type.N
import           Dhall.Typed.Type.Prod
import           Dhall.Typed.Type.Singletons

type family Map (f :: a ~> b) (xs :: [a]) :: [b] where
    Map f '[]       = '[]
    Map f (x ': xs) = f @@ x ': Map f xs

-- newtype SingSing k x :: PolySing k x -> Type where
--     SingSing :: forall k (x :: k) (s :: PolySing k x). PolySing k x -> SingSing k x s

-- Implementing the rule pairings:
--
--
-- 1. Type ↝ Type : Type
--
--    * Functions from terms to terms (ordinary functions)
--    * Type represented by: (:->)
--    * Generated by:        Lam
--    * Eliminated by:       App
--
-- 2. Kind ↝ Type : Type
--
--    * Functions from types to terms (type-polymorphic functions)
--    * Type represented by: Pi
--    * Generated by:        Poly
--    * Eliminated by:       Inst
--
-- 3. Sort ↝ Type : Type
--
--    * Functions from kinds to terms
--    * Type represented by: N/A
--    * Generated by:        N/A
--    * Eliminated by:       N/A
--
--    I don't know how to implement these! :(
--
-- 4. Kind ↝ Kind : Kind
--
--    * Functions from types to types (type-level functions)
--    * Type represented by: (:~>)
--    * Generated by:        TLam
--    * Eliminated by:       TApp
--
-- 5. Sort ↝ Kind : Sort
--
--    * Functions from kinds to types (kind-polymorphic functions)
--    * Type represented by: KPi
--    * Generated by:        TPoly
--    * Eliminated by:       TInst
--
-- 6. Sort ↝ Sort : Sort
--
--    * Functions from kinds to kinds (kind-level functions)
--    * Type represented by: (:*>)
--    * Generated by:        KLam
--    * Eliminated by:       KApp

-- ---------
-- > Sorts
-- ---------

-- | Level 3:
--
-- *  n = 3: Sort has a constant (it is n >= 2) and a function
--    type constructor (it is n >= 1).  It could also potentially have
--    primitives, but Dhall has no sort primitives.
data DSort = Kind | DSort :*> DSort

-- ---------
-- > Kinds
-- ---------

-- | Level 2
--
-- *  n = 2: Kind has variables, so it has Var, Lam, and App.  It has
--    a constant (they are n >= 2) and a function type constructor and a Pi
--    constructor (it is n >= 1 and has variables).  It could also
--    potentially have primitives; Dhall has only record and union kinds as
--    primitives.
--
-- Because Sort has no variables, it has no Poly and Inst.
data DKind :: [DSort] -> DSort -> Type where
    -- Standard value stuff
    KVar  :: Index ts a -> DKind ts a
    KLam  :: SDSort t -> DKind (t ': ts) a -> DKind ts (t ':*> a)
    KApp  :: DKind ts (a ':*> b) -> DKind ts a -> DKind ts b
    -- KP    :: KPrim as a -> Prod (DKind ts) as -> DKind ts a

    -- From being a type of something
    (:~>) :: DKind ts 'Kind -> DKind ts 'Kind -> DKind ts 'Kind
    KPi   :: SDSort t -> DKind (t ': ts) a -> DKind ts a

    -- From being a type of a type of something
    Type  :: DKind ts 'Kind

-- type a :~> b = 'KP 'KFun (a ':< b ':< 'Ø)

type family KShift ts t a (x :: DKind ts a) :: DKind (t ': ts) a where

type family KSub ts rs a b (del :: Delete ts rs a) (x :: DKind rs a) (r :: DKind ts b) :: DKind rs b where

-- ---------
-- > Types
-- ---------

data TPrim ts :: [DKind ts 'Kind] -> DKind ts 'Kind -> Type where
    Bool :: TPrim ts '[] 'Type
    List :: TPrim ts '[] ('Type ':~> 'Type)

-- | Level 1
--
-- *  n = 1: Type has variables, so it has Var, Lam, and App.  It has
--    a function type constructor and a Pi constructor (it is n >= 1 and
--    has variables).  Because its "type" has variables (Kind), it also has
--    Poly and Inst.  It has primitives, and in Dhall ther are several.
--
-- Because it is not n >= 2, it has no constant.
data DType ts :: [DKind ts 'Kind] -> DKind ts 'Kind -> Type where
    -- Standard value stuff
    TVar  :: Index us a -> DType ts us a
    TLam  :: SDKind ts 'Kind u -> DType ts (u ': us) a -> DType ts us (u ':~> a)
    TApp  :: DType ts us (a ':~> b) -> DType ts us a -> DType ts us b
    TP    :: TPrim ts as a -> Prod (DType ts us) as -> DType ts us a

    -- From having a type with variables
    -- TPoly :: SDSort t
    --       -> DType (t ': ts) (Map (KShiftSym ts t 'Kind) us) a
    --       -> DType ts        us                              ('KPi (SDSortOf t) a)
    -- TInst :: DType ts us ('KPi (SDSortOf t) b)
    --       -> SDKind ts t a
    --       -> DType ts us (KSub (t ': ts) ts t 'Kind 'DelZ a b)

    -- From being a type of something
    (:->) :: DType ts us 'Type -> DType ts us 'Type -> DType ts us 'Type
    Pi    :: SDKind ts 'Kind u -> DType ts (u ': us) a -> DType ts us a
    -- TODO
    -- Pi2   :: SDSort t
    --       -> DType (t ': ts) (Map (KShiftSym ts t 'Kind) us) (KShift ts t 'Kind a)
    --       -> DType ts        us                              a


type TBool   = 'TP 'Bool 'Ø

-- ---------
-- > Terms
-- ---------

data Prim ts us :: [DType ts us 'Type] -> DType ts us 'Type -> Type where
    BoolLit :: Bool -> Prim ts us '[] TBool
    BoolAnd :: Prim ts us '[TBool, TBool] TBool
    BoolNot :: Prim ts us '[] (TBool ':-> TBool)

type family Shift ts us u a (x :: DType ts us a) :: DType ts (u ': us) a where

type family Sub ts us qs a b (del :: Delete us qs a) (x :: DType ts qs a) (r :: DType ts us b) :: DType ts qs b where

-- | Level 0
--
-- *  n = 0: Term has variables, so it has Var, Lam, and App.  Because its
--    "type" has variables, it has Poly and Inst.  In Dhall, it has
--    multitudes of primitives.
--
-- Because it is not n >= 2 or n >= 1, it has no Pi or Function constructor
-- or constant.
data DTerm ts (us :: [DKind ts 'Kind]) :: [DType ts us 'Type] -> DType ts us 'Type -> Type where
    -- Standard value stuff
    Var  :: Index vs a -> DTerm ts us vs a
    Lam  :: SDType ts us 'Type v -> DTerm ts us (v ': vs) a -> DTerm ts us vs (v ':-> a)
    App  :: DTerm ts us vs (a ':-> b) -> DTerm ts us vs a -> DTerm ts us vs b
    P    :: Prim ts us as a -> Prod (DTerm ts us vs) as -> DTerm ts us vs a

    -- From having a type with variables
    -- Poly :: SDKind ts 'Kind u
    --      -> DTerm ts (u ': us) (Map (ShiftSym ts us u 'Type) vs) a
    --      -> DTerm ts us vs ('Pi (SDKindOf ts 'Kind u) a)
    -- Inst :: DTerm ts us vs ('Pi (SDKindOf ts 'Kind u) b)
    --      -> SDType ts us u a
    --      -> DTerm ts us vs (Sub ts (u ': us) us u 'Type 'DelZ a b)

-- ----------------
-- > Multiple Level
-- ----------------

data SomeKind :: [DSort] -> Type where
    SomeKind :: SDSort a -> DKind ts a -> SomeKind ts

data SomeType ts :: [DKind ts 'Kind] -> Type where
    SomeType :: SDKind ts 'Kind a -> DType ts us a -> SomeType ts us

data SomeTerm ts us :: [DType ts us 'Type] -> Type where
    SomeTerm :: SDType ts us 'Type a -> DTerm ts us vs a -> SomeTerm ts us vs

data DExpr ts us :: [DType ts us 'Type] -> N -> Type where
    DESort :: DSort             -> DExpr ts us vs ('S ('S ('S 'Z)))
    DEKind :: SomeKind ts       -> DExpr ts us vs ('S ('S 'Z))
    DEType :: SomeType ts us    -> DExpr ts us vs ('S 'Z)
    DETerm :: SomeTerm ts us vs -> DExpr ts us vs 'Z

dExprType :: DExpr ts us vs n -> DExpr ts us vs ('S n)
dExprType = \case
    DESort _ -> error "Sort has no type, kind, or sort"
    DEKind (SomeKind t _) -> DESort (fromSing (SDS t))
    DEType (SomeType t _) -> DEKind (SomeKind SKind (fromSing (SDK  t)))
    DETerm (SomeTerm t _) -> DEType (SomeType SType (fromSing (SDTy t)))


-- ---------
-- > Boring singleton shenanigans
-- ---------

data SDSort :: DSort -> Type where
    SKind :: SDSort 'Kind
    (:%*>) :: SDSort s -> SDSort t -> SDSort (s ':*> t)

type instance PolySing DSort = SDSort
-- type instance PolySing (SDSort t) = SingSing DSort t

data SDKind ts a :: DKind ts a -> Type where
    SKVar  :: SIndex ts a i -> SDKind ts a ('KVar i)
    SKLam  :: SingSing DSort t ('WS tt)
           -> SDKind (t ': ts) a x
           -> SDKind ts (t ':*> a) ('KLam tt x)
    SKApp  :: SDKind ts (a ':*> b) f -> SDKind ts a x -> SDKind ts b ('KApp f x)
    (:%~>) :: SDKind ts 'Kind x -> SDKind ts 'Kind y -> SDKind ts 'Kind (x ':~> y)
    SType  :: SDKind ts 'Kind 'Type

type instance PolySing (DKind ts a) = SDKind ts a

data instance Sing (x :: DSort) where
    SDS :: { getSDS :: SDSort x } -> Sing x

instance SingKind DSort where
    type Demote DSort = DSort

-- type family SDKindOf ts k (x :: DKind ts k) = (y :: SDKind ts k x) | y -> x where
--     SDKindOf ts k          ('KVar i  ) = 'SKVar (SIndexOf ts k i)

data KShiftSym ts t a :: DKind ts a ~> DKind (t ': ts) a

data instance Sing (x :: DKind ts a) where
    SDK :: { getSDK :: SDKind ts a x } -> Sing x

instance SingKind (DKind ts a) where
    type Demote (DKind ts a) = DKind ts a

data STPrim ts as a :: TPrim ts as a -> Type where
    SBool :: STPrim ts '[] 'Type 'Bool
    SList :: STPrim ts '[] ('Type ':~> 'Type) 'List

data SDType ts us a :: DType ts us a -> Type where
    STVar  :: SIndex us a i -> SDType ts us a ('TVar i)
    STLam  :: SingSing (DKind ts 'Kind) u ('WS uu)
           -> SDType ts (u ': us) a x
           -> SDType ts us (u ':~> a) ('TLam uu x)
    STApp  :: SDType ts us (a ':~> b) f
           -> SDType ts us a         x
           -> SDType ts us b         ('TApp f x)
    (:%->) :: SDType ts us 'Type x
           -> SDType ts us 'Type y
           -> SDType ts us 'Type (x ':-> y)
    STP    :: STPrim ts as a x -> SProd (DType ts us) as p -> SDType ts us a ('TP x p)

data ShiftSym ts us u a :: DType ts us a ~> DType ts (u ': us) a

data instance Sing (x :: DType ts vs a) where
    SDTy :: { getSDTy :: SDType ts vs a x } -> Sing x

instance SingKind (DType ts vs a) where
    type Demote (DType ts vs a) = DType ts vs a
