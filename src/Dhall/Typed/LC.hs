{-# LANGUAGE GADTs                  #-}
{-# LANGUAGE KindSignatures         #-}
{-# LANGUAGE LambdaCase             #-}
{-# LANGUAGE TypeFamilyDependencies #-}
{-# LANGUAGE TypeInType             #-}
{-# LANGUAGE TypeOperators          #-}

module Dhall.Typed.LC where

-- module Dhall.Typed.LC (
--   ) where

import           Data.Kind
import           Dhall.Typed.Prod
import           Dhall.Typed.Index hiding (SDS)
import qualified Dhall.Typed.Index as I
import           Dhall.Typed.N
import           Data.Singletons

type family Map (f :: a ~> b) (xs :: [a]) :: [b] where
    Map f '[]       = '[]
    Map f (x ': xs) = f @@ x ': Map f xs

-- Implementing the rule pairings:
--
--
-- 1. Type ↝ Type : Type
--
--    * Functions from terms to terms (ordinary functions)
--    * Type represented by: (:->)
--    * Generated by:        Lam
--    * Eliminated by:       App
--
-- 2. Kind ↝ Type : Type
--
--    * Functions from types to terms (type-polymorphic functions)
--    * Type represented by: Pi
--    * Generated by:        Poly
--    * Eliminated by:       Inst
--
-- 3. Sort ↝ Type : Type
--
--    * Functions from kinds to terms
--    * Type represented by: N/A
--    * Generated by:        N/A
--    * Eliminated by:       N/A
--
-- 4. Kind ↝ Kind : Kind
--
--    * Functions from types to types (type-level functions)
--    * Type represented by: (:~>)
--    * Generated by:        TLam
--    * Eliminated by:       TApp
--    
-- 5. Sort ↝ Kind : Sort
--
--    * Functions from kinds to types (kind-polymorphic functions)
--    * Type represented by: KPi
--    * Generated by:        TPoly
--    * Eliminated by:       TInst
--
-- 6. Sort ↝ Sort : Sort
--
--    * Functions from kinds to kinds (kind-level functions)
--    * Type represented by: (:*>)
--    * Generated by:        KLam
--    * Eliminated by:       KApp

-- ---------
-- | Sorts
-- ---------

-- | Level 3:
--
-- * Only "primitives", essentially.
-- * No Var, Lam, Pi
data DSort = Kind | DSort :*> DSort

-- ---------
-- | Kinds
-- ---------

data KPrim :: [DSort] -> DSort -> Type where
    KApp :: KPrim '[a ':*> b, a] b
    KFun :: KPrim '[ 'Kind, 'Kind ] 'Kind
    Type :: KPrim '[] 'Kind

-- | Level 2
--
-- Just has a single Pi constructor for kind polymorphism, since we don't
-- have sort polymorphism.
data DKind :: [DSort] -> DSort -> Type where
    KVar :: Index ts a -> DKind ts a
    KLam :: SDSort t -> DKind (t ': ts) a -> DKind ts (t ':*> a)
    KPi  :: SDSort t -> DKind (t ': ts) a -> DKind ts a
    KP   :: KPrim as a -> Prod (DKind ts) as -> DKind ts a

type a :~> b = 'KP 'KFun (a ':< b ':< 'Ø)
type KType   = 'KP 'Type 'Ø

type family KShift ts t a (x :: DKind ts a) :: DKind (t ': ts) a where

type family KSub ts rs a b (del :: Delete ts rs a) (x :: DKind rs a) (r :: DKind ts b) :: DKind rs b where

-- ---------
-- | Types
-- ---------

data TPrim ts :: [DKind ts 'Kind] -> DKind ts 'Kind -> Type where
    TApp :: TPrim ts '[a :~> b, a] b
    TFun :: TPrim ts '[KType, KType] KType
    Bool :: TPrim ts '[] KType
    List :: TPrim ts '[ KType ] KType

-- | Level 1
data DType ts :: [DKind ts 'Kind] -> DKind ts 'Kind -> Type where
    TVar  :: Index us a -> DType ts us a
    TLam  :: SDKind ts 'Kind u -> DType ts (u ': us) a -> DType ts us (u :~> a)
    Pi    :: SDKind ts 'Kind u -> DType ts (u ': us) a -> DType ts us a
    -- Pi2   :: SDSort t
    --       -> DType (t ': ts) (Map (KShiftSym ts t 'Kind) us) (KShift ts t 'Kind a)
    --       -> DType ts        us                              a
    TPoly :: SDSort t
          -> DType (t ': ts) (Map (KShiftSym ts t 'Kind) us) a
          -> DType ts        us                              ('KPi (SDSortOf t) a)
    TInst :: DType ts us ('KPi (SDSortOf t) b)
          -> SDKind ts t a
          -> DType ts us (KSub (t ': ts) ts t 'Kind 'DZ a b)
    TP    :: TPrim ts as a -> Prod (DType ts us) as -> DType ts us a

type a :-> b = 'TP 'TFun (a ':< b ':< 'Ø)
type TBool   = 'TP 'Bool 'Ø

-- ---------
-- | Terms
-- ---------

data Prim ts us :: [DType ts us KType] -> DType ts us KType -> Type where
    App     :: Prim ts us '[ a :-> b, a ] b
    BoolLit :: Bool -> Prim ts us '[] TBool
    BoolAnd :: Prim ts us '[TBool, TBool] TBool
    BoolNot :: Prim ts us '[] (TBool :-> TBool)

type family Shift ts us u a (x :: DType ts us a) :: DType ts (u ': us) a where

type family Sub ts us qs a b (del :: Delete us qs a) (x :: DType ts qs a) (r :: DType ts us b) :: DType ts qs b where

-- | Level 0
--
-- Distinguished from the others by having no Pi constructor.
data DTerm ts (us :: [DKind ts 'Kind]) :: [DType ts us KType] -> DType ts us KType -> Type where
    Var  :: Index vs a -> DTerm ts us vs a
    Lam  :: SDType ts us KType v -> DTerm ts us (v ': vs) a -> DTerm ts us vs (v :-> a)
    Poly :: SDKind ts 'Kind u
         -> DTerm ts (u ': us) (Map (ShiftSym ts us u KType) vs) a
         -> DTerm ts us vs ('Pi (SDKindOf ts 'Kind u) a)
    Inst :: DTerm ts us vs ('Pi (SDKindOf ts 'Kind u) b)
         -> SDType ts us u a
         -> DTerm ts us vs (Sub ts (u ': us) us u KType 'DZ a b)
    P    :: Prim ts us as a -> Prod (DTerm ts us vs) as -> DTerm ts us vs a

-- ----------------
-- | Multiple Level
-- ----------------

data SomeKind :: [DSort] -> Type where
    SomeKind :: SDSort a -> DKind ts a -> SomeKind ts

data SomeType ts :: [DKind ts 'Kind] -> Type where
    SomeType :: SDKind ts 'Kind a -> DType ts us a -> SomeType ts us

data SomeTerm ts us :: [DType ts us KType] -> Type where
    SomeTerm :: SDType ts us KType a -> DTerm ts us vs a -> SomeTerm ts us vs

data DExpr ts us :: [DType ts us KType] -> N -> Type where
    DESort :: DSort             -> DExpr ts us vs ('S ('S ('S 'Z)))
    DEKind :: SomeKind ts       -> DExpr ts us vs ('S ('S 'Z))
    DEType :: SomeType ts us    -> DExpr ts us vs ('S 'Z)
    DETerm :: SomeTerm ts us vs -> DExpr ts us vs 'Z

dExprType :: DExpr ts us vs n -> DExpr ts us vs ('S n)
dExprType = \case
    DESort _ -> error "Sort has no type, kind, or sort"
    DEKind (SomeKind t _) -> DESort (fromSing (SDS t))
    DEType (SomeType t _) -> DEKind (SomeKind SKind          (fromSing (SDK  t)))
    DETerm (SomeTerm t _) -> DEType (SomeType (SKP SType SØ) (fromSing (SDTy t)))


-- ---------
-- | Boring singleton shenanigans
-- ---------

data SDSort :: DSort -> Type where
    SKind :: SDSort 'Kind
    (:%*>) :: SDSort s -> SDSort t -> SDSort (s ':*> t)

type family SDSortOf (k :: DSort) = (s :: SDSort k) | s -> k where
    SDSortOf 'Kind = 'SKind
    SDSortOf (a ':*> b) = SDSortOf a ':%*> SDSortOf b

data SKPrim as a :: KPrim as a -> Type where
    SKApp :: SKPrim '[ a ':*> b, a ] b 'KApp
    SKFun :: SKPrim '[ 'Kind, 'Kind ] 'Kind 'KFun
    SType :: SKPrim '[] 'Kind 'Type

data SDKind ts a :: DKind ts a -> Type where
    SKVar :: SIndex ts a i -> SDKind ts a ('KVar i)
    SKLam :: SDSort t -> SDKind (t ': ts) a x -> SDKind ts (t ':*> a) ('KLam (SDSortOf t) x)
    SKP   :: SKPrim as a x -> SProd (DKind ts) as p -> SDKind ts a ('KP x p)

data instance Sing (x :: DSort) where
    SDS :: { getSDS :: SDSort x } -> Sing x

instance SingKind DSort where
    type Demote DSort = DSort

type family SDKindOf ts k (x :: DKind ts k) = (y :: SDKind ts k x) | y -> x where
    SDKindOf ts k          ('KVar i  ) = 'SKVar (SIndexOf ts k i)

data KShiftSym ts t a :: DKind ts a ~> DKind (t ': ts) a

data instance Sing (x :: DKind ts a) where
    SDK :: { getSDK :: SDKind ts a x } -> Sing x

instance SingKind (DKind ts a) where
    type Demote (DKind ts a) = DKind ts a

data STPrim ts as a :: TPrim ts as a -> Type where
    STApp :: STPrim ts '[ a :~> b, a ] b 'TApp
    STFun :: STPrim ts '[ KType, KType ] KType 'TFun
    SBool :: STPrim ts '[] KType 'Bool
    SList :: STPrim ts '[KType] KType 'List

data SDType ts us a :: DType ts us a -> Type where
    STVar  :: SIndex us a i -> SDType ts us a ('TVar i)
    STLam  :: SDKind ts 'Kind u
           -> SDType ts (u ': us) a x
           -> SDType ts us (u :~> a) ('TLam (SDKindOf ts 'Kind u) x)
    STP    :: STPrim ts as a x -> SProd (DType ts us) as p -> SDType ts us a ('TP x p)

data ShiftSym ts us u a :: DType ts us a ~> DType ts (u ': us) a

data instance Sing (x :: DType ts vs a) where
    SDTy :: { getSDTy :: SDType ts vs a x } -> Sing x

instance SingKind (DType ts vs a) where
    type Demote (DType ts vs a) = DType ts vs a
