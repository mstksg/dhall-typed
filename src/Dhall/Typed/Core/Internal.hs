{-# LANGUAGE AllowAmbiguousTypes     #-}
{-# LANGUAGE BangPatterns            #-}
{-# LANGUAGE EmptyCase               #-}
{-# LANGUAGE FlexibleContexts        #-}
{-# LANGUAGE FlexibleInstances       #-}
{-# LANGUAGE FunctionalDependencies  #-}
{-# LANGUAGE GADTs                   #-}
{-# LANGUAGE InstanceSigs            #-}
{-# LANGUAGE KindSignatures          #-}
{-# LANGUAGE LambdaCase              #-}
{-# LANGUAGE MultiParamTypeClasses   #-}
{-# LANGUAGE OverloadedStrings       #-}
{-# LANGUAGE PolyKinds               #-}
{-# LANGUAGE QuantifiedConstraints   #-}
{-# LANGUAGE RankNTypes              #-}
{-# LANGUAGE RecordWildCards         #-}
{-# LANGUAGE ScopedTypeVariables     #-}
{-# LANGUAGE StandaloneDeriving      #-}
{-# LANGUAGE TemplateHaskell         #-}
{-# LANGUAGE TypeApplications        #-}
{-# LANGUAGE TypeFamilies            #-}
{-# LANGUAGE TypeFamilyDependencies  #-}
{-# LANGUAGE TypeInType              #-}
{-# LANGUAGE TypeOperators           #-}
{-# LANGUAGE TypeSynonymInstances    #-}
{-# LANGUAGE UndecidableInstances    #-}
{-# LANGUAGE ViewPatterns            #-}
{-# OPTIONS_GHC -Wno-missing-methods #-}

module Dhall.Typed.Core.Internal (
  -- * Expression
  -- ** Sorts
    DSort(..)
  -- ** Kinds
  , DKind(..), SomeKind(..), type (:~>), KShift, toSomeKind, KNormalize, NDKind(..), KSub, SubbedKind(..)
  -- ** Types
  , DType(..), SomeType(..), type (:$), type (:->), Shift, toSomeType, TNormalize, NDType(..), Sub
  -- ** Terms
  , Prim(..), DTerm(..), SomeTerm(..), toSomeTerm
  -- ** Shared
  , AggType(..), Bindings(..)
  -- * Singletons
  , SDSort(..)
  , SDKind(..), SNDKind(..), SSubbedKind(..)
  , SDType(..), SNDType(..)
  , SPrim(..), SDTerm(..)
  , SAggType(..)
  , KShiftSym, KSubSym, ShiftSym
  -- * Util
  , Map, MapSym
  ) where

-- module Dhall.Typed.Core (
--   -- * Kinds
--     DKind(..), SDKind(..), SDKindI(..), sameDKind
--   -- * Types
--   , DType(..), SomeType(..), SDType(..), SDTypeI(..), sameDType, sameDTypeWith, kindOf, kindOfWith
--   , Sub, Shift, MapShift
--   -- * Terms
--   , DTerm(..), Bindings(..), SomeTerm(..), SDTerm(..), SeqListEq(..), typeOf, typeOfWith
--   -- * Expr
--   , SomeExpr(..)
--   -- * Evaluation
--   , DTypeRep, Forall(..), ForallTC(..), DTypeRepVal(..)
--   , fromTerm, fromTermWith, toTerm
--   -- * Manipulation
--   , sShift, sShift_, subIns, subIns2, sSub, sSub_, shiftProd
--   -- * Singletons
--   , Sing(SDK, getSDK, SDTy, getSDTy, SDTe, getSDTe)
--   ) where

import           Data.Kind
import           Data.Sequence                      (Seq(..))
import           Data.Singletons.Prelude.Maybe      (Maybe_)
import           Data.Singletons.TH hiding          (Sum)
import           Data.Text                          (Text)
import           Data.Type.Universe
import           Dhall.Typed.Type.Index
import           Dhall.Typed.Type.N
import           Dhall.Typed.Type.Prod
import           Dhall.Typed.Type.Singletons hiding (SNatural)
import           Dhall.Typed.Type.Singletons.TH
import           Numeric.Natural
import qualified Data.Sequence                      as Seq
import qualified GHC.TypeLits                       as TL

type family Map (f :: a ~> b) (xs :: [a]) :: [b] where
    Map f '[]       = '[]
    Map f (x ': xs) = f @@ x ': Map f xs

data MapSym (f :: a ~> b) :: [a] ~> [b]
type instance Apply (MapSym f) xs = Map f xs

-- Implementing the rule pairings:
--
--
-- 1. Type ↝ Type : Type
--
--    * Functions from terms to terms (ordinary functions)
--    * Type represented by: (:->)
--    * Generated by:        Lam
--    * Eliminated by:       App
--
-- 2. Kind ↝ Type : Type
--
--    * Functions from types to terms (type-polymorphic functions)
--    * Type represented by: Pi
--    * Generated by:        Poly
--    * Eliminated by:       Inst
--
-- 3. Sort ↝ Type : Type
--
--    * Functions from kinds to terms
--    * Type represented by: N/A
--    * Generated by:        N/A
--    * Eliminated by:       N/A
--
--    I don't know how to implement these! :(
--
-- 4. Kind ↝ Kind : Kind
--
--    * Functions from types to types (type-level functions)
--    * Type represented by: (:~>)
--    * Generated by:        TLam
--    * Eliminated by:       TApp
--
-- 5. Sort ↝ Kind : Sort
--
--    * Functions from kinds to types (kind-polymorphic functions)
--    * Type represented by: KPi
--    * Generated by:        TPoly
--    * Eliminated by:       TInst
--
-- 6. Sort ↝ Sort : Sort
--
--    * Functions from kinds to kinds (kind-level functions)
--    * Type represented by: (:*>)
--    * Generated by:        KLam
--    * Eliminated by:       KApp

-- ---------
-- > Shared
-- ---------

-- | Meta-level type describing a collection or aggregation of types.  Used
-- for specifying records and unions.
--
-- Currently does not check for uniqueness.  But it should hopefully some
-- day.  The tricky part is finding a witness type that works both at the
-- term level and at the lifted type level.
data AggType k (ls :: [Text]) (as :: [k]) where
    ATZ :: AggType k '[] '[]
    ATS :: SText l              -- TODO: add uniqueness
        -> WrappedSing k (a :: k)
        -> AggType k ls as
        -> AggType k (l ': ls) (a ': as)

genPolySingWith defaultGPSO
  { gpsoPSK    = GOHead [d| instance PolySingKind (AggType k ls as) |]
  , gpsoSingEq = GOHead [d| instance SingEq k k => SingEq (AggType k ls as) (AggType k ms bs) |]
  } ''AggType

-- | A non-empty series of /Let/ bindings.
data Bindings k :: ([k] -> k -> Type) -> [k] -> [k] -> Type where
    BNil  :: f vs a -> Bindings k f vs (a ': vs)
    (:<?) :: f vs a -> Bindings k f (a ': vs) us -> Bindings k f vs us


-- ---------
-- > Sorts
-- ---------

-- | Represents the possible sorts encountered in Dhall.
--
-- Note that this implementation allows records of kinds with sorts other
-- than 'Kind', so @{ foo : Kind -> Kind }@ would typecheck, even though
-- normal Dhall forbids this.
--
-- A 'DSort' is always in normal form.
data DSort :: Type where
    Kind    :: DSort
    (:*>)   :: DSort -> DSort -> DSort
    KRecord :: AggType DSort ls as
            -> DSort
    KUnion  :: AggType DSort ls as
            -> DSort

genPolySingWith defaultGPSO
  { gpsoPSK    = GOHead [d| instance PolySingKind DSort |]
  , gpsoSingEq = GOHead [d| instance SingEq DSort DSort |]
  } ''DSort


-- ---------
-- > Kinds
-- ---------

-- | Represents the possible types encountered in Dhall.  A value of type
--
-- @
-- 'DKind' '[r, s] t
-- @
--
-- Describes a kind of sort @t@ with possible kind variables of sorts @r@
-- and @s@.
--
-- Something of type @'DKind' '[] t@ is a kind of sort @t@ with no free
-- variables.
data DKind :: [DSort] -> DSort -> Type where
    KVar  :: Index ts a -> DKind ts a
    KLet  :: Bindings DSort DKind ts ps
          -> DKind ps a
          -> DKind ts a
    KLam  :: SDSort t -> DKind (t ': ts) a -> DKind ts (t ':*> a)
    KApp  :: DKind ts (a ':*> b) -> DKind ts a -> DKind ts b
    (:~>) :: DKind ts 'Kind -> DKind ts 'Kind -> DKind ts 'Kind
    KPi   :: SDSort t -> DKind (t ': ts) a -> DKind ts a
    Type  :: DKind ts 'Kind
    TRecord :: AggType (DKind ts 'Kind) ls as
            -> DKind ts 'Kind
    TUnion  :: AggType (DKind ts 'Kind) ls as
            -> DKind ts 'Kind

    KRecordLit
        :: SAggType DSort ls as at
        -> Prod (DKind ts) as
        -> DKind ts ('KRecord at)
    KUnionLit
        :: SAggType DSort ls as at
        -> Index as a
        -> DKind ts a
        -> DKind ts ('KUnion at)

type a :~> b = a ':~> b
infixr 1 :~>

genPolySingWith defaultGPSO
  { gpsoPSK    = GOHead [d| instance PolySingKind (DKind ts a) |]
  , gpsoSingEq = GOHead [d| instance SingEq (DKind ts a) (DKind ts b) |]
  } ''DKind

type family MaybeKVar (ts :: [DSort]) (a :: DSort) (b :: DSort) (x :: DKind ts a) (i :: Maybe (Index ts b)) :: DKind ts b where
    MaybeKVar ts a a x 'Nothing  = x
    MaybeKVar ts a b x ('Just i) = 'KVar i
    MaybeKVar ts a b x i         = TL.TypeError ('TL.Text "No MaybeKVar")

-- | Substitute in a kind for all occurrences of a kind variable of sort
-- @a@ indicated by the 'Delete' within a kind of osrt @b@.
type family KSub ts ps a b (del :: Delete ts ps a) (x :: DKind ps a) (r :: DKind ts b) :: DKind ps b where
    KSub ts ps a b del x ('KVar i) = MaybeKVar ps a b x (Del ts ps a b del i)
    KSub ts ps a (t ':*> b) del x ('KLam (tt :: SDSort t) r) =
      'KLam tt (KSub (t ': ts) (t ': ps) a b ('DelS del) (KShift ps (t ': ps) t a 'InsZ x) r)
    KSub ts ps a b     del x ('KApp (f :: DKind ts (c ':*> b)) r) =
      'KApp (KSub ts ps a (c ':*> b) del x f) (KSub ts ps a c del x r)
    KSub ts ps a 'Kind del x (r ':~> u) = KSub ts ps a 'Kind del x r ':~> KSub ts ps a 'Kind del x r
    KSub ts ps a  b         del x ('KPi (tt :: SDSort t) r)
        = 'KPi tt (KSub (t ': ts) (t ': ps) a b ('DelS del) (KShift ps (t ': ps) t a 'InsZ x) r)
    KSub ts ps a 'Kind del x 'Type = 'Type
    KSub ts ps a 'Kind del x ('TRecord (at :: AggType (DKind ts 'Kind) ls as))
                = 'TRecord (KSubAT ts ps a del ls as x at)
    KSub ts ps a 'Kind del x ('TUnion (at :: AggType (DKind ts 'Kind) ls as))
                = 'TUnion (KSubAT ts ps a del ls as x at)
    KSub ts ps a ('KRecord (at :: AggType DSort ls fs)) del x ('KRecordLit sat as)
                = 'KRecordLit sat (KSubRec ts ps a ls fs del x at as)
    KSub ts ps a ('KUnion at) del x ('KUnionLit sat i (r :: DKind ts b))
                = 'KUnionLit sat i (KSub ts ps a b del x r)

type family KSubAT ts ps a (del :: Delete ts ps a) ls as x (at :: AggType (DKind ts 'Kind) ls as)
        :: AggType (DKind ps 'Kind) ls (Map (KSubSym ts ps a 'Kind del x) as)
             where
    KSubAT ts ps a del '[] '[] x 'ATZ = 'ATZ
    KSubAT ts ps a del (l ': ls) (b ': bs) x ('ATS m ('WS (r :: SDKind ts 'Kind b)) at)
        = 'ATS m ('WS (TL.TypeError ('TL.Text "this might be a problem")))
                 (KSubAT ts ps a del ls bs x at)

type family KSubRec (ts :: [DSort])
                    (ps :: [DSort])
                    (a :: DSort)
                    (ls :: [Text])
                    (fs :: [DSort])
                    (del :: Delete ts ps a)
                    x
                    (at :: AggType DSort ls fs)
                    (as :: Prod (DKind ts) fs)
                  :: Prod (DKind ps) fs
                    where
    KSubRec ts ps a '[] '[] del x 'ATZ 'Ø = 'Ø
    KSubRec ts ps a (l ': ls) (f ': fs) del x ('ATS m ('WS r) at) (y ':< ys) =
        KSub ts ps a f del x y ':< KSubRec ts ps a ls fs del x at ys

data KSubSym ts ps a b (del :: Delete ts ps a) (x :: DKind ps a) :: DKind ts b ~> DKind ps b
type instance Apply (KSubSym ts ps a b del x) r = KSub ts ps a b del x r

data KShiftSym ts ps a b :: Insert ts ps a -> DKind ts b ~> DKind ps b
type instance Apply (KShiftSym ts ps a b i) x = KShift ts ps a b i x

-- | Shift all kind variables in a kind expression of sort @b@ to account
-- for a new bound variable of sort @a@, to be inserted at the position
-- indicated by the 'Insert'.
type family KShift ts ps a b (ins :: Insert ts ps a) (x :: DKind ts b) :: DKind ps b where
    KShift ts ps a b ins ('KVar i) = 'KVar (Ins ts ps a b ins i)
    KShift ts ps a (t ':*> b) ins ('KLam (tt :: SDSort t) x) =
      'KLam tt (KShift (t ': ts) (t ': ps) a b ('InsS ins) x)
    KShift ts ps a b     ins ('KApp (f :: DKind ts (c ':*> b)) x) =
      'KApp (KShift ts ps a (c ':*> b) ins f) (KShift ts ps a c ins x)
    KShift ts ps a 'Kind ins (x ':~> y) =
        KShift ts ps a 'Kind ins x ':~> KShift ts ps a 'Kind ins y
    KShift ts ps a b ins ('KPi (tt :: SDSort t) x) =
      'KPi tt (KShift (t ': ts) (t ': ps) a b ('InsS ins) x)
    KShift ts ps a 'Kind ins 'Type = 'Type
    KShift ts ps a 'Kind ins ('TRecord (at :: AggType (DKind ts 'Kind) ls as))
                = 'TRecord (KShiftAT ts ps a ins ls as at)
    KShift ts ps a 'Kind ins ('TUnion (at :: AggType (DKind ts 'Kind) ls as))
                = 'TUnion (KShiftAT ts ps a ins ls as at)
    KShift ts ps a ('KRecord (at :: AggType DSort ls fs)) ins ('KRecordLit sat as)
                = 'KRecordLit sat (KShiftRec ts ps a ls fs ins at as)
    KShift ts ps a ('KUnion at) ins ('KUnionLit sat i (x :: DKind ts b))
                = 'KUnionLit sat i (KShift ts ps a b ins x)

type family KShiftAT (ts :: [DSort]) (ps :: [DSort])
                (a :: DSort)
                (ins :: Insert ts ps a)
                (ls :: [Text])
                (as :: [DKind ts 'Kind])
                (at :: AggType (DKind ts 'Kind) ls as)
            :: AggType (DKind ps 'Kind) ls (Map (KShiftSym ts ps a 'Kind ins) as)
             where
    KShiftAT ts ps a ins '[] '[] 'ATZ = 'ATZ
    KShiftAT ts ps a ins (l ': ls) (b ': bs) ('ATS m ('WS (r :: SDKind ts 'Kind b)) at)
        = 'ATS m ('WS (TL.TypeError ('TL.Text "this might be a problem")))
                 (KShiftAT ts ps a ins ls bs at)

type family KShiftRec (ts :: [DSort])
                    (ps :: [DSort])
                    (a :: DSort)
                    (ls :: [Text])
                    (fs :: [DSort])
                    (ins :: Insert ts ps a)
                    (at :: AggType DSort ls fs)
                    (as :: Prod (DKind ts) fs)
                  :: Prod (DKind ps) fs
                    where
    KShiftRec ts ps a '[] '[] ins 'ATZ 'Ø = 'Ø
    KShiftRec ts ps a (l ': ls) (f ': fs) ins ('ATS m ('WS r) at) (y ':< ys) =
        KShift ts ps a f ins y ':< KShiftRec ts ps a ls fs ins at ys



-- | Ideally we would want this to be encodable within the type.  But the
-- main problem here is checking if the LHS of an application is a variable
-- or not.  This is the next best thing?
type family KNormalize ts a (x :: DKind ts a) :: DKind ts a where
    KNormalize ts a          ('KVar i   ) = 'KVar i
    KNormalize ts (t ':*> a) ('KLam tt x) = 'KLam tt (KNormalize (t ': ts) a x)
    KNormalize ts a ('KApp ('KLam (tt :: SDSort t) f) x) =
      KNormalize ts a (KSub (t ': ts) ts t a 'DelZ x f)
    KNormalize ts a ('KApp (f :: DKind ts (r ':*> a)) x) =
      'KApp (KNormalize ts (r ':*> a) f) (KNormalize ts r x)
    KNormalize ts 'Kind      (x ':~> y)   = KNormalize ts 'Kind x ':~> KNormalize ts 'Kind y
    KNormalize ts a          ('KPi (tt :: SDSort t) x)  = 'KPi tt (KNormalize (t ': ts) a x)
    KNormalize ts 'Kind      'Type        = 'Type
    KNormalize ts a t = TL.TypeError ('TL.Text "No KNormalize")

-- | Version of 'SDKind' that exposes itself in normal form.
data NDKind ts a :: DKind ts a -> Type where
    NDK :: SDKind ts a x
        -> NDKind ts a (KNormalize ts a x)

genPolySingWith defaultGPSO
  { gpsoSingI = False
  , gpsoPSK    = GOHead [d| instance PolySingKind (NDKind ts a x) |]
  , gpsoSingEq = GOHead [d| instance SingEq (NDKind ts a x) (NDKind ts b y) |]
  } ''NDKind

-- why doesn't this work?
instance PolySingI ('NDK t)

-- instance PolySingOfI t => PolySingI ('NDK (t :: SDKind ts a x)) where

instance PolySingI ('NDK 'SType) where
    polySing = SNDK (SiSi SType)
    -- KVar  :: Index ts a -> DKind ts a
    -- KLam  :: SDSort t -> DKind (t ': ts) a -> DKind ts (t ':*> a)
    -- KApp  :: DKind ts (a ':*> b) -> DKind ts a -> DKind ts b
    -- (:~>) :: DKind ts 'Kind -> DKind ts 'Kind -> DKind ts 'Kind
    -- KPi   :: SDSort t -> DKind (t ': ts) a -> DKind ts a

data SubbedKind ts t
        :: DKind ts t
        -> DKind (t ': ts) 'Kind
        -> DKind ts 'Kind
        -> Type
      where
    SbKd :: { getSbKd :: SDKind ts t a }
         -> SubbedKind ts t a b (KSub (t ': ts) ts t 'Kind 'DelZ a b)

genPolySingWith defaultGPSO
  { gpsoPSK    = GOHead [d| instance PolySingKind (SubbedKind ts t a b ks) |]
  , gpsoSingEq = GOHead [d| instance SingEq (SubbedKind ts t a b ks) (SubbedKind ts t c b js) |]
  } ''SubbedKind

-- ---------
-- > Types
-- ---------

-- | Represents the possible types encountered in Dhall.  A value of type
--
-- @
-- 'DTerm' '[r, s] '[k, j] a
-- @
--
-- Describes a type of kind @a@ with possible:
--
-- *   Kind variables of sort @r@, @s@
-- *   Type variables of kind @k@, @j@
--
-- Something of type @'DType' '[] '[] a@ is a type of kind @a@ with no free
-- variables.
--
-- Note that the type of "kind-polymorphic values" (functions from kinds to
-- terms) is not yet supported.
--
-- The kinds of the type variables should all be normalized.  All
-- constructors that introduce type variables should normalize
-- automatically, but it's possible create nonsensical types with 'TVar'.
data DType ts :: [DKind ts 'Kind] -> DKind ts 'Kind -> Type where
    TVar  :: Index us a -> DType ts us a
    TLet  :: Bindings (DKind ts 'Kind) (DType ts) us qs
          -> DType ts qs a
          -> DType ts us a
    TLam  :: NDKind ts 'Kind u
          -> DType ts (u ': us) a
          -> DType ts us (u ':~> a)
    TApp  :: DType ts us (a ':~> b) -> DType ts us a -> DType ts us b

    TPoly :: SingSing DSort t ('WS tt)
          -> DType (t ': ts) (Map (KShiftSym ts (t ': ts) t 'Kind 'InsZ) us) a
          -> DType ts us ('KPi tt a)
    TInst :: SingSing DSort t ('WS tt)
          -> DType ts us ('KPi tt b)
          -> SubbedKind ts t a b sk
          -> DType ts us sk

    (:->) :: DType ts us 'Type -> DType ts us 'Type -> DType ts us 'Type
    Pi    :: NDKind ts 'Kind u
          -> DType ts (u ': us) a
          -> DType ts us a

    Bool     :: DType ts us 'Type
    Natural  :: DType ts us 'Type
    List     :: DType ts us ('Type :~> 'Type)
    Optional :: DType ts us ('Type :~> 'Type)

    Record :: AggType (DType ts us 'Type) ls as
           -> DType ts us 'Type
    Union  :: AggType (DType ts us 'Type) ls as
           -> DType ts us 'Type

    TRecordLit
        :: SAggType (DKind ts 'Kind) ls as at
        -> Prod (DType ts us) as
        -> DType ts us ('TRecord at)
    TUnionLit
        :: SAggType (DKind ts 'Kind) ls as at
        -> Index as a
        -> DType ts us a
        -> DType ts us ('TUnion at)

    -- TODO
    -- Pi2   :: SDSort t
    --       -> DType (t ': ts) (Map (KShiftSym ts t 'Kind) us) (KShift ts t 'Kind a)
    --       -> DType ts        us                              a

type (:$)      = 'TApp
type a :-> b   = a ':-> b

infixr 0 :->
infixl 9 `TApp`
infixl 9 :$

genPolySingWith defaultGPSO
  { gpsoPSK    = GOHead [d| instance PolySingKind (DType ts us a) |]
  , gpsoSingEq = GOHead [d| instance SingEq (DType ts us a) (DType ts us b) |]
  } ''DType

-- | Substitute in a type for all occurrences of a type variable of kind
-- @a@ indicated by the 'Delete' within a type of kind @b@.
type family Sub ts us qs a b (del :: Delete us qs a) (x :: DType ts qs a) (r :: DType ts us b) :: DType ts qs b where
    -- TVar  :: Index us a -> DType ts us a
    -- TLam  :: NDKind ts 'Kind u
    --       -> DType ts (u ': us) a
    --       -> DType ts us (u ':~> a)
    -- TApp  :: DType ts us (a ':~> b) -> DType ts us a -> DType ts us b
    -- TPoly :: SingSing DSort t ('WS tt)
    --       -> DType (t ': ts) (Map (KShiftSym ts (t ': ts) t 'Kind 'InsZ) us) a
    --       -> DType ts us ('KPi tt a)
    -- TInst :: SingSing DSort t ('WS tt)
    --       -> DType ts us ('KPi tt b)
    --       -> SubbedKind ts t a b sk
    --       -> DType ts us sk
    -- (:->) :: DType ts us 'Type -> DType ts us 'Type -> DType ts us 'Type
    -- Pi    :: NDKind ts 'Kind u
    --       -> DType ts (u ': us) a
    --       -> DType ts us a
    -- Bool     :: DType ts us 'Type
    -- Natural  :: DType ts us 'Type
    -- List     :: DType ts us ('Type :~> 'Type)
    -- Optional :: DType ts us ('Type :~> 'Type)
    -- Record :: AggType (DType ts us 'Type) ls as
    --        -> DType ts us 'Type
    -- Union  :: AggType (DType ts us 'Type) ls as
    --        -> DType ts us 'Type
    -- TRecordLit
    --     :: SAggType (DKind ts 'Kind) ls as at
    --     -> Prod (DType ts us) as
    --     -> DType ts us ('TRecord at)
    -- TUnionLit
    --     :: SAggType (DKind ts 'Kind) ls as at
    --     -> Index as a
    --     -> DType ts us a
    --     -> DType ts us ('TUnion at)

data ShiftSym ts us qs a b :: Insert us qs a -> DType ts us b ~> DType ts qs b
type instance Apply (ShiftSym ts us qs a b i) x = Shift ts us qs a b i x

-- | Shift all type variables in a type expression of kind @b@ to account
-- for a new bound variable of kind @a@, to be inserted at the position
-- indicated by the 'Insert'.
type family Shift ts us qs a b (ins :: Insert us qs a) (x :: DType ts us b) :: DType ts qs b where

-- | Ideally we would want this to be encodable within the type.  But the
-- main problem here is checking if the LHS of an application is a variable
-- or not.  This is the next best thing?
--
-- Normalizing /applications/ of anonymous type functions (both 'TApp' and
-- 'TInst') is not yet supported. Practically, this means that we can't yet
-- have any values of types that are applications of type functions.
type family TNormalize (ts :: [DSort])
                       (us :: [DKind ts 'Kind])
                       (a  :: DKind ts 'Kind  )
                       (x  :: DType ts us a   )
                     :: DType ts us a where
    TNormalize ts us a          ('TVar i   ) = 'TVar i
    TNormalize ts us (u ':~> a) ('TLam (uu :: NDKind ts 'Kind u) x)
            = 'TLam uu (TNormalize ts (u ': us) a x)
    TNormalize ts us a ('TApp ('TLam u f) x)
            = TL.TypeError ('TL.Text "Normalization of anonymous type function application not yet supported.")
    -- TNormalize ts us a ('TApp ('TLam (NDK (uu :: SDKind ts 'Kind u)) f) x)
    --     = TNormalize ts a (Sub (t ': ts) ts t a 'DelZ x f)
    TNormalize ts us a ('TApp (f :: DType ts us (r ':~> a)) x) =
        'TApp (TNormalize ts us (r ':~> a) f) (TNormalize ts us r x)
    TNormalize ts us ('KPi tt a)
        ('TPoly ('SiSi ss :: SingSing DSort t ('WS tt))
                (x :: DType (t ': ts) (Map (KShiftSym ts (t ': ts) t 'Kind 'InsZ) us) a)
        )
        = 'TPoly ('SiSi ss)     -- sorts are always normalized
                 (TNormalize (t ': ts) (Map (KShiftSym ts (t ': ts) t 'Kind 'InsZ) us) a x)
    TNormalize ts us sk ('TInst ('SiSi ss :: SingSing DSort t ('WS tt))
                                ('TPoly ('SiSi ss) f)
                                (x :: SubbedKind ts t a b sk)
                        )
        = TL.TypeError ('TL.Text "Normalization of anonymous kind-polymorphic type function application not yet supported.")
    TNormalize ts us sk ('TInst ('SiSi ss :: SingSing DSort t ('WS tt))
                                (f :: DType ts us ('KPi tt b))
                                (x :: SubbedKind ts t a b sk)
                        )
        = 'TInst ('SiSi ss)
                 (TNormalize ts us ('KPi tt b) f)
                 x
    TNormalize ts us 'Type (x ':-> y) = TNormalize ts us 'Type x ':-> TNormalize ts us 'Type y
    TNormalize ts us a ('Pi (uu :: NDKind ts 'Kind u) x) = 'Pi uu (TNormalize ts (u ': us) a x)
    TNormalize ts us 'Type 'Bool = 'Bool
    TNormalize ts us 'Type 'Natural = 'Natural
    TNormalize ts us ('Type ':~> 'Type) 'List = 'List
    TNormalize ts us ('Type ':~> 'Type) 'Optional = 'Optional
    TNormalize ts us a t = TL.TypeError ('TL.Text "No TNormalize")

data TNormalizeSym ts us a :: DType ts us a ~> DType ts us a
type instance Apply (TNormalizeSym ts us a) x = TNormalize ts us a x

-- | Version of 'SDType' that exposes itself in normal form.
data NDType ts us a :: DType ts us a -> Type where
    NDT :: SDType ts us a x
        -> NDType ts us a (TNormalize ts us a x)

genPolySingWith defaultGPSO
  { gpsoSingI  = False
  , gpsoPSK    = GOHead [d| instance PolySingKind (NDType ts us a x) |]
  , gpsoSingEq = GOHead [d| instance SingEq (NDType ts us a x) (NDType ts us b y) |]
  } ''NDType


-- ---------
-- > Terms
-- ---------

-- | Primitives of Dhall terms, built into the language.
data Prim ts us :: [DType ts us 'Type] -> DType ts us 'Type -> Type where
    BoolLit       :: Bool -> Prim ts us '[] 'Bool
    BoolAnd       :: Prim ts us '[ 'Bool, 'Bool ] 'Bool
    BoolOr        :: Prim ts us '[ 'Bool, 'Bool ] 'Bool
    NaturalLit    :: Natural -> Prim ts us '[] 'Natural
    NaturalFold   :: Prim ts us '[] ('Natural :-> 'Pi ('NDK 'SType) (('TVar 'IZ :-> 'TVar 'IZ) :-> 'TVar 'IZ :-> 'TVar 'IZ))
    NaturalBuild  :: Prim ts us '[] ('Pi ('NDK 'SType) (('TVar 'IZ :-> 'TVar 'IZ) :-> 'TVar 'IZ :-> 'TVar 'IZ) :-> 'Natural)
    NaturalPlus   :: Prim ts us '[ 'Natural, 'Natural ] 'Natural
    NaturalTimes  :: Prim ts us '[ 'Natural, 'Natural ] 'Natural
    NaturalIsZero :: Prim ts us '[] ('Natural :-> 'Bool)
    ListFold      :: Prim ts us '[] ('Pi ('NDK 'SType) ('List :$ 'TVar 'IZ :-> 'Pi ('NDK 'SType) (('TVar ('IS 'IZ) :-> 'TVar 'IZ :-> 'TVar 'IZ) :-> 'TVar 'IZ :-> 'TVar 'IZ)))
    ListBuild     :: Prim ts us '[] ('Pi ('NDK 'SType) ('Pi ('NDK 'SType) (('TVar ('IS 'IZ) :-> 'TVar 'IZ :-> 'TVar 'IZ) :-> 'TVar 'IZ :-> 'TVar 'IZ) :-> 'List :$ 'TVar 'IZ))
    ListAppend    :: SDType ts us 'Type a
                  -> Prim ts us '[ 'List :$ a, 'List :$ a ] ('List :$ a)
    ListHead      :: Prim ts us '[] ('Pi ('NDK 'SType) ('List :$ 'TVar 'IZ :-> 'Optional :$ 'TVar 'IZ))
    ListLast      :: Prim ts us '[] ('Pi ('NDK 'SType) ('List :$ 'TVar 'IZ :-> 'Optional :$ 'TVar 'IZ))
    ListReverse   :: Prim ts us '[] ('Pi ('NDK 'SType) ('List :$ 'TVar 'IZ :-> 'List     :$ 'TVar 'IZ))
    Some          :: SDType ts us 'Type a -> Prim ts us '[ a ] ('Optional :$ a)
    None          :: Prim ts us '[]    ('Pi ('NDK 'SType) ('Optional :$ 'TVar 'IZ))

genPolySingWith defaultGPSO
  { gpsoPSK    = GOHead [d| instance PolySingKind (Prim ts us as a) |]
  , gpsoSingEq = GOHead [d| instance SingEq (Prim ts us as a) (Prim ts us bs b) |]
  } ''Prim

-- | Represents the possible terms encountered in Dhall.  A value of type
--
-- @
-- 'DTerm' '[r, s] '[k, j] '[a, b, c] d
-- @
--
-- Describes a term of type @d@ with possible:
--
-- *   Kind variables of sort @r@, @s@
-- *   Type variables of kind @k@, @j@
-- *   Variables of type @a@, @b@, @c@
--
-- Something of type @'DTerm' '[] '[] '[] a@ is a term of type @a@ with no
-- free variables.
--
-- Note that "kind-polymorphic values" (functions from kinds to
-- terms) are not yet supported.
data DTerm ts (us :: [DKind ts 'Kind]) :: [DType ts us 'Type] -> DType ts us 'Type -> Type where
    Var  :: Index vs a -> DTerm ts us vs a
    Let  :: Bindings (DType ts us 'Type) (DTerm ts us) vs rs
         -> DTerm ts us rs a
         -> DTerm ts us vs a
    Lam  :: NDType ts us 'Type v
         -> DTerm ts us (v ': vs) a
         -> DTerm ts us vs (v ':-> a)
    App  :: DTerm ts us vs (a ':-> b)
         -> DTerm ts us vs a
         -> DTerm ts us vs b

    Poly :: SNDKind ts 'Kind u uu
         -> DTerm ts (u ': us)
                    (Map (ShiftSym ts us (u ': us)
                         u 'Type 'InsZ) vs
                    ) a
         -> DTerm ts us vs ('Pi uu a)
    Inst :: SNDKind ts 'Kind u uu
         -> DTerm ts us vs ('Pi uu b)
         -> SDType ts us u a
         -> DTerm ts us vs
              (Sub ts (u ': us) us u 'Type 'DelZ a b)

    P    :: Prim ts us as a
         -> Prod (DTerm ts us vs) as
         -> DTerm ts us vs a
    -- TODO: use Seq
    ListLit :: NDType ts us 'Type a
            -> [DTerm ts us vs a]
            -> DTerm ts us vs ('List :$ a)
    OptionalLit :: NDType ts us 'Type a
                -> Maybe (DTerm ts us vs a)
                -> DTerm ts us vs ('Optional :$ a)

    -- TODO: we need to normalize 'as'
    RecordLit
        :: SAggType (DType ts us 'Type) ls as at
        -> Prod (DTerm ts us vs) as
        -> DTerm ts us vs ('Record at)
    UnionLit
        :: SAggType (DType ts us 'Type) ls as at
        -> Index as a
        -> DTerm ts us vs a
        -> DTerm ts us vs ('Union at)

genPolySingWith defaultGPSO
  { gpsoPSK    = GOHead [d| instance PolySingKind (DTerm ts us vs a) |]
  , gpsoSingEq = GOHead [d| instance SingEq (DTerm ts us vs a) (DTerm ts us vs b) |]
  } ''DTerm


-- ----------------
-- > Multiple Level
-- ----------------

data SomeKind :: [DSort] -> Type where
    SomeKind :: SDSort a -> DKind ts a -> SomeKind ts

toSomeKind :: PolySingI a => DKind ts a -> SomeKind ts
toSomeKind = SomeKind polySing

data SomeType ts :: [DKind ts 'Kind] -> Type where
    SomeType :: NDKind ts 'Kind a -> DType ts us a -> SomeType ts us

toSomeType
    :: forall ts us a. (PolySingI a, KNormalize ts 'Kind a ~ a)
    => DType ts us a
    -> SomeType ts us
toSomeType = SomeType (NDK (polySing @_ @a))

data SomeTerm ts us :: [DType ts us 'Type] -> Type where
    SomeTerm :: NDType ts us 'Type a
             -> DTerm ts us vs a
             -> SomeTerm ts us vs

toSomeTerm
    :: forall ts us vs a. (PolySingI a, TNormalize ts us 'Type a ~ a)
    => DTerm ts us vs a -> SomeTerm ts us vs
toSomeTerm = SomeTerm (NDT (polySing @_ @a))


---- | A non-empty series of /Let/ bindings.
--data Bindings k :: ([k] -> k -> Type) -> [k] -> [k] -> Type where
--    BNil  :: f vs a -> Bindings k f vs (a ': vs)
--    (:<?) :: f vs a -> Bindings k f (a ': vs) us -> Bindings k f vs us

--infixr 5 :<?

---- | A value of a polymorphic type.
--data Forall us p k :: DType (k ': us) 'Type -> Type where
--    FA :: { runForall :: forall r. ()
--                      => SDType us k r
--                      -> DTypeRep us p 'Type (Sub (k ': us) us k 'Type 'DelZ r a)
--          }
--       -> Forall us p k a

---- | A value of a polymorphic type, lifted to take a type constructor as
---- a parameter.
--data ForallTC us p j k :: DType (k ': us) (j ':~> 'Type) -> DKindRep j -> Type where
--    FATC :: { runForallTCC
--                :: forall r. ()
--                => SDType us k r
--                -> DTypeRep us p (j ':~> 'Type) (Sub (k ': us) us k (j ':~> 'Type) 'DelZ r a) x
--            }
--         -> ForallTC us p j k a x

---- type family IxProd f as b c (p :: Prod f as) (i :: Index as b) :: f c where

---- | Matches a 'DType' to the actual Haskell type that it represents.
--type family DTypeRep us (p :: Prod (DType us) us) k (x :: DType us k) :: DKindRep k where
--    DTypeRep us p k                  ('TVar i)                   = DTypeRep us p k (IxProd (DType us) us k p i)
--    DTypeRep us p 'Type              ('Pi (u :: SDKind a) t)     = Forall us p a t
--    DTypeRep us p (k ':~> 'Type)     ('Pi (u :: SDKind a) t)     = ForallTC us p k a t
--    DTypeRep us p k                  ((f :: DType us (r ':~> k)) ':$ (x :: DType us r))
--        = DTypeRep us p (r ':~> k) f (DTypeRep us p r x)
--    DTypeRep us p 'Type              (a ':-> b) = DTypeRep us p 'Type a -> DTypeRep us p 'Type b
--    DTypeRep us p 'Type              'Bool      = Bool
--    DTypeRep us p 'Type              'Natural   = Natural
--    DTypeRep us p ('Type ':~> 'Type) 'List      = Seq
--    DTypeRep us p ('Type ':~> 'Type) 'Optional  = Maybe
--    DTypeRep us p k                  x          = TL.TypeError ('TL.Text "No DTypeRep: " 'TL.:<>: 'TL.ShowType '(k, x))

--type family MaybeVar a b (x :: DType vs a) (i :: Maybe (Index vs b)) :: DType vs b where
--    MaybeVar a a x 'Nothing  = x
--    MaybeVar a b x ('Just i) = 'TVar i
--    MaybeVar a b x i = TL.TypeError ('TL.Text "No Maybe: " 'TL.:<>: 'TL.ShowType '(x, i))

---- | Shift all variables to accomodate for a new bound variable.
--type family Shift as bs a b (ins :: Insert as bs a) (x :: DType as b) :: DType bs b where
--    Shift as bs a b   ins ('TVar i) = 'TVar (Ins as bs a b ins i)
--    Shift as bs a b   ins ('Pi (u :: SDKind k) e) = 'Pi u (Shift (k ': as) (k ': bs) a b ('InsS ins) e)
--    Shift as bs a r i ((u :: DType as (k ':~> r)) ':$ (v :: DType as k))
--        = Shift as bs a (k ':~> r) i u ':$ Shift as bs a k i v
--    Shift as bs a 'Type              i (u ':-> v) = Shift as bs a 'Type i u ':-> Shift as bs a 'Type i v
--    Shift as bs a 'Type              i 'Bool     = 'Bool
--    Shift as bs a 'Type              i 'Natural  = 'Natural
--    Shift as bs a ('Type ':~> 'Type) i 'List     = 'List
--    Shift as bs a ('Type ':~> 'Type) i 'Optional = 'Optional
--    Shift as bs a b ins x = TL.TypeError ('TL.Text "No Shift: " 'TL.:<>: 'TL.ShowType '(as, bs, a, b, ins, x))

---- | Substitute in a value for a given variable.
--type family Sub as bs a b (d :: Delete as bs a) (x :: DType bs a) (r :: DType as b) :: DType bs b where
--    Sub as bs a b                  d x ('TVar i)
--        = MaybeVar a b x (Del as bs a b d i)
--    Sub as bs a b                  d x ('Pi (u :: SDKind k) e)
--        = 'Pi u (Sub (k ': as) (k ': bs) a b ('DS d) (Shift bs (k ': bs) k a 'InsZ x) e)
--    Sub as bs a b                  d x ((i :: DType as (k ':~> b)) ':$ (j :: DType as k))
--        = Sub as bs a (k ':~> b) d x i ':$ Sub as bs a k d x j
--    Sub as bs a 'Type              d x (i ':-> j)
--        = Sub as bs a 'Type d x i ':-> Sub as bs a 'Type d x j
--    Sub as bs a 'Type              d x 'Bool
--        = 'Bool
--    Sub as bs a 'Type              d x 'Natural
--        = 'Natural
--    Sub as bs a ('Type ':~> 'Type) d x 'List
--        = 'List
--    Sub as bs a ('Type ':~> 'Type) d x 'Optional
--        = 'Optional
--    Sub as bs a b d x r
--        = TL.TypeError ('TL.Text "No Sub: " 'TL.:<>: 'TL.ShowType '(as, bs, a, b, d, x, r))

---- | Find the kind of a type singleton with no free variables.
--kindOf :: SDType '[] k t -> SDKind k
--kindOf = kindOfWith Ø

---- | Find the kind of a type singleton with free variables by providing the
---- kinds of each free variable.
--kindOfWith :: Prod SDKind us -> SDType us k t -> SDKind k
--kindOfWith vs = \case
--    STVar i -> ixProd vs (fromSIndex i)
--    SPi u e -> kindOfWith (u :< vs) e
--    f :%$ _ -> case kindOfWith vs f of
--      _ :%~> r -> r
--    _ :%-> _ -> SType
--    SBool -> SType
--    SNatural -> SType
--    SList -> SType :%~> SType
--    SOptional -> SType :%~> SType

--type family MapShift (k :: DKind) (us :: [DKind]) (vs :: [DType us 'Type]) :: [DType (k ': us) 'Type] where
--    MapShift k us '[]       = '[]
--    MapShift k us (v ': vs) = Shift us (k ': us) k 'Type 'InsZ v ': MapShift k us vs

--data SomeTerm us :: [DType us 'Type] -> Type where
--    SomeTerm :: SDType us 'Type a
--             -> DTerm us vs a
--             -> SomeTerm us vs

---- | Find the type of a term singleton with no free variables.
--typeOf :: SDTerm '[] '[] a x -> SDType '[] 'Type a
--typeOf = typeOfWith Ø

---- | Find the type of a term singleton with free variables by providing the
---- type of each free variable.
--typeOfWith :: Prod (SDType us 'Type) vs -> SDTerm us vs a x -> SDType us 'Type a
--typeOfWith vs = \case
--    SVar i            -> ixProd vs (fromSIndex i)
--    SLam t x          -> t :%-> typeOfWith (t :< vs) x
--    SApp f _          -> case typeOfWith vs f of
--      _ :%-> r -> r
--    STLam u x         -> SPi u $ typeOfWith (shiftProd vs) x
--    STApp f x         -> case typeOfWith vs f of
--      SPi _ g  -> sSub x g
--    SBoolLit _        -> SBool
--    SNaturalLit _     -> SNatural
--    SNaturalFold      -> SNatural :%-> SPi SType ((STVar SIZ :%-> STVar SIZ) :%-> STVar SIZ :%-> STVar SIZ)
--    SNaturalBuild     -> SPi SType ((STVar SIZ :%-> STVar SIZ) :%-> STVar SIZ :%-> STVar SIZ) :%-> SNatural
--    SNaturalPlus _ _  -> SNatural
--    SNaturalTimes _ _ -> SNatural
--    SNaturalIsZero    -> SNatural :%-> SBool
--    SListLit _ a _    -> SList :%$ a
--    SListFold         -> SPi SType (SList :%$ STVar SIZ :%-> SPi SType ((STVar (SIS SIZ) :%-> STVar SIZ :%-> STVar SIZ) :%-> STVar SIZ :%-> STVar SIZ))
--    SListBuild        -> SPi SType (SPi SType ((STVar (SIS SIZ) :%-> STVar SIZ :%-> STVar SIZ) :%-> STVar SIZ :%-> STVar SIZ) :%-> SList :%$ STVar SIZ)
--    SListAppend xs _  -> typeOfWith vs xs
--    SListHead         -> SPi SType (SList :%$ STVar SIZ :%-> SOptional :%$ STVar SIZ)
--    SListLast         -> SPi SType (SList :%$ STVar SIZ :%-> SOptional :%$ STVar SIZ)
--    SListReverse      -> SPi SType (SList :%$ STVar SIZ :%-> SList     :%$ STVar SIZ)
--    SOptionalLit a _  -> SOptional :%$ a
--    SSome x           -> SOptional :%$ typeOfWith vs x
--    SNone             -> SPi SType (SOptional :%$ STVar SIZ)

--shiftProd
--    :: forall us vs k. ()
--    => Prod (SDType us        'Type) vs
--    -> Prod (SDType (k ': us) 'Type) (MapShift k us vs)
--shiftProd = \case
--    Ø       -> Ø
--    x :< xs -> sShift x :< shiftProd xs


---- | Turn a 'DTerm' with no free variables into a Haskell value of the
---- appropriate type.
--fromTerm :: DTerm '[] '[] a -> DTypeRep '[] 'Ø 'Type a
--fromTerm = fromTermWith Ø

--type family ShiftProd as bs k (p :: Prod (DType bs) as) :: Prod (DType (k ': bs)) as where
--    ShiftProd '[]       bs k 'Ø         = 'Ø
--    ShiftProd (a ': as) bs k (x ':< xs) = Shift bs (k ': bs) k a 'InsZ x ':< ShiftProd as bs k xs

--type family Reassign as bs a (p :: Prod (DType bs) as) (r :: DType as a) :: DType bs a where
--    Reassign as bs a p ('TVar i) = IxProd (DType bs) as a p i
--    Reassign as bs a p ('Pi (u :: SDKind k) e)
--        = 'Pi u (Reassign (k ': as) (k ': bs) a ('TVar 'IZ ':< ShiftProd as bs k p) e)
--    Reassign as bs k p ((i :: DType as (r ':~> k)) ':$ (j :: DType as r))
--        = Reassign as bs (r ':~> k) p i ':$ Reassign as bs r p j
--    Reassign as bs 'Type p (i ':-> j)
--        = Reassign as bs 'Type p i ':-> Reassign as bs 'Type p j
--    Reassign as bs 'Type p 'Bool = 'Bool
--    Reassign as bs 'Type p 'Natural = 'Natural
--    Reassign as bs ('Type ':~> 'Type) p 'List = 'List
--    Reassign as bs ('Type ':~> 'Type) p 'Optional = 'Optional

--type family MapReassign as bs a (p :: Prod (DType bs) as) (rs :: [DType as a]) :: [DType bs a] where
--    MapReassign as bs a p '[]       = '[]
--    MapReassign as bs a p (x ': xs) = Reassign as bs a p x ': MapReassign as bs a p xs

--reassignIndex
--    :: forall us vs qs a p. ()
--    => Index vs a
--    -> Index (MapReassign us qs 'Type p vs) (Reassign us qs 'Type p a)
--reassignIndex = \case
--    IZ   -> IZ
--    IS i -> IS (reassignIndex @_ @_ @_ @_ @p i)

--shiftSProd
--    :: SProd (DType qs) us p
--    -> SProd (DType (a ': qs)) us (ShiftProd us qs a p)
--shiftSProd = \case
--    SØ -> SØ
--    SDTy x :%< xs -> SDTy (sShift x) :%< shiftSProd xs

--reTyVar
--    :: SProd (DType qs) us p
--    -> SDType us k a
--    -> SDType qs k (Reassign us qs k p a)
--reTyVar p = \case
--    STVar i   -> getSDTy $ sIxProd p i
--    SPi u x   -> SPi u (reTyVar (SDTy (STVar SIZ) :%< shiftSProd p) x)
--    f :%$ x   -> reTyVar p f :%$ reTyVar p x
--    x :%-> y  -> reTyVar p x :%-> reTyVar p y
--    SBool     -> SBool
--    SNatural  -> SNatural
--    SList     -> SList
--    SOptional -> SOptional

--reTyVarBindings
--    :: SProd (DType qs) us p
--    -> Bindings (DType us 'Type) (DTerm us) vs rs
--    -> Bindings (DType qs 'Type) (DTerm qs) (MapReassign us qs 'Type p vs) (MapReassign us qs 'Type p rs)
--reTyVarBindings qs = \case
--    BNil x   -> BNil $ reTyVarTerm qs x
--    x :<? xs -> reTyVarTerm qs x :<? reTyVarBindings qs xs

--reTyVarTerm
--    :: forall us vs qs a p. ()
--    => SProd (DType qs) us p
--    -> DTerm us vs a
--    -> DTerm qs (MapReassign us qs 'Type p vs) (Reassign us qs 'Type p a)
--reTyVarTerm qs = \case
--    Var i            -> Var (reassignIndex @_ @_ @_ @_ @p i)
--    Lam t f          -> Lam (reTyVar qs t) (reTyVarTerm qs f)
--    App f x          -> App (reTyVarTerm qs f) (reTyVarTerm qs x)
--    TLam u f         -> TLam u . unsafeCoerce $ reTyVarTerm (SDTy (STVar SIZ) :%< shiftSProd qs) f  -- !!
--    TApp f x         -> unsafeCoerce $ TApp (reTyVarTerm qs f) (reTyVar qs x)                       -- !!
--    Let bs x         -> Let (reTyVarBindings qs bs) (reTyVarTerm qs x)
--    BoolLit b        -> BoolLit b
--    NaturalLit n     -> NaturalLit n
--    NaturalFold      -> NaturalFold
--    NaturalBuild     -> NaturalBuild
--    NaturalPlus x y  -> NaturalPlus (reTyVarTerm qs x) (reTyVarTerm qs y)
--    NaturalTimes x y -> NaturalTimes (reTyVarTerm qs x) (reTyVarTerm qs y)
--    NaturalIsZero    -> NaturalIsZero
--    ListLit t xs     -> ListLit (reTyVar qs t) (reTyVarTerm qs <$> xs)
--    ListFold         -> ListFold
--    ListBuild        -> ListBuild
--    ListAppend xs ys -> ListAppend (reTyVarTerm qs xs) (reTyVarTerm qs ys)
--    ListHead         -> ListHead
--    ListLast         -> ListLast
--    ListReverse      -> ListReverse
--    OptionalLit t xs -> OptionalLit (reTyVar qs t) (reTyVarTerm qs <$> xs)
--    Some x           -> Some (reTyVarTerm qs x)
--    None             -> None

---- | Newtype wrapper over a Haskell value of the 'DTypeRep' of that term.
--newtype DTypeRepVal us p (a :: DType us 'Type) = DTRV { getDTRV :: DTypeRep us p 'Type a }

--fromBindings
--    :: Prod (DTypeRepVal '[] 'Ø) vs
--    -> Bindings (DType '[] 'Type) (DTerm '[]) vs us
--    -> Prod (DTypeRepVal '[] 'Ø) us
--fromBindings vs = \case
--    BNil b   -> DTRV (fromTermWith vs b) :< vs
--    b :<? bs -> fromBindings (DTRV (fromTermWith vs b) :< vs) bs

---- | Turn a 'DTerm' with free variables into a Haskell value of the
---- appropriate type by providing values for each free variable.
--fromTermWith
--    :: forall vs a. ()
--    => Prod (DTypeRepVal '[] 'Ø) vs
--    -> DTerm '[] vs a
--    -> DTypeRep '[] 'Ø 'Type a
--fromTermWith vs = \case
--    Var i            -> getDTRV $ ixProd vs i
--    Lam _ x          -> \y -> fromTermWith (DTRV y :< vs) x
--    Let bs x         -> fromTermWith (fromBindings vs bs) x
--    App f x          -> fromTermWith vs f (fromTermWith vs x)
--    TLam _ f         -> FA $ \t -> unsafeCoerce $
--        fromTermWith (unsafeCoerce vs) (reTyVarTerm (SDTy t :%< SØ) f)
--    TApp f x         -> runForall (fromTermWith vs f) x
--    BoolLit b        -> b
--    NaturalLit n     -> n
--    NaturalFold      -> \n -> FA $ \_ s z -> naturalFold n s z
--    NaturalBuild     -> \f -> runForall f SNatural (+ 1) 0
--    NaturalPlus x y  -> fromTermWith vs x + fromTermWith vs y
--    NaturalTimes x y -> fromTermWith vs x * fromTermWith vs y
--    NaturalIsZero    -> (== 0)
--    ListLit _ xs     -> fromTermWith vs <$> xs
--    ListFold         -> FA $ \a xs -> FA $ \l cons nil -> case subIns a l of
--                          Refl -> foldr cons nil xs
--    -- TODO: we need new way to encode FA, since this is gross now with new
--    -- system
--    ListBuild        -> FA $ \a f -> case subIns a (SList :%$ a) of
--        Refl -> runForall f (SList :%$ a) (Seq.<|) Seq.empty
--    ListAppend xs ys -> fromTermWith vs xs <> fromTermWith vs ys
--    ListHead         -> FA $ \_ -> \case x Seq.:<| _ -> Just x
--                                         Seq.Empty   -> Nothing
--    ListLast         -> FA $ \_ -> \case _ Seq.:|> x -> Just x
--                                         Seq.Empty   -> Nothing
--    ListReverse      -> FA $ \_ -> Seq.reverse
--    OptionalLit _ x  -> fromTermWith vs <$> x
--    Some x           -> Just $ fromTermWith vs x
--    None             -> FA $ \_ -> Nothing

---- | Attempt to convert a Haskell value into a 'DTerm' with no free
---- variables.  This will fail if you attempt to convert any Haskell
---- functions @a -> b@, since we cannot encode these in general into
---- a finite language like Dhall.
--toTerm :: SDType '[] 'Type a -> DTypeRep '[] 'Ø 'Type a -> Maybe (DTerm '[] '[] a)
--toTerm = \case
--    STVar i         -> \_ -> Just $ case i of {}
--    SPi _ _         -> \_ -> Nothing
--    _ :%-> _        -> \_ -> Nothing
--    SBool           -> Just . BoolLit
--    SNatural        -> Just . NaturalLit
--    f :%$ x         -> toTermT f x

--toTermT
--    :: SDType '[] (k ':~> 'Type) f
--    -> SDType '[] k              b
--    -> DTypeRep '[] 'Ø 'Type (f ':$ b)
--    -> Maybe (DTerm '[] '[] (f ':$ b))
--toTermT = \case
--    STVar i   -> \_ -> const $ Just (case i of {})
--    SPi _ _   -> \_ -> const Nothing
--    SList     -> \a -> fmap (ListLit a) . traverse (toTerm a)
--    SOptional -> \a -> maybe (Just (None `TApp` a)) (fmap Some . toTerm a)
--    _ :%$ _   -> \_ -> const Nothing        -- ??

--naturalFold :: Natural -> (a -> a) -> a -> a
--naturalFold n s = go n
--  where
--    go 0 !x = x
--    go i !x = go (i - 1) (s x)

--data SomeExpr us :: [DType us 'Type] -> Type where
--    SEKind :: DKind          -> SomeExpr us vs
--    SEType :: SomeType us    -> SomeExpr us vs
--    SETerm :: SomeTerm us vs -> SomeExpr us vs

---- | Required equality witness for using a type variable under a 'TLam'.
----
---- This is automatically resolved if you turn on the typechecker plugin.
----
---- @
---- {-# OPTIONS_GHC -fplugin Dhall.Typed.Plugin #-}
---- @
--subIns
--    :: forall k j a b. ()
--    => SDType '[] k a
--    -> SDType '[] j b
--    -> (a :~: Sub '[j] '[] j k ('DelZ :: Delete '[j] '[] j) b (Shift '[] '[j] j k ('InsZ :: Insert '[] '[j] j) a))
--subIns _ _ = unsafeCoerce $ Refl @a

---- | Like 'subIns', but for two layers of 'TLam'.
----
---- This is automatically resolved if you turn on the typechecker plugin.
---- The typechecker plugin will solve arbitrarily nested layers.
----
---- @
---- {-# OPTIONS_GHC -fplugin Dhall.Typed.Plugin #-}
---- @
--subIns2
--    :: SDType '[] k a
--    -> SDType '[] j b
--    -> SDType '[] l c
--    -> (a :~:
--        Sub '[ l ] '[] l k 'DelZ c
--          (Sub '[l, j] '[ l ] j k ('DS 'DelZ) (Shift '[] '[ l ] l j 'InsZ b)
--              (Shift '[ j ] '[ l, j ] l k 'InsZ
--                 (Shift '[] '[ j ] j k 'InsZ a)
--              )
--          )
--       )
--subIns2 _ _ _ = unsafeCoerce $ Refl

---- | Allows you to use a type variable "under" a 'TLam'.
--sShift
--    :: SDType as k x
--    -> SDType (a ': as) k (Shift as (a ': as) a k 'InsZ x)
--sShift = sShift_ SInsZ

---- | Like 'sShift', but can shift a type variable under multiple 'TLam's.
----
---- Providing 'SInsZ' will shift a single layer, @'SInsS' 'SInsZ'@ will
---- shift two layers, etc.
--sShift_
--    :: SInsert as bs a ins
--    -> SDType as b x
--    -> SDType bs b (Shift as bs a b ins x)
--sShift_ ins = \case
--    STVar i   -> STVar (sInsert ins i)
--    SPi u e   -> SPi u (sShift_ (SInsS ins) e)
--    u :%$ v   -> sShift_ ins u :%$ sShift_ ins v
--    u :%-> v  -> sShift_ ins u :%-> sShift_ ins v
--    SBool     -> SBool
--    SNatural  -> SNatural
--    SList     -> SList
--    SOptional -> SOptional

---- | Substitute a type into the first free variable of a type expression.
--sSub
--    :: SDType bs a x
--    -> SDType (a ': bs) b r
--    -> SDType bs b (Sub (a ': bs) bs a b 'DelZ x r)
--sSub = sSub_ SDelZ

---- | Substitute a type into the Nth free variable of a type expression.
---- Providing 'DelZ' will substitute in the first free variable, providing
---- @'DS' 'DelZ'@ will substitute in the second free variable, etc.
--sSub_
--    :: SDelete as bs c del
--    -> SDType bs c x
--    -> SDType as b r
--    -> SDType bs b (Sub as bs c b del x r)
--sSub_ del x = \case
--    STVar i -> case sDelete del i of
--      GotDeleted Refl -> x
--      ThatsToxic j    -> STVar j
--    SPi u e -> SPi u $ sSub_ (SDS del) (sShift x) e
--    u :%$  v  -> sSub_ del x u :%$  sSub_ del x v
--    u :%-> v  -> sSub_ del x u :%-> sSub_ del x v
--    SBool     -> SBool
--    SNatural  -> SNatural
--    SList     -> SList
--    SOptional -> SOptional

-- -- | Syntax tree for expressions
-- data Expr s a
--     = Const Const
--     | Var Var
--     | Lam Text (Expr s a) (Expr s a)
--     | Pi  Text (Expr s a) (Expr s a)
--     | App (Expr s a) (Expr s a)
--     | Let (NonEmpty (Binding s a)) (Expr s a)
--     | Annot (Expr s a) (Expr s a)
--     | Bool
--     | BoolLit Bool
--     | BoolAnd (Expr s a) (Expr s a)
--     | BoolOr  (Expr s a) (Expr s a)
--     | BoolEQ  (Expr s a) (Expr s a)
--     | BoolNE  (Expr s a) (Expr s a)
--     | BoolIf (Expr s a) (Expr s a) (Expr s a)
--     | Natural
--     | NaturalLit Natural
--     | NaturalFold
--     | NaturalBuild
--     | NaturalIsZero
--     | NaturalEven
--     | NaturalOdd
--     | NaturalToInteger
--     | NaturalShow
--     | NaturalPlus (Expr s a) (Expr s a)
--     | NaturalTimes (Expr s a) (Expr s a)
--     | Integer
--     | IntegerLit Integer
--     | IntegerShow
--     | IntegerToDouble
--     | Double
--     | DoubleLit Double
--     | DoubleShow
--     | Text
--     | TextLit (Chunks s a)
--     | TextAppend (Expr s a) (Expr s a)
--     | List
--     | ListLit (Maybe (Expr s a)) (Seq (Expr s a))
--     | ListAppend (Expr s a) (Expr s a)
--     | ListBuild
--     | ListFold
--     | ListLength
--     | ListHead
--     | ListLast
--     | ListIndexed
--     | ListReverse
--     | Optional
--     | OptionalLit (Expr s a) (Maybe (Expr s a))
--     | Some (Expr s a)
--     | None
--     | OptionalFold
--     | OptionalBuild
--     | Record    (Map Text (Expr s a))
--     | RecordLit (Map Text (Expr s a))
--     | Union     (Map Text (Expr s a))
--     | UnionLit Text (Expr s a) (Map Text (Expr s a))
--     | Combine (Expr s a) (Expr s a)
--     | CombineTypes (Expr s a) (Expr s a)
--     | Prefer (Expr s a) (Expr s a)
--     | Merge (Expr s a) (Expr s a) (Maybe (Expr s a))
--     | Constructors (Expr s a)
--     | Field (Expr s a) Text
--     | Project (Expr s a) (Set Text)
--     | Note s (Expr s a)
--     | ImportAlt (Expr s a) (Expr s a)
--     | Embed a
--     deriving (Eq, Foldable, Generic, Traversable, Show, Data)





-- -- | Syntax tree for expressions
-- data Expr s a
--     -- | > Const c                                  ~  c
--     = Const Const
--     -- | > Var (V x 0)                              ~  x
--     --   > Var (V x n)                              ~  x@n
--     | Var Var
--     -- | > Lam x     A b                            ~  λ(x : A) -> b
--     | Lam Text (Expr s a) (Expr s a)
--     -- | > Pi "_" A B                               ~        A  -> B
--     --   > Pi x   A B                               ~  ∀(x : A) -> B
--     | Pi  Text (Expr s a) (Expr s a)
--     -- | > App f a                                  ~  f a
--     | App (Expr s a) (Expr s a)
--     -- | > Let [Binding x Nothing  r] e             ~  let x     = r in e
--     --   > Let [Binding x (Just t) r] e             ~  let x : t = r in e
--     | Let (NonEmpty (Binding s a)) (Expr s a)
--     -- | > Annot x t                                ~  x : t
--     | Annot (Expr s a) (Expr s a)
--     -- | > Bool                                     ~  Bool
--     | Bool
--     -- | > BoolLit b                                ~  b
--     | BoolLit Bool
--     -- | > BoolAnd x y                              ~  x && y
--     | BoolAnd (Expr s a) (Expr s a)
--     -- | > BoolOr  x y                              ~  x || y
--     | BoolOr  (Expr s a) (Expr s a)
--     -- | > BoolEQ  x y                              ~  x == y
--     | BoolEQ  (Expr s a) (Expr s a)
--     -- | > BoolNE  x y                              ~  x != y
--     | BoolNE  (Expr s a) (Expr s a)
--     -- | > BoolIf x y z                             ~  if x then y else z
--     | BoolIf (Expr s a) (Expr s a) (Expr s a)
--     -- | > Natural                                  ~  Natural
--     | Natural
--     -- | > NaturalLit n                             ~  n
--     | NaturalLit Natural
--     -- | > NaturalFold                              ~  Natural/fold
--     | NaturalFold
--     -- | > NaturalBuild                             ~  Natural/build
--     | NaturalBuild
--     -- | > NaturalIsZero                            ~  Natural/isZero
--     | NaturalIsZero
--     -- | > NaturalEven                              ~  Natural/even
--     | NaturalEven
--     -- | > NaturalOdd                               ~  Natural/odd
--     | NaturalOdd
--     -- | > NaturalToInteger                         ~  Natural/toInteger
--     | NaturalToInteger
--     -- | > NaturalShow                              ~  Natural/show
--     | NaturalShow
--     -- | > NaturalPlus x y                          ~  x + y
--     | NaturalPlus (Expr s a) (Expr s a)
--     -- | > NaturalTimes x y                         ~  x * y
--     | NaturalTimes (Expr s a) (Expr s a)
--     -- | > Integer                                  ~  Integer
--     | Integer
--     -- | > IntegerLit n                             ~  ±n
--     | IntegerLit Integer
--     -- | > IntegerShow                              ~  Integer/show
--     | IntegerShow
--     -- | > IntegerToDouble                          ~  Integer/toDouble
--     | IntegerToDouble
--     -- | > Double                                   ~  Double
--     | Double
--     -- | > DoubleLit n                              ~  n
--     | DoubleLit Double
--     -- | > DoubleShow                               ~  Double/show
--     | DoubleShow
--     -- | > Text                                     ~  Text
--     | Text
--     -- | > TextLit (Chunks [(t1, e1), (t2, e2)] t3) ~  "t1${e1}t2${e2}t3"
--     | TextLit (Chunks s a)
--     -- | > TextAppend x y                           ~  x ++ y
--     | TextAppend (Expr s a) (Expr s a)
--     -- | > List                                     ~  List
--     | List
--     -- | > ListLit (Just t ) [x, y, z]              ~  [x, y, z] : List t
--     --   > ListLit  Nothing  [x, y, z]              ~  [x, y, z]
--     | ListLit (Maybe (Expr s a)) (Seq (Expr s a))
--     -- | > ListAppend x y                           ~  x # y
--     | ListAppend (Expr s a) (Expr s a)
--     -- | > ListBuild                                ~  List/build
--     | ListBuild
--     -- | > ListFold                                 ~  List/fold
--     | ListFold
--     -- | > ListLength                               ~  List/length
--     | ListLength
--     -- | > ListHead                                 ~  List/head
--     | ListHead
--     -- | > ListLast                                 ~  List/last
--     | ListLast
--     -- | > ListIndexed                              ~  List/indexed
--     | ListIndexed
--     -- | > ListReverse                              ~  List/reverse
--     | ListReverse
--     -- | > Optional                                 ~  Optional
--     | Optional
--     -- | > OptionalLit t (Just e)                   ~  [e] : Optional t
--     --   > OptionalLit t Nothing                    ~  []  : Optional t
--     | OptionalLit (Expr s a) (Maybe (Expr s a))
--     -- | > Some e                                   ~  Some e
--     | Some (Expr s a)
--     -- | > None                                     ~  None
--     | None
--     -- | > OptionalFold                             ~  Optional/fold
--     | OptionalFold
--     -- | > OptionalBuild                            ~  Optional/build
--     | OptionalBuild
--     -- | > Record       [(k1, t1), (k2, t2)]        ~  { k1 : t1, k2 : t1 }
--     | Record    (Map Text (Expr s a))
--     -- | > RecordLit    [(k1, v1), (k2, v2)]        ~  { k1 = v1, k2 = v2 }
--     | RecordLit (Map Text (Expr s a))
--     -- | > Union        [(k1, t1), (k2, t2)]        ~  < k1 : t1 | k2 : t2 >
--     | Union     (Map Text (Expr s a))
--     -- | > UnionLit k v [(k1, t1), (k2, t2)]        ~  < k = v | k1 : t1 | k2 : t2 >
--     | UnionLit Text (Expr s a) (Map Text (Expr s a))
--     -- | > Combine x y                              ~  x ∧ y
--     | Combine (Expr s a) (Expr s a)
--     -- | > CombineTypes x y                         ~  x ⩓ y
--     | CombineTypes (Expr s a) (Expr s a)
--     -- | > Prefer x y                               ~  x ⫽ y
--     | Prefer (Expr s a) (Expr s a)
--     -- | > Merge x y (Just t )                      ~  merge x y : t
--     --   > Merge x y  Nothing                       ~  merge x y
--     | Merge (Expr s a) (Expr s a) (Maybe (Expr s a))
--     -- | > Constructors e                           ~  constructors e
--     | Constructors (Expr s a)
--     -- | > Field e x                                ~  e.x
--     | Field (Expr s a) Text
--     -- | > Project e xs                             ~  e.{ xs }
--     | Project (Expr s a) (Set Text)
--     -- | > Note s x                                 ~  e
--     | Note s (Expr s a)
--     -- | > ImportAlt                                ~  e1 ? e2
--     | ImportAlt (Expr s a) (Expr s a)
--     -- | > Embed import                             ~  import
--     | Embed a
--     deriving (Eq, Foldable, Generic, Traversable, Show, Data)


